{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///rekapi.js","webpack:///webpack/bootstrap c902aadf42148c491eea","webpack:///./src/rekapi.js","webpack:///./src/utils.js","webpack:///external \"shifty\"","webpack:///./src/actor.js","webpack:///./src/keyframe-property.js","webpack:///(webpack)/buildin/global.js","webpack:///./src/renderers/canvas.js","webpack:///./src/renderers/dom.js","webpack:///./~/lodash.sortedindexby/index.js","webpack:///(webpack)/buildin/module.js","webpack:///./src/main.js"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_2__","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","global","_classCallCheck","instance","Constructor","TypeError","_toConsumableArray","arr","Array","isArray","arr2","length","from","Rekapi","rendererBootstrappers","updateToCurrentMillisecond","updateToMillisecond","calculateLoopPosition","updatePlayState","isAnimationComplete","calculateTimeSinceStart","determineCurrentLoopIteration","invalidateAnimationLength","fireEvent","DEFAULT_EASING","undefined","_createClass","defineProperties","target","props","descriptor","writable","key","protoProps","staticProps","_shifty","_actor","_utils","rekapi","eventName","data","arguments","_events","forEach","handler","_animationLengthValid","timeSinceStart","animationLength","getAnimationLength","Math","floor","Tweenable","now","_loopTimestamp","currentLoopIteration","_timesToIterate","stop","forMillisecond","currentIteration","loopPosition","_loopPosition","keyframeResetList","_latestIteration","_actors","actor","_keyframeProperties","fnKeyframes","keys","reduce","acc","propertyId","push","lastFnKeyframe","hasFired","invoke","apply","update","fnKeyframe","tick","_loopId","_scheduleUpdate","_updateFn","setTimeout","getUpdateMethod","requestAnimationFrame","webkitRequestAnimationFrame","oRequestAnimationFrame","msRequestAnimationFrame","mozCancelRequestAnimationFrame","mozRequestAnimationFrame","getCancelMethod","cancelAnimationFrame","webkitCancelAnimationFrame","oCancelAnimationFrame","msCancelAnimationFrame","clearTimeout","cancelLoop","_cancelUpdate","STOPPED","_this","context","_playState","sort","animationComplete","playStateChange","play","pause","beforeUpdate","afterUpdate","addActor","removeActor","beforeAddKeyframeProperty","addKeyframeProperty","removeKeyframeProperty","removeKeyframePropertyComplete","beforeRemoveKeyframeProperty","addKeyframePropertyTrack","removeKeyframePropertyTrack","timelineModified","animationLooped","_animationLength","_pausedAtTime","_lastUpdatedMillisecond","renderers","map","renderer","filter","_","rekapiActor","Actor","indexOf","setup","actorId","id","slice","without","teardown","_this2","getAllActors","iterations","millisecond","_resetFnKeyframesFromMillisecond","playFrom","doResetLaterFnKeyframes","a","b","_updateState","wasActive","render","max","getEnd","_ref","_ref$withId","withId","exportData","duration","actors","exportTimeline","formulas","filteredFormulas","formulaName","x1","pickProps","curves","formula","displayName","pick","rekapiData","_this3","each","curve","curveName","setBezierFunction","y1","x2","y2","actorData","importTimeline","rendererConstructor","position","splice","incrementer","clone","obj","assign","difference","values","fn","intersection","arr1","el","keyNames","keyName","val","reject","uniq","uniqueId","array","_len","_key","_defineProperty","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","setPrototypeOf","__proto__","_keyframeProperty","_rekapi","_lodash","_lodash2","default","noop","getMillisecond","fire","event","getPropertyCacheEntryForMillisecond","_timelinePropertyCache","index","_millisecond","insertionPointInTrack","track","getLatestProperties","latestProperties","_propertyTracks","propertyTrack","propertyName","propertyIndexInTrack","invalidateCache","_timelinePropertyCacheValid","ensurePropertyCacheValid","_timelineFunctionCache","curCacheEntry","removeEmptyPropertyTracks","trackName","sortPropertyTracks","keyframeProperty","linkToNext","cleanupAfterKeyframeModification","_Tweenable","config","getPrototypeOf","state","easing","Function","function","KeyframeProperty","propertyTracks","some","getKeyframeProperty","copyFrom","copyTo","_this4","sourcePositions","sourceEasings","keyframe","to","hasKeyframeAt","oldIndex","_this5","modifyWith","_this6","_deleteKeyframePropertyAt","detach","removeKeyframe","newProperties","Error","starts","firstKeyframeProperty","min","endingTracks","tracksToInspect","getStart","until","end","latestProps","serializedProps","serializedEasings","latestProp","propName","modifyKeyframe","newMillisecond","targetMillisecond","_warnOnOutOfOrderKeyframes","console","warn","_insertKeyframePropertyAt","isActive","hasActiveTrack","_active","activeProperty","_this7","resetLaterFnKeyframes","start","interpolatedObject","propertyCacheEntry","getValueAt","shouldInvokeForMillisecond","_beforeKeyframePropertyInterpolate","_afterKeyframePropertyInterpolate","set","cache","_ref2","_ref2$withId","trackNames","getTrackNames","exportPropertyData","_this8","nextProperty","boundedMillisecond","delta","interpolatePosition","interpolate","drift","returnValue","g","_typeof","Symbol","iterator","eval","e","window","CanvasRenderer","dimension","canvas","heightOrWidth","newSize","style","canvasContext","on","clear","height","width","clearRect","CanvasRenderingContext2D","DOMRenderer","getActorCSS","canOptimizeAnyKeyframeProperties","generateCSSClass","generateCSSAnimationProperties","generateAnimationIterationProperty","generateAnimationNameProperty","generateBoilerplatedKeyframes","generateActorKeyframes","canOptimizeKeyframeProperty","simulateTrailingWait","simulateLeadingWait","generateActorTrackSegment","serializeActorStep","combineTransformProperties","generateOptimizedKeyframeSegment","applyVendorBoilerplates","applyVendorPropertyPrefixes","VENDOR_TOKEN","TRANSFORM_TOKEN","transformFunctions","_slicedToArray","sliceIterator","_arr","_n","_d","_e","_s","_i","next","done","err","vendorTransforms","R_TRANSFORM_TOKEN","RegExp","R_VENDOR_TOKEN","VENDOR_PREFIXES","microsoft","mozilla","opera","w3","webkit","BEZIERS","linear","easeInQuad","easeInCubic","easeInQuart","easeInQuint","easeInSine","easeInExpo","easeInCirc","easeOutQuad","easeOutCubic","easeOutQuart","easeOutQuint","easeOutSine","easeOutExpo","easeOutCirc","easeInOutQuad","easeInOutCubic","easeInOutQuart","easeInOutQuint","easeInOutSine","easeInOutExpo","easeInOutCirc","R_3D_RULE","isInt","number","vendorPrefix","document","body","getActorClassName","forceStyleReset","dummyDiv","createElement","nodeType","parentElement","replaceChild","styleID","injectStyle","css","innerHTML","head","appendChild","setStyle","element","styleName","styleValue","isTransformFunction","buildTransformValue","orderedTransforms","transformProperties","transformComponents","functionName","join","setTransformStyles","transformValue","prefixedTransform","actorRender","propertyNames","transformFunctionNames","otherProperties","_transformOrder","transform","actorTeardown","classList","className","match","sanitizedClassList","replace","onAddActor","bind","keyframes","vendor","toKeyframes","animName","fromPercent","toPercent","toFixed","bezier","split","propsToSerialize","transformNames","_ret","combinedProperties","transformFunction","v","targetProp","increments","incrementSize","actorStart","fromProp","accumulator","getLength","percent","step","generateCombinedActorKeyframes","steps","firstProp","actorEnd","_actor$_propertyTrack","_actor$_propertyTrack2","lastProp","calculateStepPercent","actorLength","generateActorTrackWaitSegment","toProp","isSegmentAWait","every","easings","leadingWait","previousSegmentWasOptimized","prop","trackSegment","shift","trailingWait","doCombineProperties","vendors","animationName","prefix","renderedName","concat","isCentered","generatedProperties","options","getActorCount","ceil","fps","_playTimestamp","_cachedCSS","_styleElement","_stopSetTimeoutHandle","isPlaying","prerender","goToEnd","removeChild","getCss","unrecognizedTransforms","animationCSS","arraySome","predicate","baseProperty","baseTimes","iteratee","result","getValue","isHostObject","toString","mapToArray","size","setToArray","Hash","entries","entry","hashClear","__data__","nativeCreate","hashDelete","has","hashGet","HASH_UNDEFINED","hashHas","hashSet","ListCache","listCacheClear","listCacheDelete","assocIndexOf","pop","listCacheGet","listCacheHas","listCacheSet","MapCache","mapCacheClear","hash","Map","string","mapCacheDelete","getMapData","mapCacheGet","mapCacheHas","mapCacheSet","SetCache","add","setCacheAdd","setCacheHas","Stack","stackClear","stackDelete","stackGet","stackHas","stackSet","pairs","LARGE_ARRAY_SIZE","arrayLikeKeys","inherited","isArguments","String","skipIndexes","isIndex","eq","baseGet","path","isKey","castPath","toKey","baseGetTag","objectToString","baseHasIn","baseIsEqual","other","customizer","bitmask","stack","isObject","isObjectLike","baseIsEqualDeep","equalFunc","objIsArr","othIsArr","objTag","arrayTag","othTag","getTag","argsTag","objectTag","objIsObj","othIsObj","isSameTag","isTypedArray","equalArrays","equalByTag","PARTIAL_COMPARE_FLAG","objIsWrapped","othIsWrapped","objUnwrapped","othUnwrapped","equalObjects","baseIsMatch","source","matchData","noCustomizer","objValue","srcValue","UNORDERED_COMPARE_FLAG","baseIsNative","isMasked","isFunction","reIsNative","reIsHostCtor","test","toSource","baseIsTypedArray","isLength","typedArrayTags","baseIteratee","identity","baseMatchesProperty","baseMatches","baseKeys","isPrototype","nativeKeys","getMatchData","matchesStrictComparable","isStrictComparable","hasIn","basePropertyDeep","baseSortedIndexBy","retHighest","low","high","valIsNaN","valIsNull","valIsSymbol","isSymbol","valIsUndefined","mid","nativeFloor","computed","othIsDefined","othIsNull","othIsReflexive","othIsSymbol","setLow","nativeMin","MAX_ARRAY_INDEX","baseToString","symbolToString","INFINITY","stringToPath","isPartial","arrLength","othLength","stacked","seen","arrValue","othValue","compared","othIndex","tag","dataViewTag","byteLength","byteOffset","buffer","arrayBufferTag","Uint8Array","boolTag","dateTag","numberTag","errorTag","message","regexpTag","stringTag","mapTag","convert","setTag","symbolTag","symbolValueOf","objProps","objLength","skipCtor","objCtor","othCtor","isKeyable","getNative","hasPath","hasFunc","MAX_SAFE_INTEGER","reIsUint","type","reIsPlainProp","reIsDeepProp","func","maskSrcKey","Ctor","objectProto","funcToString","sortedIndexBy","memoize","resolver","FUNC_ERROR_TEXT","memoized","args","Cache","isArrayLikeObject","propertyIsEnumerable","isArrayLike","funcTag","genTag","defaultValue","MAX_ARRAY_LENGTH","reLeadingDot","rePropName","reRegExpChar","reEscapeChar","freeGlobal","freeSelf","freeExports","freeModule","moduleExports","freeProcess","process","nodeUtil","binding","nodeIsTypedArray","arrayProto","funcProto","coreJsData","uid","exec","IE_PROTO","arg","DataView","Promise","Set","WeakMap","dataViewCtorString","mapCtorString","promiseCtorString","setCtorString","weakMapCtorString","symbolProto","valueOf","ArrayBuffer","resolve","ctorString","quote","webpackPolyfill","deprecate","paths","children","_canvas","_dom"],"mappings":"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","file":"rekapi.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"shifty\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"rekapi\", [\"shifty\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"rekapi\"] = factory(require(\"shifty\"));\n\telse\n\t\troot[\"rekapi\"] = factory(root[\"shifty\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_2__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"shifty\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"rekapi\", [\"shifty\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"rekapi\"] = factory(require(\"shifty\"));\n\telse\n\t\troot[\"rekapi\"] = factory(root[\"shifty\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_2__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/assets/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 10);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Rekapi = exports.rendererBootstrappers = exports.updateToCurrentMillisecond = exports.updateToMillisecond = exports.calculateLoopPosition = exports.updatePlayState = exports.isAnimationComplete = exports.calculateTimeSinceStart = exports.determineCurrentLoopIteration = exports.invalidateAnimationLength = exports.fireEvent = exports.DEFAULT_EASING = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _shifty = __webpack_require__(2);\n\nvar _actor = __webpack_require__(3);\n\nvar _utils = __webpack_require__(1);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar UPDATE_TIME = 1000 / 60;\n\nvar DEFAULT_EASING = exports.DEFAULT_EASING = 'linear';\n\n/*!\n * Fire an event bound to a Rekapi.\n * @param {Rekapi} rekapi\n * @param {string} eventName\n * @param {Object} [data={}] Optional event-specific data\n */\nvar fireEvent = exports.fireEvent = function fireEvent(rekapi, eventName) {\n  var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return rekapi._events[eventName].forEach(function (handler) {\n    return handler(rekapi, data);\n  });\n};\n\n/*!\n * @param {Rekapi} rekapi\n */\nvar invalidateAnimationLength = exports.invalidateAnimationLength = function invalidateAnimationLength(rekapi) {\n  return rekapi._animationLengthValid = false;\n};\n\n/*!\n * Determines which iteration of the loop the animation is currently in.\n * @param {Rekapi} rekapi\n * @param {number} timeSinceStart\n */\nvar determineCurrentLoopIteration = exports.determineCurrentLoopIteration = function determineCurrentLoopIteration(rekapi, timeSinceStart) {\n  var animationLength = rekapi.getAnimationLength();\n\n  if (animationLength === 0) {\n    return timeSinceStart;\n  }\n\n  return Math.floor(timeSinceStart / animationLength);\n};\n\n/*!\n * Calculate how many milliseconds since the animation began.\n * @param {Rekapi} rekapi\n * @return {number}\n */\nvar calculateTimeSinceStart = exports.calculateTimeSinceStart = function calculateTimeSinceStart(rekapi) {\n  return _shifty.Tweenable.now() - rekapi._loopTimestamp;\n};\n\n/*!\n * Determines if the animation is complete or not.\n * @param {Rekapi} rekapi\n * @param {number} currentLoopIteration\n * @return {boolean}\n */\nvar isAnimationComplete = exports.isAnimationComplete = function isAnimationComplete(rekapi, currentLoopIteration) {\n  return currentLoopIteration >= rekapi._timesToIterate && rekapi._timesToIterate !== -1;\n};\n\n/*!\n * Stops the animation if it is complete.\n * @param {Rekapi} rekapi\n * @param {number} currentLoopIteration\n * @fires rekapi.animationComplete\n */\nvar updatePlayState = exports.updatePlayState = function updatePlayState(rekapi, currentLoopIteration) {\n  if (isAnimationComplete(rekapi, currentLoopIteration)) {\n    rekapi.stop();\n    fireEvent(rekapi, 'animationComplete');\n  }\n};\n\n/*!\n * Calculate how far in the animation loop `rekapi` is, in milliseconds,\n * based on the current time.  Also overflows into a new loop if necessary.\n * @param {Rekapi} rekapi\n * @param {number} forMillisecond\n * @param {number} currentLoopIteration\n * @return {number}\n */\nvar calculateLoopPosition = exports.calculateLoopPosition = function calculateLoopPosition(rekapi, forMillisecond, currentLoopIteration) {\n  var animationLength = rekapi.getAnimationLength();\n\n  return animationLength === 0 ? 0 : isAnimationComplete(rekapi, currentLoopIteration) ? animationLength : forMillisecond % animationLength;\n};\n\n/*!\n * Calculate the timeline position and state for a given millisecond.\n * Updates the `rekapi` state internally and accounts for how many loop\n * iterations the animation runs for.\n * @param {Rekapi} rekapi\n * @param {number} forMillisecond\n * @fires rekapi.animationLooped\n */\nvar updateToMillisecond = exports.updateToMillisecond = function updateToMillisecond(rekapi, forMillisecond) {\n  var currentIteration = determineCurrentLoopIteration(rekapi, forMillisecond);\n  var loopPosition = calculateLoopPosition(rekapi, forMillisecond, currentIteration);\n\n  rekapi._loopPosition = loopPosition;\n\n  var keyframeResetList = [];\n\n  if (currentIteration > rekapi._latestIteration) {\n    fireEvent(rekapi, 'animationLooped');\n\n    rekapi._actors.forEach(function (actor) {\n      var _keyframeProperties = actor._keyframeProperties;\n\n      var fnKeyframes = Object.keys(_keyframeProperties).reduce(function (acc, propertyId) {\n        var property = _keyframeProperties[propertyId];\n\n        if (property.name === 'function') {\n          acc.push(property);\n        }\n\n        return acc;\n      }, []);\n\n      var lastFnKeyframe = fnKeyframes[fnKeyframes.length - 1];\n\n      if (lastFnKeyframe && !lastFnKeyframe.hasFired) {\n        lastFnKeyframe.invoke();\n      }\n\n      keyframeResetList.push.apply(keyframeResetList, _toConsumableArray(fnKeyframes));\n    });\n  }\n\n  rekapi._latestIteration = currentIteration;\n  rekapi.update(loopPosition, true);\n  updatePlayState(rekapi, currentIteration);\n\n  keyframeResetList.forEach(function (fnKeyframe) {\n    fnKeyframe.hasFired = false;\n  });\n};\n\n/*!\n * Calculate how far into the animation loop `rekapi` is, in milliseconds,\n * and update based on that time.\n * @param {Rekapi} rekapi\n */\nvar updateToCurrentMillisecond = exports.updateToCurrentMillisecond = function updateToCurrentMillisecond(rekapi) {\n  return updateToMillisecond(rekapi, calculateTimeSinceStart(rekapi));\n};\n\n/*!\n * This is the heartbeat of an animation.  This updates `rekapi`'s state and\n * then calls itself continuously.\n * @param {Rekapi} rekapi\n */\nvar tick = function tick(rekapi) {\n  return (\n    // Need to check for .call presence to get around an IE limitation.  See\n    // annotation for cancelLoop for more info.\n    rekapi._loopId = rekapi._scheduleUpdate.call ? rekapi._scheduleUpdate.call(global, rekapi._updateFn, UPDATE_TIME) : setTimeout(rekapi._updateFn, UPDATE_TIME)\n  );\n};\n\n/*!\n * @return {Function}\n */\nvar getUpdateMethod = function getUpdateMethod() {\n  return (\n    // requestAnimationFrame() shim by Paul Irish (modified for Rekapi)\n    // http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n    global.requestAnimationFrame || global.webkitRequestAnimationFrame || global.oRequestAnimationFrame || global.msRequestAnimationFrame || global.mozCancelRequestAnimationFrame && global.mozRequestAnimationFrame || global.setTimeout\n  );\n};\n\n/*!\n * @return {Function}\n */\nvar getCancelMethod = function getCancelMethod() {\n  return global.cancelAnimationFrame || global.webkitCancelAnimationFrame || global.oCancelAnimationFrame || global.msCancelAnimationFrame || global.mozCancelRequestAnimationFrame || global.clearTimeout;\n};\n\n/*!\n * Cancels an update loop.  This abstraction is needed to get around the fact\n * that in IE, clearTimeout is not technically a function\n * (https://twitter.com/kitcambridge/status/206655060342603777) and thus\n * Function.prototype.call cannot be used upon it.\n * @param {Rekapi} rekapi\n */\nvar cancelLoop = function cancelLoop(rekapi) {\n  return rekapi._cancelUpdate.call ? rekapi._cancelUpdate.call(global, rekapi._loopId) : clearTimeout(rekapi._loopId);\n};\n\nvar STOPPED = 'stopped';\nvar PAUSED = 'paused';\nvar PLAYING = 'playing';\n\n/*!\n * @type {Object.<function>} Contains the context init function to be called in\n * the Rekapi constructor.  This array is populated by modules in the\n * renderers/ directory.\n */\nvar rendererBootstrappers = exports.rendererBootstrappers = [];\n\n/**\n * If this is a rendered animation, the appropriate renderer is accessible as\n * `this.renderer`.  If provided, a reference to `context` is accessible\n * as `this.context`.\n * @param {(Object|CanvasRenderingContext2D|HTMLElement)} [context={}] Sets\n * {@link rekapi.Rekapi#context}. This determines how to render the animation.\n * {@link rekapi.Rekapi} will also automatically set up all necessary {@link\n * rekapi.Rekapi#renderers} based on this value:\n *\n * * If this is not provided or is a plain object (`{}`), the animation will\n * not render anything and {@link rekapi.Rekapi#renderers} will be empty.\n * * If this is a\n * [`CanvasRenderingContext2D`](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D),\n * {@link rekapi.Rekapi#renderers} will contain a {@link\n * rekapi.CanvasRenderer}.\n * * If this is a DOM element, {@link rekapi.Rekapi#renderers} will contain a\n * {@link rekapi.DOMRenderer}.\n * @constructs rekapi.Rekapi\n */\n\nvar Rekapi = exports.Rekapi = function () {\n  function Rekapi() {\n    var _this = this;\n\n    var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Rekapi);\n\n    /**\n     * @member {(Object|CanvasRenderingContext2D|HTMLElement)}\n     * rekapi.Rekapi#context The rendering context for an animation.\n     * @default {}\n     */\n    this.context = context;\n    this._actors = [];\n    this._playState = STOPPED;\n\n    /**\n     * @member {(rekapi.actorSortFunction|null)} rekapi.Rekapi#sort Optional\n     * function for sorting the render order of {@link rekapi.Actor}s.  If set,\n     * this is called each frame before the {@link rekapi.Actor}s are rendered.\n     * If not set, {@link rekapi.Actor}s will render in the order they were\n     * added via {@link rekapi.Rekapi#addActor}.\n     *\n     * The following example assumes that all {@link rekapi.Actor}s are circles\n     * that have a `radius` {@link rekapi.KeyframeProperty}.  The circles will\n     * be rendered in order of the value of their `radius`, from smallest to\n     * largest.  This has the effect of layering larger circles on top of\n     * smaller circles, thus giving a sense of perspective.\n     *\n     *     const rekapi = new Rekapi();\n     *     rekapi.sort = actor => actor.get().radius;\n     * @default null\n     */\n    this.sort = null;\n\n    this._events = {\n      animationComplete: [],\n      playStateChange: [],\n      play: [],\n      pause: [],\n      stop: [],\n      beforeUpdate: [],\n      afterUpdate: [],\n      addActor: [],\n      removeActor: [],\n      beforeAddKeyframeProperty: [],\n      addKeyframeProperty: [],\n      removeKeyframeProperty: [],\n      removeKeyframePropertyComplete: [],\n      beforeRemoveKeyframeProperty: [],\n      addKeyframePropertyTrack: [],\n      removeKeyframePropertyTrack: [],\n      timelineModified: [],\n      animationLooped: []\n    };\n\n    // How many times to loop the animation before stopping\n    this._timesToIterate = -1;\n\n    // Millisecond duration of the animation\n    this._animationLength = 0;\n    this._animationLengthValid = false;\n\n    // The setTimeout ID of `tick`\n    this._loopId = null;\n\n    // The UNIX time at which the animation loop started\n    this._loopTimestamp = null;\n\n    // Used for maintaining position when the animation is paused\n    this._pausedAtTime = null;\n\n    // The last millisecond position that was updated\n    this._lastUpdatedMillisecond = 0;\n\n    // The most recent loop iteration a frame was calculated for\n    this._latestIteration = 0;\n\n    // The most recent millisecond position within the loop that the animation\n    // was updated to\n    this._loopPosition = null;\n\n    this._scheduleUpdate = getUpdateMethod();\n    this._cancelUpdate = getCancelMethod();\n\n    this._updateFn = function () {\n      tick(_this);\n      updateToCurrentMillisecond(_this);\n    };\n\n    /**\n     * @member {Array.<rekapi.renderer>} rekapi.Rekapi#renderers Instances of\n     * {@link rekapi.renderer} classes, as inferred by the `context`\n     * parameter provided to the {@link rekapi.Rekapi} constructor.  You can\n     * add more renderers to this list manually; see the {@tutorial\n     * multiple-renderers} tutorial for an example.\n     */\n    this.renderers = rendererBootstrappers.map(function (renderer) {\n      return renderer(_this);\n    }).filter(function (_) {\n      return _;\n    });\n  }\n\n  /**\n   * Add a {@link rekapi.Actor} to the animation.  Decorates the added {@link\n   * rekapi.Actor} with a reference to this {@link rekapi.Rekapi} instance as\n   * {@link rekapi.Actor#rekapi}.\n   *\n   * @method rekapi.Rekapi#addActor\n   * @param {(rekapi.Actor|Object)} [actor={}] If this is an `Object`, it is used to as\n   * the constructor parameters for a new {@link rekapi.Actor} instance that\n   * is created by this method.\n   * @return {rekapi.Actor} The {@link rekapi.Actor} that was added.\n   * @fires rekapi.addActor\n   */\n\n\n  _createClass(Rekapi, [{\n    key: 'addActor',\n    value: function addActor() {\n      var actor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var rekapiActor = actor instanceof _actor.Actor ? actor : new _actor.Actor(actor);\n\n      // You can't add an actor more than once.\n      if (~this._actors.indexOf(rekapiActor)) {\n        return rekapiActor;\n      }\n\n      rekapiActor.context = rekapiActor.context || this.context;\n      rekapiActor.rekapi = this;\n\n      // Store a reference to the actor internally\n      this._actors.push(rekapiActor);\n\n      invalidateAnimationLength(this);\n      rekapiActor.setup();\n\n      fireEvent(this, 'addActor', rekapiActor);\n\n      return rekapiActor;\n    }\n\n    /**\n     * @method rekapi.Rekapi#getActor\n     * @param {number} actorId\n     * @return {rekapi.Actor} A reference to an actor from the animation by its\n     * `id`.  You can use {@link rekapi.Rekapi#getActorIds} to get a list of IDs\n     * for all actors in the animation.\n     */\n\n  }, {\n    key: 'getActor',\n    value: function getActor(actorId) {\n      return this._actors.filter(function (actor) {\n        return actor.id === actorId;\n      })[0];\n    }\n\n    /**\n     * @method rekapi.Rekapi#getActorIds\n     * @return {Array.<number>} The `id`s of all {@link rekapi.Actor}`s in the\n     * animation.\n     */\n\n  }, {\n    key: 'getActorIds',\n    value: function getActorIds() {\n      return this._actors.map(function (actor) {\n        return actor.id;\n      });\n    }\n\n    /**\n     * @method rekapi.Rekapi#getAllActors\n     * @return {Array.<rekapi.Actor>} All {@link rekapi.Actor}s in the animation.\n     */\n\n  }, {\n    key: 'getAllActors',\n    value: function getAllActors() {\n      return this._actors.slice();\n    }\n\n    /**\n     * @method rekapi.Rekapi#getActorCount\n     * @return {number} The number of {@link rekapi.Actor}s in the animation.\n     */\n\n  }, {\n    key: 'getActorCount',\n    value: function getActorCount() {\n      return this._actors.length;\n    }\n\n    /**\n     * Remove an actor from the animation.  This does not destroy the actor, it\n     * only removes the link between it and this {@link rekapi.Rekapi} instance.\n     * This method calls the actor's {@link rekapi.Actor#teardown} method, if\n     * defined.\n     * @method rekapi.Rekapi#removeActor\n     * @param {rekapi.Actor} actor\n     * @return {rekapi.Actor} The {@link rekapi.Actor} that was removed.\n     * @fires rekapi.removeActor\n     */\n\n  }, {\n    key: 'removeActor',\n    value: function removeActor(actor) {\n      // Remove the link between Rekapi and actor\n      this._actors = (0, _utils.without)(this._actors, actor);\n      delete actor.rekapi;\n\n      actor.teardown();\n      invalidateAnimationLength(this);\n\n      fireEvent(this, 'removeActor', actor);\n\n      return actor;\n    }\n\n    /**\n     * Remove all {@link rekapi.Actor}s from the animation.\n     * @method rekapi.Rekapi#removeAllActors\n     * @return {Array.<rekapi.Actor>} The {@link rekapi.Actor}s that were\n     * removed.\n     */\n\n  }, {\n    key: 'removeAllActors',\n    value: function removeAllActors() {\n      var _this2 = this;\n\n      return this.getAllActors().map(function (actor) {\n        return _this2.removeActor(actor);\n      });\n    }\n\n    /**\n     * Play the animation.\n     *\n     * @method rekapi.Rekapi#play\n     * @param {number} [iterations=-1] If omitted, the animation will loop\n     * endlessly.\n     * @return {rekapi.Rekapi}\n     * @fires rekapi.playStateChange\n     * @fires rekapi.play\n     */\n\n  }, {\n    key: 'play',\n    value: function play() {\n      var iterations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;\n\n      cancelLoop(this);\n\n      if (this._playState === PAUSED) {\n        // Move the playhead to the correct position in the timeline if resuming\n        // from a pause\n        this._loopTimestamp += _shifty.Tweenable.now() - this._pausedAtTime;\n      } else {\n        this._loopTimestamp = _shifty.Tweenable.now();\n      }\n\n      this._timesToIterate = iterations;\n      this._playState = PLAYING;\n\n      // Start the update loop\n      tick(this);\n\n      fireEvent(this, 'playStateChange');\n      fireEvent(this, 'play');\n\n      return this;\n    }\n\n    /**\n     * Move to a specific millisecond on the timeline and play from there.\n     *\n     * @method rekapi.Rekapi#playFrom\n     * @param {number} millisecond\n     * @param {number} [iterations] Works as it does in {@link\n     * rekapi.Rekapi#play}.\n     * @return {rekapi.Rekapi}\n     */\n\n  }, {\n    key: 'playFrom',\n    value: function playFrom(millisecond, iterations) {\n      this.play(iterations);\n      this._loopTimestamp = _shifty.Tweenable.now() - millisecond;\n\n      this._actors.forEach(function (actor) {\n        return actor._resetFnKeyframesFromMillisecond(millisecond);\n      });\n\n      return this;\n    }\n\n    /**\n     * Play from the last frame that was rendered with {@link\n     * rekapi.Rekapi#update}.\n     *\n     * @method rekapi.Rekapi#playFromCurrent\n     * @param {number} [iterations] Works as it does in {@link\n     * rekapi.Rekapi#play}.\n     * @return {rekapi.Rekapi}\n     */\n\n  }, {\n    key: 'playFromCurrent',\n    value: function playFromCurrent(iterations) {\n      return this.playFrom(this._lastUpdatedMillisecond, iterations);\n    }\n\n    /**\n     * Pause the animation.  A \"paused\" animation can be resumed from where it\n     * left off with {@link rekapi.Rekapi#play}.\n     *\n     * @method rekapi.Rekapi#pause\n     * @return {rekapi.Rekapi}\n     * @fires rekapi.playStateChange\n     * @fires rekapi.pause\n     */\n\n  }, {\n    key: 'pause',\n    value: function pause() {\n      if (this._playState === PAUSED) {\n        return this;\n      }\n\n      this._playState = PAUSED;\n      cancelLoop(this);\n      this._pausedAtTime = _shifty.Tweenable.now();\n\n      fireEvent(this, 'playStateChange');\n      fireEvent(this, 'pause');\n\n      return this;\n    }\n\n    /**\n     * Stop the animation.  A \"stopped\" animation will start from the beginning\n     * if {@link rekapi.Rekapi#play} is called.\n     *\n     * @method rekapi.Rekapi#stop\n     * @return {rekapi.Rekapi}\n     * @fires rekapi.playStateChange\n     * @fires rekapi.stop\n     */\n\n  }, {\n    key: 'stop',\n    value: function stop() {\n      this._playState = STOPPED;\n      cancelLoop(this);\n\n      // Also kill any shifty tweens that are running.\n      this._actors.forEach(function (actor) {\n        return actor._resetFnKeyframesFromMillisecond(0);\n      });\n\n      fireEvent(this, 'playStateChange');\n      fireEvent(this, 'stop');\n\n      return this;\n    }\n\n    /**\n     * @method rekapi.Rekapi#isPlaying\n     * @return {boolean} Whether or not the animation is playing (meaning not paused or\n     * stopped).\n     */\n\n  }, {\n    key: 'isPlaying',\n    value: function isPlaying() {\n      return this._playState === PLAYING;\n    }\n\n    /**\n     * @method rekapi.Rekapi#isPaused\n     * @return {boolean} Whether or not the animation is paused (meaning not playing or\n     * stopped).\n     */\n\n  }, {\n    key: 'isPaused',\n    value: function isPaused() {\n      return this._playState === PAUSED;\n    }\n\n    /**\n     * @method rekapi.Rekapi#isStopped\n     * @return {boolean} Whether or not the animation is stopped (meaning not playing or\n     * paused).\n     */\n\n  }, {\n    key: 'isStopped',\n    value: function isStopped() {\n      return this._playState === STOPPED;\n    }\n\n    /**\n     * Render an animation frame at a specific point in the timeline.\n     *\n     * @method rekapi.Rekapi#update\n     * @param {number} [millisecond=this._lastUpdatedMillisecond] The point in\n     * the timeline at which to render.  If omitted, this renders the last\n     * millisecond that was rendered (it's a re-render).\n     * @param {boolean} [doResetLaterFnKeyframes=false] If `true`, allow all\n     * {@link rekapi.keyframeFunction}s later in the timeline to be run again.\n     * This is a low-level feature, it should not be `true` (or even provided)\n     * for most use cases.\n     * @return {rekapi.Rekapi}\n     * @fires rekapi.beforeUpdate\n     * @fires rekapi.afterUpdate\n     */\n\n  }, {\n    key: 'update',\n    value: function update() {\n      var millisecond = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._lastUpdatedMillisecond;\n      var doResetLaterFnKeyframes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      fireEvent(this, 'beforeUpdate');\n\n      var sort = this.sort;\n\n\n      var renderOrder = sort ? this._actors.sort(function (a, b) {\n        return sort(a) - sort(b);\n      }) : this._actors;\n\n      // Update and render each of the actors\n      renderOrder.forEach(function (actor) {\n        actor._updateState(millisecond, doResetLaterFnKeyframes);\n\n        if (actor.wasActive) {\n          actor.render(actor.context, actor.get());\n        }\n      });\n\n      this._lastUpdatedMillisecond = millisecond;\n      fireEvent(this, 'afterUpdate');\n\n      return this;\n    }\n\n    /**\n     * @method rekapi.Rekapi#getLastPositionUpdated\n     * @return {number} The normalized timeline position (between 0 and 1) that\n     * was last rendered.\n     */\n\n  }, {\n    key: 'getLastPositionUpdated',\n    value: function getLastPositionUpdated() {\n      return this._lastUpdatedMillisecond / this.getAnimationLength();\n    }\n\n    /**\n     * @method rekapi.Rekapi#getLastMillisecondUpdated\n     * @return {number} The millisecond that was last rendered.\n     */\n\n  }, {\n    key: 'getLastMillisecondUpdated',\n    value: function getLastMillisecondUpdated() {\n      return this._lastUpdatedMillisecond;\n    }\n\n    /**\n     * @method rekapi.Rekapi#getAnimationLength\n     * @return {number} The length of the animation timeline, in milliseconds.\n     */\n\n  }, {\n    key: 'getAnimationLength',\n    value: function getAnimationLength() {\n      if (!this._animationLengthValid) {\n        this._animationLength = Math.max.apply(Math, this._actors.map(function (actor) {\n          return actor.getEnd();\n        }));\n\n        this._animationLengthValid = true;\n      }\n\n      return this._animationLength;\n    }\n\n    /**\n     * Bind a {@link rekapi.eventHandler} function to a Rekapi event.\n     * @method rekapi.Rekapi#on\n     * @param {string} eventName\n     * @param {rekapi.eventHandler} handler The event handler function.\n     * @return {rekapi.Rekapi}\n     */\n\n  }, {\n    key: 'on',\n    value: function on(eventName, handler) {\n      if (!this._events[eventName]) {\n        return this;\n      }\n\n      this._events[eventName].push(handler);\n\n      return this;\n    }\n\n    /**\n     * Manually fire a Rekapi event, thereby calling all {@link\n     * rekapi.eventHandler}s bound to that event.\n     * @param {string} eventName The name of the event to trigger.\n     * @param {any} [data] Optional data to provide to the `eventName` {@link\n     * rekapi.eventHandler}s.\n     * @method rekapi.Rekapi#trigger\n     * @return {rekapi.Rekapi}\n     * @fires *\n     */\n\n  }, {\n    key: 'trigger',\n    value: function trigger(eventName, data) {\n      fireEvent(this, eventName, data);\n\n      return this;\n    }\n\n    /**\n     * Unbind one or more handlers from a Rekapi event.\n     * @method rekapi.Rekapi#off\n     * @param {string} eventName Valid values correspond to the list under\n     * {@link rekapi.Rekapi#on}.\n     * @param {rekapi.eventHandler} [handler] A reference to the {@link\n     * rekapi.eventHandler} to unbind.  If omitted, all {@link\n     * rekapi.eventHandler}s bound to `eventName` are unbound.\n     * @return {rekapi.Rekapi}\n     */\n\n  }, {\n    key: 'off',\n    value: function off(eventName, handler) {\n      if (!this._events[eventName]) {\n        return this;\n      }\n\n      this._events[eventName] = handler ? (0, _utils.without)(this._events[eventName], handler) : [];\n\n      return this;\n    }\n\n    /**\n     * Export the timeline to a `JSON.stringify`-friendly `Object`.\n     *\n     * @method rekapi.Rekapi#exportTimeline\n     * @param {Object} [config]\n     * @param {boolean} [config.withId=false] If `true`, include internal `id`\n     * values in exported data.\n     * @return {rekapi.timelineData} This data can later be consumed by {@link\n     * rekapi.Rekapi#importTimeline}.\n     */\n\n  }, {\n    key: 'exportTimeline',\n    value: function exportTimeline() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref$withId = _ref.withId,\n          withId = _ref$withId === undefined ? false : _ref$withId;\n\n      var exportData = {\n        duration: this.getAnimationLength(),\n        actors: this._actors.map(function (actor) {\n          return actor.exportTimeline({ withId: withId });\n        })\n      };\n\n      var formulas = _shifty.Tweenable.formulas;\n\n\n      var filteredFormulas = Object.keys(formulas).filter(function (formulaName) {\n        return typeof formulas[formulaName].x1 === 'number';\n      });\n\n      var pickProps = ['displayName', 'x1', 'y1', 'x2', 'y2'];\n\n      exportData.curves = filteredFormulas.reduce(function (acc, formulaName) {\n        var formula = formulas[formulaName];\n        acc[formula.displayName] = (0, _utils.pick)(formula, pickProps);\n\n        return acc;\n      }, {});\n\n      return exportData;\n    }\n\n    /**\n     * Import data that was created by {@link rekapi.Rekapi#exportTimeline}.\n     * This sets up all actors, keyframes, and custom easing curves specified in\n     * the `rekapiData` parameter.  These two methods collectively allow you\n     * serialize an animation (for sending to a server for persistence, for\n     * example) and later recreating an identical animation.\n     *\n     * @method rekapi.Rekapi#importTimeline\n     * @param {rekapi.timelineData} rekapiData Any object that has the same data\n     * format as the object generated from {@link rekapi.Rekapi#exportTimeline}.\n     */\n\n  }, {\n    key: 'importTimeline',\n    value: function importTimeline(rekapiData) {\n      var _this3 = this;\n\n      (0, _utils.each)(rekapiData.curves, function (curve, curveName) {\n        return (0, _shifty.setBezierFunction)(curveName, curve.x1, curve.y1, curve.x2, curve.y2);\n      });\n\n      rekapiData.actors.forEach(function (actorData) {\n        var actor = new _actor.Actor();\n        actor.importTimeline(actorData);\n        _this3.addActor(actor);\n      });\n    }\n\n    /**\n     * @method rekapi.Rekapi#getEventNames\n     * @return {Array.<string>} The list of event names that this Rekapi instance\n     * supports.\n     */\n\n  }, {\n    key: 'getEventNames',\n    value: function getEventNames() {\n      return Object.keys(this._events);\n    }\n\n    /**\n     * Get a reference to a {@link rekapi.renderer} that was initialized for this\n     * animation.\n     * @method rekapi.Rekapi#getRendererInstance\n     * @param {rekapi.renderer} rendererConstructor The type of {@link\n     * rekapi.renderer} subclass (such as {@link rekapi.CanvasRenderer} or {@link\n     * rekapi.DOMRenderer}) to look up an instance of.\n     * @return {rekapi.renderer|undefined} The matching {@link rekapi.renderer},\n     * if any.\n     */\n\n  }, {\n    key: 'getRendererInstance',\n    value: function getRendererInstance(rendererConstructor) {\n      return this.renderers.filter(function (renderer) {\n        return renderer instanceof rendererConstructor;\n      })[0];\n    }\n\n    /**\n     * Move a {@link rekapi.Actor} around within the internal render order list.\n     * By default, a {@link rekapi.Actor} is rendered in the order it was added\n     * with {@link rekapi.Rekapi#addActor}.\n     *\n     * This method has no effect if {@link rekapi.Rekapi#sort} is set.\n     *\n     * @method rekapi.Rekapi#moveActorToPosition\n     * @param {rekapi.Actor} actor\n     * @param {number} layer This should be within `0` and the total number of\n     * {@link rekapi.Actor}s in the animation.  That number can be found with\n     * {@link rekapi.Rekapi#getActorCount}.\n     * @return {rekapi.Rekapi}\n     */\n\n  }, {\n    key: 'moveActorToPosition',\n    value: function moveActorToPosition(actor, position) {\n      if (position < this._actors.length && position > -1) {\n        this._actors = (0, _utils.without)(this._actors, actor);\n        this._actors.splice(position, 0, actor);\n      }\n\n      return this;\n    }\n  }]);\n\n  return Rekapi;\n}();\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * @param {Object} obj\n * @return {Object}\n */\nvar clone = exports.clone = function clone(obj) {\n  return Object.assign({}, obj);\n};\n\n/**\n * Simplified version of https://lodash.com/docs/4.17.4#difference\n * @param {Array.<any>} arr\n * @param {Array.<any>} values\n * @return {Array.<any>}\n */\nvar difference = exports.difference = function difference(arr, values) {\n  return arr.filter(function (value) {\n    return !~values.indexOf(value);\n  });\n};\n\n/**\n * Simplified version of https://lodash.com/docs/4.17.4#forEach, but only for\n * Objects.\n * @param {Object.<any>} obj\n * @param {Function(any)} fn\n */\nvar each = exports.each = function each(obj, fn) {\n  return Object.keys(obj).forEach(function (key) {\n    return fn(obj[key], key);\n  });\n};\n\n/*!\n * Simplified version of https://lodash.com/docs/4.17.4#intersection\n * @param {Array.<any>} arr1\n * @param {Array.<any>} arr2\n * @return {Array.<any>}\n */\nvar intersection = exports.intersection = function intersection(arr1, arr2) {\n  return arr1.filter(function (el) {\n    return ~arr2.indexOf(el);\n  });\n};\n\n/**\n * Simplified version of https://lodash.com/docs/4.17.4#pick\n * @param {Object.<any>} obj\n * @param {Array.<string>} keyNames\n */\nvar pick = exports.pick = function pick(obj, keyNames) {\n  return keyNames.reduce(function (acc, keyName) {\n    var val = obj[keyName];\n\n    if (typeof val !== 'undefined') {\n      acc[keyName] = val;\n    }\n\n    return acc;\n  }, {});\n};\n\n/**\n * Simplified version of https://lodash.com/docs/4.17.4#reject\n * @param {Array.<any>} arr\n * @param {Function(any)} fn\n * @return {Array.<any>}\n */\nvar reject = exports.reject = function reject(arr, fn) {\n  return arr.filter(function (el) {\n    return !fn(el);\n  });\n};\n\n/**\n * Simplified version of https://lodash.com/docs/4.17.4#uniq\n * @param {Array.<any>} arr\n * @return {Array.<any>}\n */\nvar uniq = exports.uniq = function uniq(arr) {\n  return arr.reduce(function (acc, value) {\n    if (!~acc.indexOf(value)) {\n      acc.push(value);\n    }\n\n    return acc;\n  }, []);\n};\n\nvar incrementer = 0;\n/**\n * @param {string} [prefix]\n * @return {string}\n */\nvar uniqueId = exports.uniqueId = function uniqueId() {\n  var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  return prefix + incrementer++;\n};\n\n/**\n * Simplified version of https://lodash.com/docs/4.17.4#without\n * @param {Array.<any>} array\n * @param {...any} values\n * @return {Array.<any>}\n */\nvar without = exports.without = function without(array) {\n  for (var _len = arguments.length, values = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    values[_key - 1] = arguments[_key];\n  }\n\n  return array.filter(function (value) {\n    return !~values.indexOf(value);\n  });\n};\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Actor = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _shifty = __webpack_require__(2);\n\nvar _keyframeProperty = __webpack_require__(4);\n\nvar _rekapi = __webpack_require__(0);\n\nvar _utils = __webpack_require__(1);\n\nvar _lodash = __webpack_require__(8);\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar noop = function noop() {};\n\n/*!\n * @param {Object} obj\n * @return {number} millisecond\n */\nvar getMillisecond = function getMillisecond(obj) {\n  return obj.millisecond;\n};\n\n// TODO: Make this a prototype method\n/*!\n * @param {Actor} actor\n * @param {string} event\n * @param {any} [data]\n */\nvar fire = function fire(actor, event, data) {\n  return actor.rekapi && (0, _rekapi.fireEvent)(actor.rekapi, event, data);\n};\n\n/*!\n * Retrieves the most recent property cache entry for a given millisecond.\n * @param {Actor} actor\n * @param {number} millisecond\n * @return {(Object|undefined)} undefined if there is no property cache for\n * the millisecond, i.e. an empty cache.\n */\nvar getPropertyCacheEntryForMillisecond = function getPropertyCacheEntryForMillisecond(actor, millisecond) {\n  var _timelinePropertyCache = actor._timelinePropertyCache;\n\n  var index = (0, _lodash2.default)(_timelinePropertyCache, { _millisecond: millisecond }, function (obj) {\n    return obj._millisecond;\n  });\n\n  if (!_timelinePropertyCache[index]) {\n    return;\n  }\n\n  return _timelinePropertyCache[index]._millisecond === millisecond ? _timelinePropertyCache[index] : index >= 1 ? _timelinePropertyCache[index - 1] : _timelinePropertyCache[0];\n};\n\n/*!\n * Search property track `track` and find the correct index to insert a\n * new element at `millisecond`.\n * @param {Array(KeyframeProperty)} track\n * @param {number} millisecond\n * @return {number} index\n */\nvar insertionPointInTrack = function insertionPointInTrack(track, millisecond) {\n  return (0, _lodash2.default)(track, { millisecond: millisecond }, getMillisecond);\n};\n\n/*!\n * Gets all of the current and most recent Rekapi.KeyframeProperties for a\n * given millisecond.\n * @param {Actor} actor\n * @param {number} forMillisecond\n * @return {Object} An Object containing Rekapi.KeyframeProperties\n */\nvar getLatestProperties = function getLatestProperties(actor, forMillisecond) {\n  var latestProperties = {};\n\n  (0, _utils.each)(actor._propertyTracks, function (propertyTrack, propertyName) {\n    var index = insertionPointInTrack(propertyTrack, forMillisecond);\n\n    latestProperties[propertyName] = propertyTrack[index] && propertyTrack[index].millisecond === forMillisecond ?\n    // Found forMillisecond exactly.\n    propertyTrack[index] : index >= 1 ?\n    // forMillisecond doesn't exist in the track and index is\n    // where we'd need to insert it, therefore the previous\n    // keyframe is the most recent one before forMillisecond.\n    propertyTrack[index - 1] :\n    // Return first property.  This is after forMillisecond.\n    propertyTrack[0];\n  });\n\n  return latestProperties;\n};\n\n/*!\n * Search property track `track` and find the index to the element that is\n * at `millisecond`.  Returns `undefined` if not found.\n * @param {Array(KeyframeProperty)} track\n * @param {number} millisecond\n * @return {number} index or -1 if not present\n */\nvar propertyIndexInTrack = function propertyIndexInTrack(track, millisecond) {\n  var index = insertionPointInTrack(track, millisecond);\n\n  return track[index] && track[index].millisecond === millisecond ? index : -1;\n};\n\n/*!\n * Mark the cache of internal KeyframeProperty data as invalid.  The cache\n * will be rebuilt on the next call to ensurePropertyCacheValid.\n * @param {Actor}\n */\nvar invalidateCache = function invalidateCache(actor) {\n  return actor._timelinePropertyCacheValid = false;\n};\n\n/*!\n * Empty out and rebuild the cache of internal KeyframeProperty data if it\n * has been marked as invalid.\n * @param {Actor}\n */\nvar ensurePropertyCacheValid = function ensurePropertyCacheValid(actor) {\n  if (actor._timelinePropertyCacheValid) {\n    return;\n  }\n\n  actor._timelinePropertyCache = [];\n  actor._timelineFunctionCache = [];\n\n  var _keyframeProperties = actor._keyframeProperties,\n      _timelineFunctionCache = actor._timelineFunctionCache,\n      _timelinePropertyCache = actor._timelinePropertyCache;\n\n  // Build the cache map\n\n  var props = Object.keys(_keyframeProperties).map(function (key) {\n    return _keyframeProperties[key];\n  }).sort(function (a, b) {\n    return a.millisecond - b.millisecond;\n  });\n\n  var curCacheEntry = getLatestProperties(actor, 0);\n\n  curCacheEntry._millisecond = 0;\n  _timelinePropertyCache.push(curCacheEntry);\n\n  props.forEach(function (property) {\n    if (property.millisecond !== curCacheEntry._millisecond) {\n      curCacheEntry = (0, _utils.clone)(curCacheEntry);\n      curCacheEntry._millisecond = property.millisecond;\n      _timelinePropertyCache.push(curCacheEntry);\n    }\n\n    curCacheEntry[property.name] = property;\n\n    if (property.name === 'function') {\n      _timelineFunctionCache.push(property);\n    }\n  });\n\n  actor._timelinePropertyCacheValid = true;\n};\n\n/*!\n * Remove any property tracks that are empty.\n * @param {Actor} actor\n * @fires rekapi.removeKeyframePropertyTrack\n */\nvar removeEmptyPropertyTracks = function removeEmptyPropertyTracks(actor) {\n  var _propertyTracks = actor._propertyTracks;\n\n\n  Object.keys(_propertyTracks).forEach(function (trackName) {\n    if (!_propertyTracks[trackName].length) {\n      delete _propertyTracks[trackName];\n      fire(actor, 'removeKeyframePropertyTrack', trackName);\n    }\n  });\n};\n\n/*!\n * Stably sort all of the property tracks of an actor\n * @param {Actor} actor\n */\nvar sortPropertyTracks = function sortPropertyTracks(actor) {\n  (0, _utils.each)(actor._propertyTracks, function (propertyTrack, trackName) {\n    propertyTrack = propertyTrack.sort(function (a, b) {\n      return a.millisecond - b.millisecond;\n    });\n\n    propertyTrack.forEach(function (keyframeProperty, i) {\n      return keyframeProperty.linkToNext(propertyTrack[i + 1]);\n    });\n\n    actor._propertyTracks[trackName] = propertyTrack;\n  });\n};\n\n/*!\n * Updates internal Rekapi and Actor data after a KeyframeProperty\n * modification method is called.\n *\n * @param {Actor} actor\n * @fires rekapi.timelineModified\n */\nvar cleanupAfterKeyframeModification = function cleanupAfterKeyframeModification(actor) {\n  sortPropertyTracks(actor);\n  invalidateCache(actor);\n\n  if (actor.rekapi) {\n    (0, _rekapi.invalidateAnimationLength)(actor.rekapi);\n  }\n\n  fire(actor, 'timelineModified');\n};\n\n/**\n * A {@link rekapi.Actor} represents an individual component of an animation.\n * An animation may have one or many {@link rekapi.Actor}s.\n *\n * @param {Object} [config={}]\n * @param {(Object|CanvasRenderingContext2D|HTMLElement)} [config.context] Sets\n * {@link rekapi.Actor#context}.\n * @param {Function} [config.setup] Sets {@link rekapi.Actor#setup}.\n * @param {rekapi.render} [config.render] Sets {@link rekapi.Actor#render}.\n * @param {Function} [config.teardown] Sets {@link rekapi.Actor#teardown}.\n * @constructs rekapi.Actor\n */\n\nvar Actor = exports.Actor = function (_Tweenable) {\n  _inherits(Actor, _Tweenable);\n\n  function Actor() {\n    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Actor);\n\n    /**\n     * @member {rekapi.Rekapi|undefined} rekapi.Actor#rekapi The {@link\n     * rekapi.Rekapi} instance to which this {@link rekapi.Actor} belongs, if\n     * any.\n     */\n\n    var _this = _possibleConstructorReturn(this, (Actor.__proto__ || Object.getPrototypeOf(Actor)).call(this));\n\n    Object.assign(_this, {\n      _propertyTracks: {},\n      _timelinePropertyCache: [],\n      _timelineFunctionCache: [],\n      _timelinePropertyCacheValid: false,\n      _keyframeProperties: {},\n\n      /**\n       * @member {string} rekapi.Actor#id The unique ID of this {@link rekapi.Actor}.\n       */\n      id: (0, _utils.uniqueId)(),\n\n      /**\n        * @member {(Object|CanvasRenderingContext2D|HTMLElement|undefined)}\n        * [rekapi.Actor#context] If this {@link rekapi.Actor} was created by or\n        * provided as an argument to {@link rekapi.Rekapi#addActor}, then this\n        * member is a reference to that {@link rekapi.Rekapi}'s {@link\n        * rekapi.Rekapi#context}.\n        */\n      context: config.context,\n\n      /**\n       * @member {Function} rekapi.Actor#setup Gets called when an actor is\n       * added to an animation by {@link rekapi.Rekapi#addActor}.\n       */\n      setup: config.setup || noop,\n\n      /**\n       * @member {rekapi.render} rekapi.Actor#render The function that renders\n       * this {@link rekapi.Actor}.\n       */\n      render: config.render || noop,\n\n      /**\n       * @member {Function} rekapi.Actor#teardown Gets called when an actor is\n       * removed from an animation by {@link rekapi.Rekapi#removeActor}.\n       */\n      teardown: config.teardown || noop,\n\n      /**\n       * @member {boolean} rekapi.Actor#wasActive A flag that records whether\n       * this {@link rekapi.Actor} had any state in the previous updated cycle.\n       * Handy for immediate-mode renderers (such as {@link\n       * rekapi.CanvasRenderer}) to prevent unintended renders after the actor\n       * has no state. Also used to prevent redundant {@link\n       * rekapi.keyframeFunction} calls.\n       */\n      wasActive: true\n    });\n    return _this;\n  }\n\n  /**\n   * Create a keyframe for the actor.  The animation timeline begins at `0`.\n   * The timeline's length will automatically \"grow\" to accommodate new\n   * keyframes as they are added.\n   *\n   * `state` should contain all of the properties that define this keyframe's\n   * state.  These properties can be any value that can be tweened by\n   * [Shifty](http://jeremyckahn.github.io/shifty/doc/) (numbers,\n   * RGB/hexadecimal color strings, and CSS property strings).  `state` can\n   * also be a [function]{@link rekapi.keyframeFunction}, but\n   * [this works differently]{@tutorial keyframes-in-depth}.\n   *\n   * __Note:__ Internally, this creates {@link rekapi.KeyframeProperty}s and\n   * places them on a \"track.\" Tracks are automatically named to match the\n   * relevant {@link rekapi.KeyframeProperty#name}s.  These {@link\n   * rekapi.KeyframeProperty}s are managed for you by the {@link rekapi.Actor}\n   * APIs.\n   *\n   * ## [Click to learn about keyframes in depth]{@tutorial keyframes-in-depth}\n   * @method rekapi.Actor#keyframe\n   * @param {number} millisecond Where on the timeline to set the keyframe.\n   * @param {(Object|rekapi.keyframeFunction)} state The state properties of\n   * the keyframe.  If this is an Object, the properties will be interpolated\n   * between this and those of the following keyframe for a given point on the\n   * animation timeline.  If this is a function ({@link\n   * rekapi.keyframeFunction}), it will be called at the keyframe specified by\n   * `millisecond`.\n   * @param {(string|Object)} [easing] Optional easing string or Object.  If\n   * `state` is a function, this is ignored.\n   * @return {rekapi.Actor}\n   * @fires rekapi.timelineModified\n   */\n\n\n  _createClass(Actor, [{\n    key: 'keyframe',\n    value: function keyframe(millisecond, state) {\n      var _this2 = this;\n\n      var easing = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _rekapi.DEFAULT_EASING;\n\n      if (state instanceof Function) {\n        state = { 'function': state };\n      }\n\n      (0, _utils.each)(state, function (value, name) {\n        return _this2.addKeyframeProperty(new _keyframeProperty.KeyframeProperty(millisecond, name, value, typeof easing === 'string' ? easing : easing[name] || _rekapi.DEFAULT_EASING));\n      });\n\n      if (this.rekapi) {\n        (0, _rekapi.invalidateAnimationLength)(this.rekapi);\n      }\n\n      invalidateCache(this);\n      fire(this, 'timelineModified');\n\n      return this;\n    }\n\n    /**\n     * @method rekapi.Actor#hasKeyframeAt\n     * @param {number} millisecond Point on the timeline to query.\n     * @param {rekapi.KeyframeProperty#name} [trackName] Optionally scope the\n     * lookup to a particular track.\n     * @return {boolean} Whether or not the actor has any {@link\n     * rekapi.KeyframeProperty}s set at `millisecond`.\n     */\n\n  }, {\n    key: 'hasKeyframeAt',\n    value: function hasKeyframeAt(millisecond) {\n      var _this3 = this;\n\n      var trackName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      var _propertyTracks = this._propertyTracks;\n\n\n      if (trackName && !_propertyTracks[trackName]) {\n        return false;\n      }\n\n      var propertyTracks = trackName ? (0, _utils.pick)(_propertyTracks, [trackName]) : _propertyTracks;\n\n      return Object.keys(propertyTracks).some(function (track) {\n        return propertyTracks.hasOwnProperty(track) && !!_this3.getKeyframeProperty(track, millisecond);\n      });\n    }\n\n    /**\n     * Copies all of the {@link rekapi.KeyframeProperty}s from one point on the\n     * actor's timeline to another. This is particularly useful for animating an\n     * actor back to its original position.\n     *\n     *     actor\n     *       .keyframe(0, {\n     *         x: 10,\n     *         y: 15\n     *       }).keyframe(1000, {\n     *         x: 50,\n     *         y: 75\n     *       });\n     *\n     *     // Return the actor to its original position\n     *     actor.copyKeyframe(0, 2000);\n     *\n     * @method rekapi.Actor#copyKeyframe\n     * @param {number} copyFrom The timeline millisecond to copy {@link\n     * rekapi.KeyframeProperty}s from.\n     * @param {number} copyTo The timeline millisecond to copy {@link\n     * rekapi.KeyframeProperty}s to.\n     * @return {rekapi.Actor}\n     */\n\n  }, {\n    key: 'copyKeyframe',\n    value: function copyKeyframe(copyFrom, copyTo) {\n      var _this4 = this;\n\n      // Build the configuation objects to be passed to Actor#keyframe\n      var sourcePositions = {};\n      var sourceEasings = {};\n\n      (0, _utils.each)(this._propertyTracks, function (propertyTrack, trackName) {\n        var keyframeProperty = _this4.getKeyframeProperty(trackName, copyFrom);\n\n        if (keyframeProperty) {\n          sourcePositions[trackName] = keyframeProperty.value;\n          sourceEasings[trackName] = keyframeProperty.easing;\n        }\n      });\n\n      this.keyframe(copyTo, sourcePositions, sourceEasings);\n\n      return this;\n    }\n\n    /**\n     * Moves all of the {@link rekapi.KeyframeProperty}s from one point on the\n     * actor's timeline to another.  Although this method does error checking for\n     * you to make sure the operation can be safely performed, an effective\n     * pattern is to use {@link rekapi.Actor#hasKeyframeAt} to see if there is\n     * already a keyframe at the requested `to` destination.\n     *\n     * @method rekapi.Actor#moveKeyframe\n     * @param {number} from The millisecond of the keyframe to be moved.\n     * @param {number} to The millisecond of where the keyframe should be moved\n     * to.\n     * @return {boolean} Whether or not the keyframe was successfully moved.\n     */\n\n  }, {\n    key: 'moveKeyframe',\n    value: function moveKeyframe(from, to) {\n      if (!this.hasKeyframeAt(from) || this.hasKeyframeAt(to)) {\n        return false;\n      }\n\n      // Move each of the relevant KeyframeProperties to the new location in the\n      // timeline\n      (0, _utils.each)(this._propertyTracks, function (propertyTrack, trackName) {\n        var oldIndex = propertyIndexInTrack(propertyTrack, from);\n\n        if (oldIndex !== -1) {\n          propertyTrack[oldIndex].millisecond = to;\n        }\n      });\n\n      cleanupAfterKeyframeModification(this);\n\n      return true;\n    }\n\n    /**\n     * Augment the `value` or `easing` of the {@link rekapi.KeyframeProperty}s\n     * at a given millisecond.  Any {@link rekapi.KeyframeProperty}s omitted in\n     * `state` or `easing` are not modified.\n     *\n     *     actor.keyframe(0, {\n     *       'x': 10,\n     *       'y': 20\n     *     }).keyframe(1000, {\n     *       'x': 20,\n     *       'y': 40\n     *     }).keyframe(2000, {\n     *       'x': 30,\n     *       'y': 60\n     *     })\n     *\n     *     // Changes the state of the keyframe at millisecond 1000.\n     *     // Modifies the value of 'y' and the easing of 'x.'\n     *     actor.modifyKeyframe(1000, {\n     *       'y': 150\n     *     }, {\n     *       'x': 'easeFrom'\n     *     });\n     *\n     * @method rekapi.Actor#modifyKeyframe\n     * @param {number} millisecond\n     * @param {Object} state\n     * @param {Object} [easing={}]\n     * @return {rekapi.Actor}\n     */\n\n  }, {\n    key: 'modifyKeyframe',\n    value: function modifyKeyframe(millisecond, state) {\n      var _this5 = this;\n\n      var easing = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      (0, _utils.each)(this._propertyTracks, function (propertyTrack, trackName) {\n        var property = _this5.getKeyframeProperty(trackName, millisecond);\n\n        if (property) {\n          property.modifyWith({\n            value: state[trackName],\n            easing: easing[trackName]\n          });\n        } else if (state[trackName]) {\n          _this5.addKeyframeProperty(new _keyframeProperty.KeyframeProperty(millisecond, trackName, state[trackName], easing[trackName]));\n        }\n      });\n\n      cleanupAfterKeyframeModification(this);\n\n      return this;\n    }\n\n    /**\n     * Remove all {@link rekapi.KeyframeProperty}s set\n     * on the actor at a given millisecond in the animation.\n     *\n     * @method rekapi.Actor#removeKeyframe\n     * @param {number} millisecond The location on the timeline of the keyframe\n     * to remove.\n     * @return {rekapi.Actor}\n     * @fires rekapi.timelineModified\n     */\n\n  }, {\n    key: 'removeKeyframe',\n    value: function removeKeyframe(millisecond) {\n      var _this6 = this;\n\n      (0, _utils.each)(this._propertyTracks, function (propertyTrack, propertyName) {\n        var index = propertyIndexInTrack(propertyTrack, millisecond);\n\n        if (index !== -1) {\n          var keyframeProperty = propertyTrack[index];\n          _this6._deleteKeyframePropertyAt(propertyTrack, index);\n          keyframeProperty.detach();\n        }\n      });\n\n      removeEmptyPropertyTracks(this);\n      cleanupAfterKeyframeModification(this);\n      fire(this, 'timelineModified');\n\n      return this;\n    }\n\n    /**\n     * Remove all {@link rekapi.KeyframeProperty}s set\n     * on the actor.\n     *\n     * **NOTE**: This method does _not_ fire the `beforeRemoveKeyframeProperty`\n     * or `removeKeyframePropertyComplete` events.  This method is a bulk\n     * operation that is more efficient than calling {@link\n     * rekapi.Actor#removeKeyframeProperty} many times individually, but\n     * foregoes firing events.\n     *\n     * @method rekapi.Actor#removeAllKeyframes\n     * @return {rekapi.Actor}\n     */\n\n  }, {\n    key: 'removeAllKeyframes',\n    value: function removeAllKeyframes() {\n      (0, _utils.each)(this._propertyTracks, function (propertyTrack) {\n        return propertyTrack.length = 0;\n      });\n\n      (0, _utils.each)(this._keyframeProperties, function (keyframeProperty) {\n        return keyframeProperty.detach();\n      });\n\n      removeEmptyPropertyTracks(this);\n      this._keyframeProperties = {};\n\n      // Calling removeKeyframe performs some necessary post-removal cleanup, the\n      // earlier part of this method skipped all of that for the sake of\n      // efficiency.\n      return this.removeKeyframe(0);\n    }\n\n    /**\n     * @method rekapi.Actor#getKeyframeProperty\n     * @param {string} property The name of the property track.\n     * @param {number} millisecond The millisecond of the property in the\n     * timeline.\n     * @return {(rekapi.KeyframeProperty|undefined)} A {@link\n     * rekapi.KeyframeProperty} that is stored on the actor, as specified by the\n     * `property` and `millisecond` parameters. This is `undefined` if no\n     * properties were found.\n     */\n\n  }, {\n    key: 'getKeyframeProperty',\n    value: function getKeyframeProperty(property, millisecond) {\n      var propertyTrack = this._propertyTracks[property];\n\n      return propertyTrack[propertyIndexInTrack(propertyTrack, millisecond)];\n    }\n\n    /**\n     * Modify a {@link rekapi.KeyframeProperty} stored on an actor.\n     * Internally, this calls {@link rekapi.KeyframeProperty#modifyWith} and\n     * then performs some cleanup.\n     *\n     * @method rekapi.Actor#modifyKeyframeProperty\n     * @param {string} property The name of the {@link rekapi.KeyframeProperty}\n     * to modify.\n     * @param {number} millisecond The timeline millisecond of the {@link\n     * rekapi.KeyframeProperty} to modify.\n     * @param {Object} newProperties The properties to augment the {@link\n     * rekapi.KeyframeProperty} with.\n     * @return {rekapi.Actor}\n     */\n\n  }, {\n    key: 'modifyKeyframeProperty',\n    value: function modifyKeyframeProperty(property, millisecond, newProperties) {\n      var keyframeProperty = this.getKeyframeProperty(property, millisecond);\n\n      if (keyframeProperty) {\n        if ('millisecond' in newProperties && this.hasKeyframeAt(newProperties.millisecond, property)) {\n          throw new Error('Tried to move ' + property + ' to ' + newProperties.millisecond + 'ms, but a keyframe property already exists there');\n        }\n\n        keyframeProperty.modifyWith(newProperties);\n        cleanupAfterKeyframeModification(this);\n      }\n\n      return this;\n    }\n\n    /**\n     * Remove a single {@link rekapi.KeyframeProperty}\n     * from the actor.\n     * @method rekapi.Actor#removeKeyframeProperty\n     * @param {string} property The name of the {@link rekapi.KeyframeProperty}\n     * to remove.\n     * @param {number} millisecond Where in the timeline the {@link\n     * rekapi.KeyframeProperty} to remove is.\n     * @return {(rekapi.KeyframeProperty|undefined)} The removed\n     * KeyframeProperty, if one was found.\n     * @fires rekapi.beforeRemoveKeyframeProperty\n     * @fires rekapi.removeKeyframePropertyComplete\n     */\n\n  }, {\n    key: 'removeKeyframeProperty',\n    value: function removeKeyframeProperty(property, millisecond) {\n      var _propertyTracks = this._propertyTracks;\n\n\n      if (_propertyTracks[property]) {\n        var propertyTrack = _propertyTracks[property];\n        var index = propertyIndexInTrack(propertyTrack, millisecond);\n        var keyframeProperty = propertyTrack[index];\n\n        fire(this, 'beforeRemoveKeyframeProperty', keyframeProperty);\n        this._deleteKeyframePropertyAt(propertyTrack, index);\n        keyframeProperty.detach();\n\n        removeEmptyPropertyTracks(this);\n        cleanupAfterKeyframeModification(this);\n        fire(this, 'removeKeyframePropertyComplete', keyframeProperty);\n\n        return keyframeProperty;\n      }\n    }\n\n    /**\n     *\n     * @method rekapi.Actor#getTrackNames\n     * @return {Array.<rekapi.KeyframeProperty#name>} A list of all the track\n     * names for a {@link rekapi.Actor}.\n     */\n\n  }, {\n    key: 'getTrackNames',\n    value: function getTrackNames() {\n      return Object.keys(this._propertyTracks);\n    }\n\n    /**\n     * Get all of the {@link rekapi.KeyframeProperty}s for a track.\n     * @method rekapi.Actor#getPropertiesInTrack\n     * @param {rekapi.KeyframeProperty#name} trackName The track name to query.\n     * @return {Array(rekapi.KeyframeProperty)}\n     */\n\n  }, {\n    key: 'getPropertiesInTrack',\n    value: function getPropertiesInTrack(trackName) {\n      return (this._propertyTracks[trackName] || []).slice(0);\n    }\n\n    /**\n     * @method rekapi.Actor#getStart\n     * @param {rekapi.KeyframeProperty#name} [trackName] Optionally scope the\n     * lookup to a particular track.\n     * @return {number} The millisecond of the first animating state of a {@link\n     * rekapi.Actor} (for instance, if the first keyframe is later than\n     * millisecond `0`).  If there are no keyframes, this is `0`.\n     */\n\n  }, {\n    key: 'getStart',\n    value: function getStart() {\n      var trackName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n      var _propertyTracks = this._propertyTracks;\n\n      var starts = [];\n\n      // Null check to see if trackName was provided and is valid\n      if (_propertyTracks.hasOwnProperty(trackName)) {\n        var firstKeyframeProperty = _propertyTracks[trackName][0];\n\n        if (firstKeyframeProperty) {\n          starts.push(firstKeyframeProperty.millisecond);\n        }\n      } else {\n        // Loop over all property tracks and accumulate the first\n        // keyframeProperties from non-empty tracks\n        (0, _utils.each)(_propertyTracks, function (propertyTrack) {\n          if (propertyTrack.length) {\n            starts.push(propertyTrack[0].millisecond);\n          }\n        });\n      }\n\n      return starts.length > 0 ? Math.min.apply(Math, starts) : 0;\n    }\n\n    /**\n     * @method rekapi.Actor#getEnd\n     * @param {rekapi.KeyframeProperty#name} [trackName] Optionally scope the\n     * lookup to a particular keyframe track.\n     * @return {number} The millisecond of the last state of an actor (the point\n     * in the timeline in which it is done animating).  If there are no\n     * keyframes, this is `0`.\n     */\n\n  }, {\n    key: 'getEnd',\n    value: function getEnd() {\n      var trackName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n\n      var endingTracks = [0];\n\n      var tracksToInspect = trackName ? _defineProperty({}, trackName, this._propertyTracks[trackName]) : this._propertyTracks;\n\n      (0, _utils.each)(tracksToInspect, function (propertyTrack) {\n        if (propertyTrack.length) {\n          endingTracks.push(propertyTrack[propertyTrack.length - 1].millisecond);\n        }\n      });\n\n      return Math.max.apply(Math, endingTracks);\n    }\n\n    /**\n     * @method rekapi.Actor#getLength\n     * @param {rekapi.KeyframeProperty#name} [trackName] Optionally scope the\n     * lookup to a particular track.\n     * @return {number} The length of time in milliseconds that the actor\n     * animates for.\n     */\n\n  }, {\n    key: 'getLength',\n    value: function getLength() {\n      var trackName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n\n      return this.getEnd(trackName) - this.getStart(trackName);\n    }\n\n    /**\n     * Extend the last state on this actor's timeline to simulate a pause.\n     * Internally, this method copies the final state of the actor in the\n     * timeline to the millisecond defined by `until`.\n     *\n     * @method rekapi.Actor#wait\n     * @param {number} until At what point in the animation the Actor should wait\n     * until (relative to the start of the animation timeline).  If this number\n     * is less than the value returned from {@link rekapi.Actor#getLength},\n     * this method does nothing.\n     * @return {rekapi.Actor}\n     */\n\n  }, {\n    key: 'wait',\n    value: function wait(until) {\n      var end = this.getEnd();\n\n      if (until <= end) {\n        return this;\n      }\n\n      var latestProps = getLatestProperties(this, this.getEnd());\n      var serializedProps = {};\n      var serializedEasings = {};\n\n      (0, _utils.each)(latestProps, function (latestProp, propName) {\n        serializedProps[propName] = latestProp.value;\n        serializedEasings[propName] = latestProp.easing;\n      });\n\n      this.modifyKeyframe(end, serializedProps, serializedEasings);\n      this.keyframe(until, serializedProps, serializedEasings);\n\n      return this;\n    }\n\n    /*!\n     * Insert a `KeyframeProperty` into a property track at `index`.  The linked\n     * list structure of the property track is maintained.\n     * @method rekapi.Actor#_insertKeyframePropertyAt\n     * @param {KeyframeProperty} keyframeProperty\n     * @param {Array(KeyframeProperty)} propertyTrack\n     * @param {number} index\n     */\n\n  }, {\n    key: '_insertKeyframePropertyAt',\n    value: function _insertKeyframePropertyAt(keyframeProperty, propertyTrack, index) {\n      propertyTrack.splice(index, 0, keyframeProperty);\n    }\n\n    /*!\n     * Remove the `KeyframeProperty` at `index` from a property track.  The linked\n     * list structure of the property track is maintained.  The removed property\n     * is not modified or unlinked internally.\n     * @method rekapi.Actor#_deleteKeyframePropertyAt\n     * @param {Array(KeyframeProperty)} propertyTrack\n     * @param {number} index\n     */\n\n  }, {\n    key: '_deleteKeyframePropertyAt',\n    value: function _deleteKeyframePropertyAt(propertyTrack, index) {\n      propertyTrack.splice(index, 1);\n    }\n\n    /**\n     * Associate a {@link rekapi.KeyframeProperty} to this {@link rekapi.Actor}.\n     * Updates {@link rekapi.KeyframeProperty#actor} to maintain a link between\n     * the two objects.  This is a lower-level method and it is generally better\n     * to use {@link rekapi.Actor#keyframe}.  This is mostly useful for adding a\n     * {@link rekapi.KeyframeProperty} back to an actor after it was {@link\n     * rekapi.KeyframeProperty#detach}ed.\n     * @method rekapi.Actor#addKeyframeProperty\n     * @param {rekapi.KeyframeProperty} keyframeProperty\n     * @return {rekapi.Actor}\n     * @fires rekapi.beforeAddKeyframeProperty\n     * @fires rekapi.addKeyframePropertyTrack\n     * @fires rekapi.addKeyframeProperty\n     */\n\n  }, {\n    key: 'addKeyframeProperty',\n    value: function addKeyframeProperty(keyframeProperty) {\n      if (this.rekapi) {\n        fire(this, 'beforeAddKeyframeProperty', keyframeProperty);\n      }\n\n      keyframeProperty.actor = this;\n      this._keyframeProperties[keyframeProperty.id] = keyframeProperty;\n\n      var name = keyframeProperty.name;\n      var _propertyTracks = this._propertyTracks,\n          rekapi = this.rekapi;\n\n\n      if (!this._propertyTracks[name]) {\n        _propertyTracks[name] = [keyframeProperty];\n\n        if (rekapi) {\n          fire(this, 'addKeyframePropertyTrack', keyframeProperty);\n        }\n      } else {\n        var index = insertionPointInTrack(_propertyTracks[name], keyframeProperty.millisecond);\n\n        if (_propertyTracks[name][index]) {\n          var newMillisecond = keyframeProperty.millisecond;\n          var targetMillisecond = _propertyTracks[name][index].millisecond;\n\n          if (targetMillisecond === newMillisecond) {\n            throw new Error('Cannot add duplicate ' + name + ' keyframe property @ ' + newMillisecond + 'ms');\n          } else if (rekapi && rekapi._warnOnOutOfOrderKeyframes) {\n            console.warn(new Error('Added a keyframe property before end of ' + name + ' track @ ' + newMillisecond + 'ms (< ' + targetMillisecond + 'ms)'));\n          }\n        }\n\n        this._insertKeyframePropertyAt(keyframeProperty, _propertyTracks[name], index);\n        cleanupAfterKeyframeModification(this);\n      }\n\n      if (rekapi) {\n        fire(this, 'addKeyframeProperty', keyframeProperty);\n      }\n\n      return this;\n    }\n\n    /*!\n     * TODO: Explain the use case for this method\n     * Set the actor to be active or inactive starting at `millisecond`.\n     * @method rekapi.Actor#setActive\n     * @param {number} millisecond The time at which to change the actor's active state\n     * @param {boolean} isActive Whether the actor should be active or inactive\n     * @return {rekapi.Actor}\n     */\n\n  }, {\n    key: 'setActive',\n    value: function setActive(millisecond, isActive) {\n      var hasActiveTrack = !!this._propertyTracks._active;\n      var activeProperty = hasActiveTrack && this.getKeyframeProperty('_active', millisecond);\n\n      if (activeProperty) {\n        activeProperty.value = isActive;\n      } else {\n        this.addKeyframeProperty(new _keyframeProperty.KeyframeProperty(millisecond, '_active', isActive));\n      }\n\n      return this;\n    }\n\n    /*!\n     * Calculate and set the actor's position at `millisecond` in the animation.\n     * @method rekapi.Actor#_updateState\n     * @param {number} millisecond\n     * @param {boolean} [resetLaterFnKeyframes] If true, allow all function\n     * keyframes later in the timeline to be run again.\n     */\n\n  }, {\n    key: '_updateState',\n    value: function _updateState(millisecond) {\n      var _this7 = this;\n\n      var resetLaterFnKeyframes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      var start = this.getStart();\n      var end = this.getEnd();\n      var interpolatedObject = {};\n\n      millisecond = Math.min(end, millisecond);\n\n      ensurePropertyCacheValid(this);\n\n      var propertyCacheEntry = (0, _utils.clone)(getPropertyCacheEntryForMillisecond(this, millisecond));\n\n      delete propertyCacheEntry._millisecond;\n\n      // All actors are active at time 0 unless otherwise specified;\n      // make sure a future time deactivation doesn't deactive the actor\n      // by default.\n      if (propertyCacheEntry._active && millisecond >= propertyCacheEntry._active.millisecond) {\n\n        this.wasActive = propertyCacheEntry._active.getValueAt(millisecond);\n\n        if (!this.wasActive) {\n          return this;\n        }\n      } else {\n        this.wasActive = true;\n      }\n\n      if (start === end) {\n        // If there is only one keyframe, use that for the state of the actor\n        (0, _utils.each)(propertyCacheEntry, function (keyframeProperty, propName) {\n          if (keyframeProperty.shouldInvokeForMillisecond(millisecond)) {\n            keyframeProperty.invoke();\n            keyframeProperty.hasFired = false;\n            return;\n          }\n\n          interpolatedObject[propName] = keyframeProperty.value;\n        });\n      } else {\n        (0, _utils.each)(propertyCacheEntry, function (keyframeProperty, propName) {\n          if (_this7._beforeKeyframePropertyInterpolate !== noop) {\n            _this7._beforeKeyframePropertyInterpolate(keyframeProperty);\n          }\n\n          if (keyframeProperty.shouldInvokeForMillisecond(millisecond)) {\n            keyframeProperty.invoke();\n            return;\n          }\n\n          interpolatedObject[propName] = keyframeProperty.getValueAt(millisecond);\n\n          if (_this7._afterKeyframePropertyInterpolate !== noop) {\n            _this7._afterKeyframePropertyInterpolate(keyframeProperty, interpolatedObject);\n          }\n        });\n      }\n\n      this.set(interpolatedObject);\n\n      if (!resetLaterFnKeyframes) {\n        this._resetFnKeyframesFromMillisecond(millisecond);\n      }\n\n      return this;\n    }\n\n    /*!\n     * @method rekapi.Actor#_resetFnKeyframesFromMillisecond\n     * @param {number} millisecond\n     */\n\n  }, {\n    key: '_resetFnKeyframesFromMillisecond',\n    value: function _resetFnKeyframesFromMillisecond(millisecond) {\n      var cache = this._timelineFunctionCache;\n      var length = cache.length;\n\n      var index = (0, _lodash2.default)(cache, { millisecond: millisecond }, getMillisecond);\n\n      while (index < length) {\n        cache[index++].hasFired = false;\n      }\n    }\n\n    /**\n     * Export this {@link rekapi.Actor} to a `JSON.stringify`-friendly `Object`.\n     * @method rekapi.Actor#exportTimeline\n     * @param {Object} [config]\n     * @param {boolean} [config.withId=false] If `true`, include internal `id`\n     * values in exported data.\n     * @return {rekapi.actorData} This data can later be consumed by {@link\n     * rekapi.Actor#importTimeline}.\n     */\n\n  }, {\n    key: 'exportTimeline',\n    value: function exportTimeline() {\n      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref2$withId = _ref2.withId,\n          withId = _ref2$withId === undefined ? false : _ref2$withId;\n\n      var exportData = {\n        start: this.getStart(),\n        end: this.getEnd(),\n        trackNames: this.getTrackNames(),\n        propertyTracks: {}\n      };\n\n      if (withId) {\n        exportData.id = this.id;\n      }\n\n      (0, _utils.each)(this._propertyTracks, function (propertyTrack, trackName) {\n        var track = [];\n\n        propertyTrack.forEach(function (keyframeProperty) {\n          track.push(keyframeProperty.exportPropertyData({ withId: withId }));\n        });\n\n        exportData.propertyTracks[trackName] = track;\n      });\n\n      return exportData;\n    }\n\n    /**\n     * Import an Object to augment this actor's state.  This does not remove\n     * keyframe properties before importing new ones.\n     * @method rekapi.Actor#importTimeline\n     * @param {rekapi.actorData} actorData Any object that has the same data\n     * format as the object generated from {@link rekapi.Actor#exportTimeline}.\n     */\n\n  }, {\n    key: 'importTimeline',\n    value: function importTimeline(actorData) {\n      var _this8 = this;\n\n      (0, _utils.each)(actorData.propertyTracks, function (propertyTrack) {\n        propertyTrack.forEach(function (property) {\n          _this8.keyframe(property.millisecond, _defineProperty({}, property.name, property.value), property.easing);\n        });\n      });\n    }\n  }]);\n\n  return Actor;\n}(_shifty.Tweenable);\n\nObject.assign(Actor.prototype, {\n  /*!\n   * @method rekapi.Actor#_beforeKeyframePropertyInterpolate\n   * @param {KeyframeProperty} keyframeProperty\n   * @abstract\n   */\n  _beforeKeyframePropertyInterpolate: noop,\n\n  /*!\n   * @method rekapi.Actor#_afterKeyframePropertyInterpolate\n   * @param {KeyframeProperty} keyframeProperty\n   * @param {Object} interpolatedObject\n   * @abstract\n   */\n  _afterKeyframePropertyInterpolate: noop\n});\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.KeyframeProperty = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _shifty = __webpack_require__(2);\n\nvar _rekapi = __webpack_require__(0);\n\nvar _utils = __webpack_require__(1);\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar DEFAULT_EASING = 'linear';\n\n/**\n * Represents an individual component of an {@link rekapi.Actor}'s keyframe\n * state.  In most cases you won't need to deal with this object directly, as\n * the {@link rekapi.Actor} APIs abstract a lot of what this Object does away\n * for you.\n * @param {number} millisecond Sets {@link\n * rekapi.KeyframeProperty#millisecond}.\n * @param {string} name Sets {@link rekapi.KeyframeProperty#name}.\n * @param {(number|string|boolean|rekapi.keyframeFunction)} value Sets {@link\n * rekapi.KeyframeProperty#value}.\n * @param {string} [easing=\"linear\"] Sets {@link\n * rekapi.KeyframeProperty#easing}.\n * @constructs rekapi.KeyframeProperty\n */\n\nvar KeyframeProperty = exports.KeyframeProperty = function () {\n  function KeyframeProperty(millisecond, name, value) {\n    var easing = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_EASING;\n\n    _classCallCheck(this, KeyframeProperty);\n\n    /**\n     * @member {string} rekapi.KeyframeProperty#id The unique ID of this {@link\n     * rekapi.KeyframeProperty}.\n     */\n    this.id = (0, _utils.uniqueId)('keyframeProperty_');\n\n    /**\n     * @member {boolean} rekapi.KeyframeProperty#hasFired Flag to determine if\n     * this {@link rekapi.KeyframeProperty}'s {@link rekapi.keyframeFunction}\n     * should be invoked in the current animation loop.\n     */\n    this.hasFired = null;\n\n    /**\n     * @member {(rekapi.Actor|undefined)} rekapi.KeyframeProperty#actor The\n     * {@link rekapi.Actor} to which this {@link rekapi.KeyframeProperty}\n     * belongs, if any.\n     */\n\n    /**\n     * @member {(rekapi.KeyframeProperty|null)}\n     * rekapi.KeyframeProperty#nextProperty A reference to the {@link\n      * rekapi.KeyframeProperty} that follows this one in a {@link\n      * rekapi.Actor}'s property track.\n     */\n    this.nextProperty = null;\n\n    Object.assign(this, {\n      /**\n       * @member {number} rekapi.KeyframeProperty#millisecond Where on the\n       * animation timeline this {@link rekapi.KeyframeProperty} is.\n       */\n      millisecond: millisecond,\n      /**\n       * @member {string} rekapi.KeyframeProperty#name This {@link\n       * rekapi.KeyframeProperty}'s name, such as `\"x\"` or `\"opacity\"`.\n       */\n      name: name,\n      /**\n       * @member {number|string|boolean|rekapi.keyframeFunction}\n       * rekapi.KeyframeProperty#value The value that this {@link\n       * rekapi.KeyframeProperty} represents.\n       */\n      value: value,\n      /**\n       * @member {string} rekapi.KeyframeProperty#easing The easing curve by\n       * which this {@link rekapi.KeyframeProperty} should be animated.\n       */\n      easing: easing\n    });\n  }\n\n  /**\n   * Modify this {@link rekapi.KeyframeProperty}.\n   * @method rekapi.KeyframeProperty#modifyWith\n   * @param {Object} newProperties Valid values are:\n   * @param {number} [newProperties.millisecond] Sets {@link\n   * rekapi.KeyframeProperty#millisecond}.\n   * @param {string} [newProperties.name] Sets {@link rekapi.KeyframeProperty#name}.\n   * @param {(number|string|boolean|rekapi.keyframeFunction)} [newProperties.value] Sets {@link\n   * rekapi.KeyframeProperty#value}.\n   * @param {string} [newProperties.easing] Sets {@link\n   * rekapi.KeyframeProperty#easing}.\n   */\n\n\n  _createClass(KeyframeProperty, [{\n    key: 'modifyWith',\n    value: function modifyWith(newProperties) {\n      Object.assign(this, newProperties);\n    }\n\n    /**\n     * Calculate the midpoint between this {@link rekapi.KeyframeProperty} and\n     * the next {@link rekapi.KeyframeProperty} in a {@link rekapi.Actor}'s\n     * property track.\n     *\n     * In just about all cases, `millisecond` should be between this {@link\n     * rekapi.KeyframeProperty}'s `millisecond` and the `millisecond` of the\n     * {@link rekapi.KeyframeProperty} that follows it in the animation\n     * timeline, but it is valid to specify a value outside of this range.\n     * @method rekapi.KeyframeProperty#getValueAt\n     * @param {number} millisecond The millisecond in the animation timeline to\n     * compute the state value for.\n     * @return {(number|string|boolean|rekapi.keyframeFunction|rekapi.KeyframeProperty#value)}\n     */\n\n  }, {\n    key: 'getValueAt',\n    value: function getValueAt(millisecond) {\n      var nextProperty = this.nextProperty;\n\n      if (typeof this.value === 'boolean') {\n        return this.value;\n      } else if (nextProperty) {\n        var boundedMillisecond = Math.min(Math.max(millisecond, this.millisecond), nextProperty.millisecond);\n\n        var name = this.name;\n\n        var delta = nextProperty.millisecond - this.millisecond;\n        var interpolatePosition = (boundedMillisecond - this.millisecond) / delta;\n\n        return (0, _shifty.interpolate)(_defineProperty({}, name, this.value), _defineProperty({}, name, nextProperty.value), interpolatePosition, nextProperty.easing)[name];\n      } else {\n        return this.value;\n      }\n    }\n\n    /**\n     * Create the reference to the {@link rekapi.KeyframeProperty} that follows\n     * this one on a {@link rekapi.Actor}'s property track.  Property tracks\n     * are just linked lists of {@link rekapi.KeyframeProperty}s.\n     * @method rekapi.KeyframeProperty#linkToNext\n     * @param {KeyframeProperty=} nextProperty The {@link\n     * rekapi.KeyframeProperty} that should immediately follow this one on the\n     * animation timeline.\n     */\n\n  }, {\n    key: 'linkToNext',\n    value: function linkToNext() {\n      var nextProperty = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      this.nextProperty = nextProperty;\n    }\n\n    /**\n     * Disassociates this {@link rekapi.KeyframeProperty} from its {@link\n     * rekapi.Actor}.  This is called by various {@link rekapi.Actor} methods\n     * and triggers the [removeKeyframeProperty]{@link rekapi.Rekapi#on} event\n     * on the associated {@link rekapi.Rekapi} instance.\n     * @method rekapi.KeyframeProperty#detach\n     * @fires rekapi.removeKeyframeProperty\n     */\n\n  }, {\n    key: 'detach',\n    value: function detach() {\n      var actor = this.actor;\n\n\n      if (actor && actor.rekapi) {\n        (0, _rekapi.fireEvent)(actor.rekapi, 'removeKeyframeProperty', this);\n        delete actor._keyframeProperties[this.id];\n        this.actor = null;\n      }\n\n      return this;\n    }\n\n    /**\n     * Export this {@link rekapi.KeyframeProperty} to a `JSON.stringify`-friendly\n     * `Object`.\n     * @method rekapi.KeyframeProperty#exportPropertyData\n     * @param {Object} [config]\n     * @param {boolean} [config.withId=false] If `true`, include internal `id`\n     * value in exported data.\n     * @return {rekapi.propertyData}\n     */\n\n  }, {\n    key: 'exportPropertyData',\n    value: function exportPropertyData() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref$withId = _ref.withId,\n          withId = _ref$withId === undefined ? false : _ref$withId;\n\n      var props = ['millisecond', 'name', 'value', 'easing'];\n\n      if (withId) {\n        props.push('id');\n      }\n\n      return (0, _utils.pick)(this, props);\n    }\n\n    /*!\n     * Whether or not this is a function keyframe and should be invoked for the\n     * current frame.  Helper method for Actor.\n     * @method rekapi.KeyframeProperty#shouldInvokeForMillisecond\n     * @return {boolean}\n     */\n\n  }, {\n    key: 'shouldInvokeForMillisecond',\n    value: function shouldInvokeForMillisecond(millisecond) {\n      return millisecond >= this.millisecond && this.name === 'function' && !this.hasFired;\n    }\n\n    /**\n     * Calls {@link rekapi.KeyframeProperty#value} if it is a {@link\n     * rekapi.keyframeFunction}.\n     * @method rekapi.KeyframeProperty#invoke\n     * @return {any} Whatever value is returned for this {@link\n     * rekapi.KeyframeProperty}'s {@link rekapi.keyframeFunction}.\n     */\n\n  }, {\n    key: 'invoke',\n    value: function invoke() {\n      var drift = this.actor.rekapi._loopPosition - this.millisecond;\n      var returnValue = this.value(this.actor, drift);\n      this.hasFired = true;\n\n      return returnValue;\n    }\n  }]);\n\n  return KeyframeProperty;\n}();\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar g;\n\n// This works in non-strict mode\ng = function () {\n\treturn this;\n}();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CanvasRenderer = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _rekapi = __webpack_require__(0);\n\nvar _rekapi2 = _interopRequireDefault(_rekapi);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// PRIVATE UTILITY FUNCTIONS\n//\n\n/*!\n * Gets (and optionally sets) height or width on a canvas.\n * @param {HTMLCanvas} canvas\n * @param {string} heightOrWidth The dimension (either \"height\" or \"width\")\n * to get or set.\n * @param {number=} newSize The new value to set for `dimension`.\n * @return {number}\n */\nvar dimension = function dimension(canvas, heightOrWidth) {\n  var newSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n\n  if (newSize !== undefined) {\n    canvas[heightOrWidth] = newSize;\n    canvas.style[heightOrWidth] = newSize + 'px';\n  }\n\n  return canvas[heightOrWidth];\n};\n\n// CANVAS RENDERER OBJECT\n//\n\n/**\n * You can use Rekapi to render animations to an HTML5 `<canvas>`.  To do so,\n * just provide a\n * [`CanvasRenderingContext2D`](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D)\n * instance to the {@link rekapi.Rekapi} constructor to\n * automatically set up the renderer:\n *\n *     const rekapi = new Rekapi(document.createElement('canvas').getContext('2d'));\n *\n *  To use this renderer's API, get a reference to the initialized object:\n *\n *     const canvasRenderer = rekapi.getRendererInstance(CanvasRenderer);\n *\n * __Note__: {@link rekapi.CanvasRenderer} is added to {@link\n * rekapi.Rekapi#renderers} automatically, there is no reason to call the\n * constructor yourself in most cases.\n * @param {rekapi.Rekapi} rekapi The {@link rekapi.Rekapi} instance to render for.\n * @param {CanvasRenderingContext2D=} context See [the canvas\n * docs](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D).\n * @constructor rekapi.CanvasRenderer\n * @extends {rekapi.renderer}\n */\n\nvar CanvasRenderer = function () {\n  function CanvasRenderer(rekapi) {\n    var _this = this;\n\n    var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n    _classCallCheck(this, CanvasRenderer);\n\n    Object.assign(this, {\n      rekapi: rekapi,\n      canvasContext: context || rekapi.context\n    });\n\n    rekapi.on('beforeUpdate', function () {\n      return _this.clear();\n    });\n  }\n\n  /**\n   * Get and optionally set the height of the associated `<canvas>` element.\n   * @method rekapi.CanvasRenderer#height\n   * @param {number} [height] The height to optionally set.\n   * @return {number}\n   */\n\n\n  _createClass(CanvasRenderer, [{\n    key: 'height',\n    value: function height() {\n      var _height = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n\n      return dimension(this.canvasContext.canvas, 'height', _height);\n    }\n\n    /**\n     * Get and optionally set the width of the associated `<canvas>` element.\n     * @method rekapi.CanvasRenderer#width\n     * @param {number} [width] The width to optionally set.\n     * @return {number}\n     */\n\n  }, {\n    key: 'width',\n    value: function width() {\n      var _width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n\n      return dimension(this.canvasContext.canvas, 'width', _width);\n    }\n\n    /**\n     * Erase the `<canvas>`.\n     * @method rekapi.CanvasRenderer#clear\n     * @return {rekapi.CanvasRenderer}\n     */\n\n  }, {\n    key: 'clear',\n    value: function clear() {\n      this.canvasContext.clearRect(0, 0, this.width(), this.height());\n\n      return this;\n    }\n  }]);\n\n  return CanvasRenderer;\n}();\n\n/*!\n * Sets up an instance of CanvasRenderer and attaches it to a `Rekapi`\n * instance.  Also augments the Rekapi instance with canvas-specific\n * functions.\n * @param {Rekapi} rekapi\n */\n\n\nexports.CanvasRenderer = CanvasRenderer;\n_rekapi.rendererBootstrappers.push(function (rekapi) {\n  if (typeof CanvasRenderingContext2D === 'undefined' || !(rekapi.context instanceof CanvasRenderingContext2D)) {\n\n    return;\n  }\n\n  return new CanvasRenderer(rekapi);\n});\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DOMRenderer = exports.getActorCSS = exports.canOptimizeAnyKeyframeProperties = exports.generateCSSClass = exports.generateCSSAnimationProperties = exports.generateAnimationIterationProperty = exports.generateAnimationNameProperty = exports.generateBoilerplatedKeyframes = exports.generateActorKeyframes = exports.canOptimizeKeyframeProperty = exports.simulateTrailingWait = exports.simulateLeadingWait = exports.generateActorTrackSegment = exports.serializeActorStep = exports.combineTransformProperties = exports.generateOptimizedKeyframeSegment = exports.applyVendorBoilerplates = exports.applyVendorPropertyPrefixes = exports.VENDOR_TOKEN = exports.TRANSFORM_TOKEN = exports.transformFunctions = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _shifty = __webpack_require__(2);\n\nvar _rekapi = __webpack_require__(0);\n\nvar _rekapi2 = _interopRequireDefault(_rekapi);\n\nvar _utils = __webpack_require__(1);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar now = _shifty.Tweenable.now;\n\n\nvar vendorTransforms = ['transform', 'webkitTransform', 'MozTransform', 'oTransform', 'msTransform'];\n\nvar transformFunctions = exports.transformFunctions = ['translateX', 'translateY', 'translateZ', 'scale', 'scaleX', 'scaleY', 'perspective', 'rotate', 'rotateX', 'rotateY', 'rotateZ', 'skewX', 'skewY'];\n\nvar DEFAULT_FPS = 30;\nvar TRANSFORM_TOKEN = exports.TRANSFORM_TOKEN = 'TRANSFORM';\nvar VENDOR_TOKEN = exports.VENDOR_TOKEN = 'VENDOR';\nvar R_TRANSFORM_TOKEN = new RegExp(TRANSFORM_TOKEN, 'g');\nvar R_VENDOR_TOKEN = new RegExp(VENDOR_TOKEN, 'g');\nvar VENDOR_PREFIXES = {\n  microsoft: '-ms-',\n  mozilla: '-moz-',\n  opera: '-o-',\n  w3: '',\n  webkit: '-webkit-'\n};\nvar BEZIERS = {\n  linear: '.25,.25,.75,.75',\n  easeInQuad: '.55,.085,.68,.53',\n  easeInCubic: '.55,.055,.675,.19',\n  easeInQuart: '.895,.03,.685,.22',\n  easeInQuint: '.755,.05,.855,.06',\n  easeInSine: '.47,0,.745,.715',\n  easeInExpo: '.95,.05,.795,.035',\n  easeInCirc: '.6,.04,.98, .335',\n  easeOutQuad: '.25,.46,.45,.94',\n  easeOutCubic: '.215,.61,.355,1',\n  easeOutQuart: '.165,.84,.44,1',\n  easeOutQuint: '.23,1,.32,1',\n  easeOutSine: '.39,.575,.565,1',\n  easeOutExpo: '.19,1,.22,1',\n  easeOutCirc: '.075,.82,.165,1',\n  easeInOutQuad: '.455,.03,.515,.955',\n  easeInOutCubic: '.645,.045,.355,1',\n  easeInOutQuart: '.77,0,.175,1',\n  easeInOutQuint: '.86,0.07,1',\n  easeInOutSine: '.445,.05,.55,.95',\n  easeInOutExpo: '1,0,0,1',\n  easeInOutCirc: '.785,.135,.15,.86'\n};\n\n// The timer to remove an injected style isn't likely to match the actual\n// length of the CSS animation, so give it some extra time to complete so it\n// doesn't cut off the end.\nvar INJECTED_STYLE_REMOVAL_BUFFER_MS = 250;\n\nvar R_3D_RULE = /3d\\(/g;\nvar _3D_RULE = '3d(';\nvar _3D_TOKEN = '__THREED__';\n\n// PRIVATE UTILITY FUNCTIONS\n//\n\n/*!\n * http://stackoverflow.com/a/3886106\n *\n * @param {number} number\n */\nvar isInt = function isInt(number) {\n  return number % 1 === 0;\n};\n\n/*!\n * @return {string}\n */\nvar vendorPrefix = function () {\n  if (typeof document === 'undefined') {\n    return;\n  }\n\n  var style = document.body.style;\n\n\n  return '-webkit-animation' in style ? 'webkit' : '-moz-animation' in style ? 'mozilla' : '-ms-animation' in style ? 'microsoft' : '-o-animation' in style ? 'opera' : 'animation' in style ? 'w3' : '';\n}();\n\n/*!\n * @param {Actor} actor\n * @return {string} The default CSS class that is targeted by {@link\n * rekapi.DOMRenderer#getCss} if a custom class is not specified.  This may be\n * useful for getting a standard and consistent CSS class name for an actor's\n * DOM element.\n */\nvar getActorClassName = function getActorClassName(actor) {\n  return 'actor-' + actor.id;\n};\n\n/*!\n * Fixes a really bizarre issue that only seems to affect Presto and Blink.\n * In some situations, DOM nodes will not detect dynamically injected <style>\n * elements.  Explicitly re-inserting DOM nodes seems to fix the issue.  Not\n * sure what causes this issue.  Not sure why this fixes it.\n *\n * @param {Rekapi} rekapi\n */\nvar forceStyleReset = function forceStyleReset(rekapi) {\n  var dummyDiv = document.createElement('div');\n\n  rekapi.getAllActors().forEach(function (actor) {\n    if (actor.context.nodeType === 1) {\n      var context = actor.context;\n      var parentElement = context.parentElement;\n\n\n      parentElement.replaceChild(dummyDiv, context);\n      parentElement.replaceChild(context, dummyDiv);\n    }\n  });\n};\n\nvar styleID = 0;\n/*!\n * @param {Rekapi} rekapi\n * @param {string} css The css content that the <style> element should have.\n * @return {HTMLStyleElement} The unique ID of the injected <style> element.\n */\nvar injectStyle = function injectStyle(rekapi, css) {\n  var style = document.createElement('style');\n  var id = 'rekapi-' + styleID++;\n  style.id = id;\n  style.innerHTML = css;\n  document.head.appendChild(style);\n  forceStyleReset(rekapi);\n\n  return style;\n};\n\n/*!\n * @param {HTMLElement} element\n * @param {string} styleName\n * @param {string|number} styleValue\n */\nvar setStyle = function setStyle(element, styleName, styleValue) {\n  return element.style[styleName] = styleValue;\n};\n\n/*!\n * @param {string} name A transform function name\n * @return {boolean}\n */\nvar isTransformFunction = function isTransformFunction(name) {\n  return ~transformFunctions.indexOf(name);\n};\n\n/*!\n * Builds a concatenated string of given transform property values in order.\n *\n * @param {Array.<string>} orderedTransforms Array of ordered transform\n *     function names\n * @param {Object} transformProperties Transform properties to build together\n * @return {string}\n */\nvar buildTransformValue = function buildTransformValue(orderedTransforms, transformProperties) {\n  var transformComponents = [];\n\n  orderedTransforms.forEach(function (functionName) {\n    if (transformProperties[functionName] !== undefined) {\n      transformComponents.push(functionName + '(' + transformProperties[functionName] + ')');\n    }\n  });\n\n  return transformComponents.join(' ');\n};\n\n/*!\n * Sets value for all vendor prefixed transform properties on an element\n *\n * @param {HTMLElement} element The actor's DOM element\n * @param {string} transformValue The transform style value\n */\nvar setTransformStyles = function setTransformStyles(element, transformValue) {\n  return vendorTransforms.forEach(function (prefixedTransform) {\n    return setStyle(element, prefixedTransform, transformValue);\n  });\n};\n\n/*!\n * @param {Actor} actor\n * @param {HTMLElement} element\n * @param {Object} state\n */\nvar actorRender = function actorRender(actor, element, state) {\n  var propertyNames = Object.keys(state);\n  // TODO:  Optimize the following code so that propertyNames is not looped\n  // over twice.\n  var transformFunctionNames = propertyNames.filter(isTransformFunction);\n  var otherProperties = (0, _utils.pick)(state, (0, _utils.reject)(propertyNames, isTransformFunction));\n\n  if (transformFunctionNames.length) {\n    setTransformStyles(element, buildTransformValue(actor._transformOrder, (0, _utils.pick)(state, transformFunctionNames)));\n  } else if (state.transform) {\n    setTransformStyles(element, state.transform);\n  }\n\n  (0, _utils.each)(otherProperties, function (styleValue, styleName) {\n    return setStyle(element, styleName, styleValue);\n  });\n};\n\n/*!\n * @param {Actor} actor\n */\nvar actorTeardown = function actorTeardown(actor) {\n  var context = actor.context;\n\n  var classList = context.className.match(/\\S+/g);\n  var sanitizedClassList = (0, _utils.without)(classList, getActorClassName(actor));\n  context.className = sanitizedClassList.join(' ');\n};\n\n/*!\n * transform properties like translate3d and rotate3d break the cardinality\n * of multi-ease easing strings, because the \"3\" gets treated like a\n * tweenable value.  Transform \"3d(\" to \"__THREED__\" to prevent this, and\n * transform it back in _afterKeyframePropertyInterpolate.\n *\n * @param {KeyframeProperty} keyframeProperty\n */\nvar _beforeKeyframePropertyInterpolate = function _beforeKeyframePropertyInterpolate(keyframeProperty) {\n  if (keyframeProperty.name !== 'transform') {\n    return;\n  }\n\n  var value = keyframeProperty.value,\n      nextProperty = keyframeProperty.nextProperty;\n\n\n  if (nextProperty && value.match(R_3D_RULE)) {\n    keyframeProperty.value = value.replace(R_3D_RULE, _3D_TOKEN);\n    nextProperty.value = nextProperty.value.replace(R_3D_RULE, _3D_TOKEN);\n  }\n};\n\n/*!\n * @param {KeyframeProperty} keyframeProperty\n * @param {Object} interpolatedObject\n */\nvar _afterKeyframePropertyInterpolate = function _afterKeyframePropertyInterpolate(keyframeProperty, interpolatedObject) {\n  if (keyframeProperty.name !== 'transform') {\n    return;\n  }\n\n  var value = keyframeProperty.value,\n      nextProperty = keyframeProperty.nextProperty,\n      name = keyframeProperty.name;\n\n\n  if (nextProperty && value.match(_3D_TOKEN)) {\n    keyframeProperty.value = value.replace(_3D_TOKEN, _3D_RULE);\n    nextProperty.value = nextProperty.value.replace(_3D_TOKEN, _3D_RULE);\n    interpolatedObject[name] = interpolatedObject[name].replace(_3D_TOKEN, _3D_RULE);\n  }\n};\n\n/*!\n * @param {Rekapi} rekapi\n * @param {Actor} actor\n */\nvar onAddActor = function onAddActor(rekapi, actor) {\n  var context = actor.context;\n\n\n  if (context.nodeType !== 1) {\n    return;\n  }\n\n  var className = getActorClassName(actor);\n\n  // Add the class if it's not already there.\n  // Using className instead of classList to make IE happy.\n  if (!context.className.match(className)) {\n    context.className += ' ' + className;\n  }\n\n  Object.assign(actor, {\n    render: actorRender.bind(actor, actor),\n    teardown: actorTeardown.bind(actor, actor),\n    _transformOrder: transformFunctions.slice(0),\n    _beforeKeyframePropertyInterpolate: _beforeKeyframePropertyInterpolate,\n    _afterKeyframePropertyInterpolate: _afterKeyframePropertyInterpolate\n  });\n};\n\n/*!\n * @param {string} keyframes\n * @param {vendor} vendor\n * @return {string}\n */\nvar applyVendorPropertyPrefixes = exports.applyVendorPropertyPrefixes = function applyVendorPropertyPrefixes(keyframes, vendor) {\n  return keyframes.replace(R_VENDOR_TOKEN, VENDOR_PREFIXES[vendor]).replace(R_TRANSFORM_TOKEN, VENDOR_PREFIXES[vendor] + 'transform');\n};\n\n/*!\n * @param {string} toKeyframes Generated keyframes to wrap in boilerplates\n * @param {string} animName\n * @param {Array.<string>=} vendors Vendor boilerplates to be applied.\n *     Should be any of the values in Rekapi.util.VENDOR_PREFIXES.\n * @return {string}\n */\nvar applyVendorBoilerplates = exports.applyVendorBoilerplates = function applyVendorBoilerplates(toKeyframes, animName) {\n  var vendors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ['w3'];\n  return vendors.map(function (vendor) {\n    return applyVendorPropertyPrefixes('@' + VENDOR_PREFIXES[vendor] + 'keyframes ' + animName + '-keyframes {\\n' + toKeyframes + '\\n' + '}', vendor);\n  }).join('\\n');\n};\n\n/*!\n * @param {KeyframeProperty} property\n * @param {number} fromPercent\n * @param {number} toPercent\n * @return {string}\n */\nvar generateOptimizedKeyframeSegment = exports.generateOptimizedKeyframeSegment = function generateOptimizedKeyframeSegment(property, fromPercent, toPercent) {\n  var name = property.name === 'transform' ? TRANSFORM_TOKEN : property.name;\n\n  var nextProperty = property.nextProperty,\n      value = property.value;\n\n  var from = isInt(fromPercent) ? fromPercent : fromPercent.toFixed(2);\n  var to = isInt(toPercent) ? toPercent : toPercent.toFixed(2);\n  var bezier = BEZIERS[nextProperty.easing.split(' ')[0]];\n\n  return '  ' + from + '% {' + name + ':' + value + ';' + VENDOR_TOKEN + 'animation-timing-function: cubic-bezier(' + bezier + ');' + '}\\n  ' + to + '% {' + name + ':' + nextProperty.value + ';}';\n};\n\n/*!\n * @param {Object} propsToSerialize\n * @param {Array.<string>} transformNames\n * @return {Object}\n */\nvar combineTransformProperties = exports.combineTransformProperties = function combineTransformProperties(propsToSerialize, transformNames) {\n  if (Object.keys((0, _utils.pick)(propsToSerialize, transformFunctions)).length) {\n    var _ret = function () {\n      var serializedProps = (0, _utils.clone)(propsToSerialize);\n\n      serializedProps[TRANSFORM_TOKEN] = transformNames.reduce(function (combinedProperties, transformFunction) {\n        if (serializedProps.hasOwnProperty(transformFunction)) {\n          combinedProperties += ' ' + transformFunction + '(' + serializedProps[transformFunction] + ')';\n\n          delete serializedProps[transformFunction];\n        }\n\n        return combinedProperties;\n      }, '').slice(1);\n\n      return {\n        v: serializedProps\n      };\n    }();\n\n    if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n  } else {\n    return propsToSerialize;\n  }\n};\n\n/*!\n * @param {Actor} actor\n * @param {string=} targetProp\n * @return {string}\n */\nvar serializeActorStep = exports.serializeActorStep = function serializeActorStep(actor) {\n  var targetProp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n  var transformProperties = combineTransformProperties(targetProp ? _defineProperty({}, targetProp, actor.get()[targetProp]) : actor.get(), actor._transformOrder);\n\n  var data = Object.keys(transformProperties).reduce(function (acc, key) {\n    return '' + acc + (key === 'transform' ? TRANSFORM_TOKEN : key) + ':' + transformProperties[key] + ';';\n  }, '');\n\n  return '{' + data + '}';\n};\n\n/*!\n * @param {Actor} actor\n * @param {number} increments\n * @param {number} incrementSize\n * @param {number} actorStart\n * @param {number} fromPercent\n * @param {KeyframeProperty=} fromProp\n * @return {Array.<string>}\n */\nvar generateActorTrackSegment = exports.generateActorTrackSegment = function generateActorTrackSegment(actor, increments, incrementSize, actorStart, fromPercent) {\n  var fromProp = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : undefined;\n\n\n  var accumulator = [];\n  var length = actor.getLength();\n\n  for (var i = 0; i < increments; i++) {\n    var percent = fromPercent + i * incrementSize;\n\n    actor._updateState(percent / 100 * length + actorStart, true);\n\n    var step = serializeActorStep(actor, fromProp && fromProp.name);\n\n    accumulator.push('  ' + +percent.toFixed(2) + '% ' + step);\n  }\n\n  return accumulator;\n};\n\n/*!\n * @param {Actor} actor\n * @param {number} steps\n * @return {string}\n */\nvar generateCombinedActorKeyframes = function generateCombinedActorKeyframes(actor, steps) {\n  return generateActorTrackSegment(actor, steps + 1, 100 / steps, 0, 0).join('\\n');\n};\n\n/*!\n * @param {Actor} actor\n * @param {string} track\n * @param {number} actorStart\n * @return {string|undefined}\n */\nvar simulateLeadingWait = exports.simulateLeadingWait = function simulateLeadingWait(actor, track, actorStart) {\n  var firstProp = actor._propertyTracks[track][0];\n\n  if (firstProp !== undefined && firstProp.millisecond !== actorStart) {\n    return generateActorTrackSegment(actor, 1, 1, firstProp.millisecond, 0, firstProp).join('\\n');\n  }\n};\n\n/*!\n * @param {Actor} actor\n * @param {string} track\n * @param {number} actorStart\n * @param {number} actorEnd\n * @return {string|undefined}\n */\nvar simulateTrailingWait = exports.simulateTrailingWait = function simulateTrailingWait(actor, track, actorStart, actorEnd) {\n  var _actor$_propertyTrack = actor._propertyTracks[track].slice(-1),\n      _actor$_propertyTrack2 = _slicedToArray(_actor$_propertyTrack, 1),\n      lastProp = _actor$_propertyTrack2[0];\n\n  if (lastProp !== undefined && lastProp.millisecond !== actorEnd) {\n    return generateActorTrackSegment(actor, 1, 1, actorStart, 100, lastProp).join('\\n');\n  }\n};\n\n/*!\n * @param {KeyframeProperty} property\n * @param {number} actorStart\n * @param {number} actorLength\n * @return {number}\n */\nvar calculateStepPercent = function calculateStepPercent(property, actorStart, actorLength) {\n  return (property.millisecond - actorStart) / actorLength * 100;\n};\n\n/*!\n * @param {Actor} actor\n * @param {number} actorStart\n * @param {KeyframeProperty} fromProp\n * @param {KeyframeProperty} toProp\n * @param {number} fromPercent\n * @param {number} toPercent\n * @return {Array.<string>}\n */\nvar generateActorTrackWaitSegment = function generateActorTrackWaitSegment(actor, actorStart, fromProp, toProp, fromPercent, toPercent) {\n  return generateActorTrackSegment(actor, 1, toPercent - fromPercent, actorStart, fromPercent, fromProp);\n};\n\n/*!\n * @param {KeyframeProperty} property\n * @param {KeyframeProperty} nextProperty\n * @return {boolean}\n */\nvar isSegmentAWait = function isSegmentAWait(property, nextProperty) {\n  return property.name === nextProperty.name && property.value === nextProperty.value;\n};\n\n/*!\n * @param {KeyframeProperty} property\n * @return {boolean}\n */\nvar canOptimizeKeyframeProperty = exports.canOptimizeKeyframeProperty = function canOptimizeKeyframeProperty(property) {\n  return !property.nextProperty ? false : isSegmentAWait(property, property.nextProperty) ? true : property.nextProperty.easing.split(' ').every(function (easing, i, easings) {\n    return !(!BEZIERS[easing] || i > 0 && easings[i - 1] !== easing);\n  });\n};\n\n/*!\n * @param {Actor} actor\n * @param {number} steps\n * @param {string} track\n * @return {string}\n */\nvar generateActorKeyframes = exports.generateActorKeyframes = function generateActorKeyframes(actor, steps, track) {\n  // This function is completely crazy.  Simplify it?\n  var accumulator = [];\n  var end = actor.getEnd();\n  var start = actor.getStart();\n  var length = actor.getLength();\n  var leadingWait = simulateLeadingWait(actor, track, start);\n\n  if (leadingWait) {\n    accumulator.push(leadingWait);\n  }\n\n  var previousSegmentWasOptimized = false;\n  actor._propertyTracks[track].forEach(function (prop) {\n    var fromPercent = calculateStepPercent(prop, start, length);\n    var nextProperty = prop.nextProperty;\n\n\n    var toPercent = void 0,\n        increments = void 0,\n        incrementSize = void 0;\n\n    if (nextProperty) {\n      toPercent = calculateStepPercent(nextProperty, start, length);\n      var delta = toPercent - fromPercent;\n      increments = Math.floor(delta / 100 * steps) || 1;\n      incrementSize = delta / increments;\n    } else {\n      toPercent = 100;\n      increments = 1;\n      incrementSize = 1;\n    }\n\n    var trackSegment = void 0;\n    if (nextProperty && isSegmentAWait(prop, nextProperty)) {\n      trackSegment = generateActorTrackWaitSegment(actor, start, prop, nextProperty, fromPercent, toPercent);\n\n      if (previousSegmentWasOptimized) {\n        trackSegment.shift();\n      }\n\n      previousSegmentWasOptimized = false;\n    } else if (canOptimizeKeyframeProperty(prop)) {\n      trackSegment = generateOptimizedKeyframeSegment(prop, fromPercent, toPercent);\n\n      // If this and the previous segment are optimized, remove the\n      // destination keyframe of the previous step.  The starting keyframe of\n      // the newest segment makes it redundant.\n      if (previousSegmentWasOptimized) {\n        accumulator[accumulator.length - 1] = accumulator[accumulator.length - 1].split('\\n')[0];\n      }\n\n      previousSegmentWasOptimized = true;\n    } else {\n      trackSegment = generateActorTrackSegment(actor, increments, incrementSize, start, fromPercent, prop);\n\n      if (previousSegmentWasOptimized) {\n        trackSegment.shift();\n      }\n\n      if (trackSegment.length) {\n        trackSegment = trackSegment.join('\\n');\n      }\n\n      previousSegmentWasOptimized = false;\n    }\n\n    if (trackSegment.length) {\n      accumulator.push(trackSegment);\n    }\n  });\n\n  var trailingWait = simulateTrailingWait(actor, track, start, end);\n\n  if (trailingWait) {\n    accumulator.push(trailingWait);\n  }\n\n  return accumulator.join('\\n');\n};\n\n/*!\n * @param {Actor} actor\n * @param {string} animName\n * @param {number} steps\n * @param {boolean} doCombineProperties\n * @param {Array.<string>=} vendors\n * @return {string}\n */\nvar generateBoilerplatedKeyframes = exports.generateBoilerplatedKeyframes = function generateBoilerplatedKeyframes(actor, animName, steps, doCombineProperties) {\n  var vendors = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;\n  return doCombineProperties ? applyVendorBoilerplates(generateCombinedActorKeyframes(actor, steps), animName, vendors) : actor.getTrackNames().map(function (trackName) {\n    return applyVendorBoilerplates(generateActorKeyframes(actor, steps, trackName), animName + '-' + trackName, vendors);\n  }).join('\\n');\n};\n\n/*!\n * @param {Actor} actor\n * @param {string} animName\n * @param {string} prefix\n * @param {boolean} doCombineProperties\n * @return {string}\n */\nvar generateAnimationNameProperty = exports.generateAnimationNameProperty = function generateAnimationNameProperty(actor, animationName, prefix, doCombineProperties) {\n\n  var renderedName = '  ' + prefix + 'animation-name:';\n\n  if (doCombineProperties) {\n    renderedName += ' ' + animationName + '-keyframes;';\n  } else {\n    var trackNames = actor.getTrackNames();\n\n    var trackNamesToPrint = (0, _utils.intersection)(trackNames, transformFunctions).length ? (0, _utils.difference)(trackNames, transformFunctions).concat('transform') : trackNames;\n\n    renderedName = trackNamesToPrint.reduce(function (renderedName, trackName) {\n      return renderedName + ' ' + animationName + '-' + trackName + '-keyframes,';\n    }, renderedName).replace(/.$/, ';');\n  }\n\n  return renderedName;\n};\n\n/*!\n * @param {Rekapi} rekapi\n * @param {string} prefix\n * @param {number|string=} iterations\n * @return {string}\n */\nvar generateAnimationIterationProperty = exports.generateAnimationIterationProperty = function generateAnimationIterationProperty(rekapi, prefix) {\n  var iterations = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n  return '  ' + prefix + 'animation-iteration-count: ' + (iterations !== undefined ? iterations : rekapi._timesToIterate === -1 ? 'infinite' : rekapi._timesToIterate) + ';';\n};\n\n/*!\n * @param {Actor} actor\n * @param {string} animName\n * @param {string} vendor\n * @param {boolean} doCombineProperties\n * @param {number|string=} iterations\n * @param {boolean=} isCentered\n * @return {string}\n */\nvar generateCSSAnimationProperties = exports.generateCSSAnimationProperties = function generateCSSAnimationProperties(actor, animName, vendor, doCombineProperties) {\n  var iterations = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;\n  var isCentered = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n\n  var prefix = VENDOR_PREFIXES[vendor];\n  var start = actor.getStart();\n  var end = actor.getEnd();\n\n  var generatedProperties = [generateAnimationNameProperty(actor, animName, prefix, doCombineProperties), '  ' + prefix + 'animation-duration: ' + (end - start) + 'ms;', '  ' + prefix + 'animation-delay: ' + start + 'ms;', '  ' + prefix + 'animation-fill-mode: forwards;', '  ' + prefix + 'animation-timing-function: linear;', generateAnimationIterationProperty(actor.rekapi, prefix, iterations)];\n\n  if (isCentered) {\n    generatedProperties.push('  ' + prefix + 'transform-origin: 0 0;');\n  }\n\n  return generatedProperties.join('\\n');\n};\n\n/*!\n * @param {Actor} actor\n * @param {string} animName\n * @param {boolean} doCombineProperties\n * @param {Array.<string>=} vendors\n * @param {number|string=} iterations\n * @param {boolean=} isCentered\n * @return {string}\n */\nvar generateCSSClass = exports.generateCSSClass = function generateCSSClass(actor, animName, doCombineProperties) {\n  var vendors = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ['w3'];\n  var iterations = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;\n  var isCentered = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : undefined;\n  return '.' + animName + ' {\\n' + vendors.map(function (vendor) {\n    return generateCSSAnimationProperties(actor, animName, vendor, doCombineProperties, iterations, isCentered);\n  }).join('\\n') + '\\n}';\n};\n\n/*!\n * @param {Actor} actor\n * @return {boolean}\n */\nvar canOptimizeAnyKeyframeProperties = exports.canOptimizeAnyKeyframeProperties = function canOptimizeAnyKeyframeProperties(actor) {\n  return Object.keys(actor._keyframeProperties).some(function (property) {\n    return canOptimizeKeyframeProperty(actor._keyframeProperties[property]);\n  }) && !(0, _utils.intersection)(Object.keys(actor._propertyTracks), transformFunctions).length;\n};\n\n/*!\n * Creates the CSS `@keyframes` for an individual actor.\n * @param {Actor} actor\n * @param {Object=} options Same as options for Rekapi.prototype.toCSS.\n * @return {string}\n */\nvar getActorCSS = exports.getActorCSS = function getActorCSS(actor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var name = options.name,\n      vendors = options.vendors,\n      iterations = options.iterations,\n      isCentered = options.isCentered;\n\n\n  var animName = name ? actor.rekapi.getActorCount() > 1 ? name + '-' + actor.id : name : getActorClassName(actor);\n\n  var steps = Math.ceil(actor.rekapi.getAnimationLength() / 1000 * (options.fps || DEFAULT_FPS));\n\n  var doCombineProperties = !canOptimizeAnyKeyframeProperties(actor);\n\n  return [generateCSSClass(actor, animName, doCombineProperties, vendors, iterations, isCentered), generateBoilerplatedKeyframes(actor, animName, steps, doCombineProperties, vendors)].join('\\n');\n};\n\n/**\n * {@link rekapi.DOMRenderer} allows you to animate DOM elements.  This is\n * achieved either by [CSS `@keyframe`\n * animations](https://developer.mozilla.org/en-US/docs/Web/CSS/@keyframes), or\n * by per-frame inline style updates  keyframes are defined with the same API\n * in either case.  To render animations with the DOM, just supply any DOM\n * element to the {@link rekapi.Rekapi} constructor.  You may use\n * `document.body`, since it is generally always available:\n *\n *     const rekapi = new Rekapi(document.body);\n *\n *  To use this renderer's API, get a reference to the initialized object:\n *\n *     const domRenderer = rekapi.getRendererInstance(DOMRenderer);\n *\n * There are separate APIs for playing inline style animations and CSS\n * `@keyframe` animations.  For a detailed breakdown of how to choose between\n * these two APIs and use {@link rekapi.DOMRenderer} effectively, check out the\n * {@tutorial dom-rendering-in-depth} tutorial.\n *\n * __Note__: {@link rekapi.DOMRenderer} is added to {@link\n * rekapi.Rekapi#renderers} automatically, there is no reason to call the\n * constructor yourself in most cases.\n * @param {rekapi.Rekapi} rekapi The {@link rekapi.Rekapi} instance to render for.\n * @constructor rekapi.DOMRenderer\n * @extends {rekapi.renderer}\n */\n\nvar DOMRenderer = exports.DOMRenderer = function () {\n  function DOMRenderer(rekapi) {\n    var _this = this;\n\n    _classCallCheck(this, DOMRenderer);\n\n    Object.assign(this, {\n      rekapi: rekapi,\n\n      // @private {number}\n      _playTimestamp: null,\n\n      // @private {string}\n      _cachedCSS: null,\n\n      // The HTMLStyleElement that gets injected into the DOM.\n      // @private {HTMLStyleElement)\n      _styleElement: null,\n\n      // @private {number}\n      _stopSetTimeoutHandle: null\n    });\n\n    rekapi.on('timelineModified', function () {\n      return _this._cachedCSS = null;\n    });\n    rekapi.on('addActor', onAddActor);\n  }\n\n  /**\n   * @method rekapi.DOMRenderer#canAnimateWithCSS\n   * @return {boolean} Whether or not the browser supports CSS `@keyframe`\n   * animations.\n   */\n\n\n  _createClass(DOMRenderer, [{\n    key: 'canAnimateWithCSS',\n    value: function canAnimateWithCSS() {\n      return !!vendorPrefix;\n    }\n\n    /**\n     * Play the Rekapi animation as a CSS `@keyframe` animation.\n     *\n     * Note that this is not the same as {@link rekapi.Rekapi#play}.  That method\n     * controls inline style animations, while this method controls CSS\n     * `@keyframe` animations.\n     * @method rekapi.DOMRenderer#play\n     * @param {number} [iterations] How many times the animation should loop.\n     * This can be `null` or `0` if you want to loop the animation endlessly but\n     * also specify a value for `fps`.\n     * @param {number} [fps] How many `@keyframes` to generate per second of the\n     * animation.  A higher value results in a more precise CSS animation, but it\n     * will take longer to generate.  The default value is `30`.  You should not\n     * need to go higher than `60`.\n     * @fires rekapi.play\n     */\n\n  }, {\n    key: 'play',\n    value: function play() {\n      var iterations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n      var fps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n      if (this.isPlaying()) {\n        this.stop();\n      }\n\n      this._styleElement = injectStyle(this.rekapi, this._cachedCSS || this.prerender.apply(this, arguments));\n\n      this._playTimestamp = now();\n\n      if (iterations) {\n        var animationLength = iterations * this.rekapi.getAnimationLength();\n        this._stopSetTimeoutHandle = setTimeout(this.stop.bind(this, true), animationLength + INJECTED_STYLE_REMOVAL_BUFFER_MS);\n      }\n\n      (0, _rekapi.fireEvent)(this.rekapi, 'play');\n    }\n\n    /**\n     * Stop a CSS `@keyframe` animation.  This also removes any `<style>`\n     * elements that were dynamically injected into the DOM.\n     *\n     * Note that this is not the same as {@link rekapi.Rekapi#stop}.  That method\n     * controls inline style animations, while this method controls CSS\n     * `@keyframe` animations.\n     * @method rekapi.DOMRenderer#stop\n     * @param {boolean=} goToEnd If true, skip to the end of the animation.  If\n     * false or omitted, set inline styles on the {@link rekapi.Actor} elements\n     * to keep them in their current position.\n     * @fires rekapi.stop\n     */\n\n  }, {\n    key: 'stop',\n    value: function stop() {\n      var goToEnd = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n\n      if (this.isPlaying()) {\n        clearTimeout(this._stopSetTimeoutHandle);\n\n        // Forces a style update in WebKit/Presto\n        this._styleElement.innerHTML = '';\n\n        document.head.removeChild(this._styleElement);\n        this._styleElement = null;\n        var animationLength = this.rekapi.getAnimationLength();\n\n        this.rekapi.update(goToEnd ? animationLength : (now() - this._playTimestamp) % animationLength);\n\n        (0, _rekapi.fireEvent)(this.rekapi, 'stop');\n      }\n    }\n\n    /**\n     * @method rekapi.DOMRenderer#isPlaying\n     * @return {boolean} Whether or not a CSS `@keyframe` animation is running.\n     */\n\n  }, {\n    key: 'isPlaying',\n    value: function isPlaying() {\n      return !!this._styleElement;\n    }\n\n    /**\n     * Prerender and cache the CSS animation so that it is immediately ready to\n     * be used when it is needed in the future.  The function signature is\n     * identical to {@link rekapi.DOMRenderer#play}.  This\n     * is necessary to play a CSS animation and will be automatically called for\n     * you if you don't call it manually, but calling it ahead of time (such as\n     * on page load) will prevent any perceived lag when a CSS `@keyframe`\n     * animation is started.  The prerendered animation is cached for reuse until\n     * the timeline or a keyframe is modified.\n     *\n     * @method rekapi.DOMRenderer#prerender\n     * @param {number=} iterations How many times the animation should loop.\n     * This can be `null` or `0` if you want to loop the animation endlessly but\n     * also specify a value for `fps`.\n     * @param {number=} fps How many `@keyframes` to generate per second of\n     * the animation.  A higher value results in a more precise CSS animation,\n     * but it will take longer to generate.  The default value is `30`.  You\n     * should not need to go higher than `60`.\n     * @return {string} The prerendered CSS string.  You likely won't need this,\n     * as it is also cached internally.\n     */\n\n  }, {\n    key: 'prerender',\n    value: function prerender() {\n      var iterations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n      var fps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n      return this._cachedCSS = this.getCss({\n        vendors: [vendorPrefix],\n        fps: fps,\n        iterations: iterations\n      });\n    }\n\n    /**\n     * You can decouple transform components in order to animate each property\n     * with its own easing curve:\n     *\n     *     actor\n     *       .keyframe(0, {\n     *         translateX: '0px',\n     *         translateY: '0px',\n     *         rotate: '0deg'\n     *       })\n     *       .keyframe(1500, {\n     *         translateX: '200px',\n     *         translateY: '200px',\n     *         rotate: '90deg'\n     *       }, {\n     *         translateX: 'easeOutExpo',\n     *         translateY: 'easeInSine',\n     *         rotate: 'elastic'\n     *       });\n     *\n     * CSS transform string components are order-dependent, but JavaScript object\n     * properties have an unpredictable order.  Rekapi must combine transform\n     * properties supplied to {@link rekapi.Actor#keyframe} (as shown above) into\n     * a single string when it renders each frame.  This method lets you change\n     * that order from the default.\n     *\n     * However, if you prefer a more standards-oriented approach, Rekapi also\n     * supports combining the transform components yourself, obviating the need\n     * for {@link rekapi.DOMRenderer#setActorTransformOrder} entirely:\n     *\n     *     actor\n     *       .keyframe(0, {\n     *         transform: 'translateX(0px) translateY(0px) rotate(0deg)'\n     *       })\n     *       .keyframe(1500, {\n     *         transform: 'translateX(200px) translateY(200px) rotate(90deg)'\n     *       }, {\n     *         transform: 'easeOutExpo easeInSine elastic'\n     *       });\n     * @method rekapi.DOMRenderer#setActorTransformOrder\n     * @param {rekapi.Actor} actor The {@link rekapi.Actor} to apply the new\n     * transform order to.\n     * @param {Array.<string>} orderedTransforms The array of transform names.\n     * The supported array values (and default order) are:\n     *\n     * - `translateX`\n     * - `translateY`\n     * - `translateZ`\n     * - `scale`\n     * - `scaleX`\n     * - `scaleY`\n     * - `perspective`\n     * - `rotate`\n     * - `rotateX`\n     * - `rotateY`\n     * - `rotateZ`\n     * - `skewX`\n     * - `skewY`\n     * @return {rekapi.Rekapi}\n     */\n\n  }, {\n    key: 'setActorTransformOrder',\n    value: function setActorTransformOrder(actor, orderedTransforms) {\n      var unrecognizedTransforms = (0, _utils.reject)(orderedTransforms, isTransformFunction);\n\n      if (unrecognizedTransforms.length) {\n        throw 'Unknown or unsupported transform functions: ' + unrecognizedTransforms.join(', ');\n      }\n\n      // Ignore duplicate transform function names in the array\n      actor._transformOrder = (0, _utils.uniq)(orderedTransforms);\n\n      return this.rekapi;\n    }\n\n    /**\n     * Convert the animation to CSS `@keyframes`.\n     * @method rekapi.DOMRenderer#getCss\n     * @param {Object} [options={}]\n     * @param {Array.<string>} [options.vendors=['w3']] The browser vendors you\n     * want to support. Valid values are:\n     *   * `'microsoft'`\n     *   * `'mozilla'`\n     *   * `'opera'`\n     *   * `'w3'`\n     *   * `'webkit'`\n     *\n     *\n     * @param {number} [options.fps=30]  Defines the number of CSS `@keyframe` frames\n     * rendered per second of an animation.  CSS `@keyframes` are comprised of a\n     * series of explicitly defined steps, and more steps will allow for a more\n     * complex animation.  More steps will also result in a larger CSS string,\n     * and more time needed to generate the string.\n     * @param {string} [options.name] Define a custom name for your animation.\n     * This becomes the class name targeted by the generated CSS.\n     * @param {boolean} [options.isCentered] If `true`, the generated CSS will\n     * contain `transform-origin: 0 0;`, which centers the DOM element along the\n     * path of motion.  If `false` or omitted, no `transform-origin` rule is\n     * specified and the element is aligned to the path of motion by its top-left\n     * corner.\n     * @param {number} [options.iterations] How many times the generated\n     * animation should repeat.  If omitted, the animation will loop\n     * indefinitely.\n     * @return {string}\n     */\n\n  }, {\n    key: 'getCss',\n    value: function getCss() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var animationCSS = [];\n\n      this.rekapi.getAllActors().forEach(function (actor) {\n        if (actor.context.nodeType === 1) {\n          animationCSS.push(getActorCSS(actor, options));\n        }\n      });\n\n      return animationCSS.join('\\n');\n    }\n  }]);\n\n  return DOMRenderer;\n}();\n\n/*!\n * @param {Rekapi} rekapi\n */\n\n\n_rekapi.rendererBootstrappers.push(function (rekapi) {\n  return (\n    // Node.nodeType 1 is an ELEMENT_NODE.\n    // https://developer.mozilla.org/en-US/docs/Web/API/Node.nodeType\n    rekapi.context.nodeType === 1 && new DOMRenderer(rekapi)\n  );\n});\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global, module) {\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used to compose bitmasks for comparison styles. */\nvar UNORDERED_COMPARE_FLAG = 1,\n    PARTIAL_COMPARE_FLAG = 2;\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_SAFE_INTEGER = 9007199254740991;\n\n/** Used as references for the maximum length and index of an array. */\nvar MAX_ARRAY_LENGTH = 4294967295,\n    MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/,\n    reLeadingDot = /^\\./,\n    rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = (typeof self === 'undefined' ? 'undefined' : _typeof(self)) == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports = ( false ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && ( false ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = function () {\n  try {\n    return freeProcess && freeProcess.binding('util');\n  } catch (e) {}\n}();\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function (object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function (value) {\n    return func(value);\n  };\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function (value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function (arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function (value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = function () {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? 'Symbol(src)_1.' + uid : '';\n}();\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&').replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$');\n\n/** Built-in value references. */\nvar _Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeFloor = Math.floor,\n    nativeKeys = overArg(Object.keys, Object),\n    nativeMin = Math.min;\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = _Symbol ? _Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash(),\n    'map': new (Map || ListCache)(),\n    'string': new Hash()\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values ? values.length : 0;\n\n  this.__data__ = new MapCache();\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\n/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  this.__data__ = new ListCache(entries);\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache();\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  return this.__data__['delete'](key);\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var cache = this.__data__;\n  if (cache instanceof ListCache) {\n    var pairs = cache.__data__;\n    if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {\n      pairs.push([key, value]);\n      return this;\n    }\n    cache = this.__data__ = new MapCache(pairs);\n  }\n  cache.set(key, value);\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  // Safari 9 makes `arguments.length` enumerable in strict mode.\n  var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];\n\n  var length = result.length,\n      skipIndexes = !!length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == 'length' || isIndex(key, length)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = isKey(path, object) ? [path] : castPath(path);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return index && index == length ? object : undefined;\n}\n\n/**\n * The base implementation of `getTag`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  return objectToString.call(value);\n}\n\n/**\n * The base implementation of `_.hasIn` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHasIn(object, key) {\n  return object != null && key in Object(object);\n}\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {boolean} [bitmask] The bitmask of comparison flags.\n *  The bitmask may be composed of the following flags:\n *     1 - Unordered comparison\n *     2 - Partial comparison\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, customizer, bitmask, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || !isObject(value) && !isObjectLike(other)) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);\n}\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`\n *  for more details.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = arrayTag,\n      othTag = arrayTag;\n\n  if (!objIsArr) {\n    objTag = getTag(object);\n    objTag = objTag == argsTag ? objectTag : objTag;\n  }\n  if (!othIsArr) {\n    othTag = getTag(other);\n    othTag = othTag == argsTag ? objectTag : othTag;\n  }\n  var objIsObj = objTag == objectTag && !isHostObject(object),\n      othIsObj = othTag == objectTag && !isHostObject(other),\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack());\n    return objIsArr || isTypedArray(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);\n  }\n  if (!(bitmask & PARTIAL_COMPARE_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack());\n      return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack());\n  return equalObjects(object, other, equalFunc, customizer, bitmask, stack);\n}\n\n/**\n * The base implementation of `_.isMatch` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property values to match.\n * @param {Array} matchData The property names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */\nfunction baseIsMatch(object, source, matchData, customizer) {\n  var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer;\n\n  if (object == null) {\n    return !length;\n  }\n  object = Object(object);\n  while (index--) {\n    var data = matchData[index];\n    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0],\n        objValue = object[key],\n        srcValue = data[1];\n\n    if (noCustomizer && data[2]) {\n      if (objValue === undefined && !(key in object)) {\n        return false;\n      }\n    } else {\n      var stack = new Stack();\n      if (customizer) {\n        var result = customizer(objValue, srcValue, key, object, source, stack);\n      }\n      if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];\n}\n\n/**\n * The base implementation of `_.iteratee`.\n *\n * @private\n * @param {*} [value=_.identity] The value to convert to an iteratee.\n * @returns {Function} Returns the iteratee.\n */\nfunction baseIteratee(value) {\n  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n  if (typeof value == 'function') {\n    return value;\n  }\n  if (value == null) {\n    return identity;\n  }\n  if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object') {\n    return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);\n  }\n  return property(value);\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.matches` which doesn't clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatches(source) {\n  var matchData = getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n  }\n  return function (object) {\n    return object === source || baseIsMatch(object, source, matchData);\n  };\n}\n\n/**\n * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatchesProperty(path, srcValue) {\n  if (isKey(path) && isStrictComparable(srcValue)) {\n    return matchesStrictComparable(toKey(path), srcValue);\n  }\n  return function (object) {\n    var objValue = get(object, path);\n    return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);\n  };\n}\n\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyDeep(path) {\n  return function (object) {\n    return baseGet(object, path);\n  };\n}\n\n/**\n * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`\n * which invokes `iteratee` for `value` and each element of `array` to compute\n * their sort ranking. The iteratee is invoked with one argument; (value).\n *\n * @private\n * @param {Array} array The sorted array to inspect.\n * @param {*} value The value to evaluate.\n * @param {Function} iteratee The iteratee invoked per element.\n * @param {boolean} [retHighest] Specify returning the highest qualified index.\n * @returns {number} Returns the index at which `value` should be inserted\n *  into `array`.\n */\nfunction baseSortedIndexBy(array, value, iteratee, retHighest) {\n  value = iteratee(value);\n\n  var low = 0,\n      high = array ? array.length : 0,\n      valIsNaN = value !== value,\n      valIsNull = value === null,\n      valIsSymbol = isSymbol(value),\n      valIsUndefined = value === undefined;\n\n  while (low < high) {\n    var mid = nativeFloor((low + high) / 2),\n        computed = iteratee(array[mid]),\n        othIsDefined = computed !== undefined,\n        othIsNull = computed === null,\n        othIsReflexive = computed === computed,\n        othIsSymbol = isSymbol(computed);\n\n    if (valIsNaN) {\n      var setLow = retHighest || othIsReflexive;\n    } else if (valIsUndefined) {\n      setLow = othIsReflexive && (retHighest || othIsDefined);\n    } else if (valIsNull) {\n      setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);\n    } else if (valIsSymbol) {\n      setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);\n    } else if (othIsNull || othIsSymbol) {\n      setLow = false;\n    } else {\n      setLow = retHighest ? computed <= value : computed < value;\n    }\n    if (setLow) {\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n  return nativeMin(high, MAX_ARRAY_INDEX);\n}\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = value + '';\n  return result == '0' && 1 / value == -INFINITY ? '-0' : result;\n}\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value) {\n  return isArray(value) ? value : stringToPath(value);\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} customizer The function to customize comparisons.\n * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`\n *  for more details.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, equalFunc, customizer, bitmask, stack) {\n  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function (othValue, othIndex) {\n        if (!seen.has(othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {\n          return seen.add(othIndex);\n        }\n      })) {\n        result = false;\n        break;\n      }\n    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} customizer The function to customize comparisons.\n * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`\n *  for more details.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == other + '';\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & PARTIAL_COMPARE_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= UNORDERED_COMPARE_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} customizer The function to customize comparisons.\n * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`\n *  for more details.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, equalFunc, customizer, bitmask, stack) {\n  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,\n      objProps = keys(object),\n      objLength = objProps.length,\n      othProps = keys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;\n}\n\n/**\n * Gets the property names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */\nfunction getMatchData(object) {\n  var result = keys(object),\n      length = result.length;\n\n  while (length--) {\n    var key = result[length],\n        value = object[key];\n\n    result[length] = [key, value, isStrictComparable(value)];\n  }\n  return result;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11,\n// for data views in Edge < 14, and promises in Node.js.\nif (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {\n  getTag = function getTag(value) {\n    var result = objectToString.call(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : undefined;\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString:\n          return dataViewTag;\n        case mapCtorString:\n          return mapTag;\n        case promiseCtorString:\n          return promiseTag;\n        case setCtorString:\n          return setTag;\n        case weakMapCtorString:\n          return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Checks if `path` exists on `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @param {Function} hasFunc The function to check properties.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n */\nfunction hasPath(object, path, hasFunc) {\n  path = isKey(path, object) ? [path] : castPath(path);\n\n  var result,\n      index = -1,\n      length = path.length;\n\n  while (++index < length) {\n    var key = toKey(path[index]);\n    if (!(result = object != null && hasFunc(object, key))) {\n      break;\n    }\n    object = object[key];\n  }\n  if (result) {\n    return result;\n  }\n  var length = object ? object.length : 0;\n  return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;\n}\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);\n  if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);\n  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && maskSrcKey in func;\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */\nfunction isStrictComparable(value) {\n  return value === value && !isObject(value);\n}\n\n/**\n * A specialized version of `matchesProperty` for source values suitable\n * for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction matchesStrictComparable(key, srcValue) {\n  return function (object) {\n    if (object == null) {\n      return false;\n    }\n    return object[key] === srcValue && (srcValue !== undefined || key in Object(object));\n  };\n}\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoize(function (string) {\n  string = toString(string);\n\n  var result = [];\n  if (reLeadingDot.test(string)) {\n    result.push('');\n  }\n  string.replace(rePropName, function (match, number, quote, string) {\n    result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);\n  });\n  return result;\n});\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = value + '';\n  return result == '0' && 1 / value == -INFINITY ? '-0' : result;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return func + '';\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * This method is like `_.sortedIndex` except that it accepts `iteratee`\n * which is invoked for `value` and each element of `array` to compute their\n * sort ranking. The iteratee is invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {Array} array The sorted array to inspect.\n * @param {*} value The value to evaluate.\n * @param {Function} [iteratee=_.identity]\n *  The iteratee invoked per element.\n * @returns {number} Returns the index at which `value` should be inserted\n *  into `array`.\n * @example\n *\n * var objects = [{ 'x': 4 }, { 'x': 5 }];\n *\n * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });\n * // => 0\n *\n * // The `_.property` iteratee shorthand.\n * _.sortedIndexBy(objects, { 'x': 4 }, 'x');\n * // => 0\n */\nfunction sortedIndexBy(array, value, iteratee) {\n  return baseSortedIndexBy(array, value, baseIteratee(iteratee, 2));\n}\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || resolver && typeof resolver != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function memoized() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result);\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache)();\n  return memoized;\n}\n\n// Assign cache to `_.memoize`.\nmemoize.Cache = MapCache;\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || value !== value && other !== other;\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nfunction isArguments(value) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') && (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;\n}\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\n/**\n * Checks if `path` is a direct or inherited property of `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.hasIn(object, 'a');\n * // => true\n *\n * _.hasIn(object, 'a.b');\n * // => true\n *\n * _.hasIn(object, ['a', 'b']);\n * // => true\n *\n * _.hasIn(object, 'b');\n * // => false\n */\nfunction hasIn(object, path) {\n  return object != null && hasPath(object, path, baseHasIn);\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\n/**\n * Creates a function that returns the value at `path` of a given object.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': 2 } },\n *   { 'a': { 'b': 1 } }\n * ];\n *\n * _.map(objects, _.property('a.b'));\n * // => [2, 1]\n *\n * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n * // => [1, 2]\n */\nfunction property(path) {\n  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n}\n\nmodule.exports = sortedIndexBy;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5), __webpack_require__(9)(module)))\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function (module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function () {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function get() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function get() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _rekapi = __webpack_require__(0);\n\nObject.defineProperty(exports, 'Rekapi', {\n  enumerable: true,\n  get: function get() {\n    return _rekapi.Rekapi;\n  }\n});\n\nvar _actor = __webpack_require__(3);\n\nObject.defineProperty(exports, 'Actor', {\n  enumerable: true,\n  get: function get() {\n    return _actor.Actor;\n  }\n});\n\nvar _keyframeProperty = __webpack_require__(4);\n\nObject.defineProperty(exports, 'KeyframeProperty', {\n  enumerable: true,\n  get: function get() {\n    return _keyframeProperty.KeyframeProperty;\n  }\n});\n\nvar _canvas = __webpack_require__(6);\n\nObject.defineProperty(exports, 'CanvasRenderer', {\n  enumerable: true,\n  get: function get() {\n    return _canvas.CanvasRenderer;\n  }\n});\n\nvar _dom = __webpack_require__(7);\n\nObject.defineProperty(exports, 'DOMRenderer', {\n  enumerable: true,\n  get: function get() {\n    return _dom.DOMRenderer;\n  }\n});\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// rekapi.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/assets/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 10);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap c902aadf42148c491eea","import { Tweenable, setBezierFunction } from 'shifty';\nimport { Actor } from './actor';\n\nimport {\n  each,\n  pick,\n  without\n} from './utils';\n\nconst UPDATE_TIME = 1000 / 60;\n\nexport const DEFAULT_EASING = 'linear';\n\n/*!\n * Fire an event bound to a Rekapi.\n * @param {Rekapi} rekapi\n * @param {string} eventName\n * @param {Object} [data={}] Optional event-specific data\n */\nexport const fireEvent = (rekapi, eventName, data = {}) =>\n  rekapi._events[eventName].forEach(handler => handler(rekapi, data));\n\n/*!\n * @param {Rekapi} rekapi\n */\nexport const invalidateAnimationLength = rekapi =>\n  rekapi._animationLengthValid = false;\n\n/*!\n * Determines which iteration of the loop the animation is currently in.\n * @param {Rekapi} rekapi\n * @param {number} timeSinceStart\n */\nexport const determineCurrentLoopIteration = (rekapi, timeSinceStart) => {\n  const animationLength = rekapi.getAnimationLength();\n\n  if (animationLength === 0) {\n    return timeSinceStart;\n  }\n\n  return Math.floor(timeSinceStart / animationLength);\n};\n\n/*!\n * Calculate how many milliseconds since the animation began.\n * @param {Rekapi} rekapi\n * @return {number}\n */\nexport const calculateTimeSinceStart = rekapi =>\n  Tweenable.now() - rekapi._loopTimestamp;\n\n/*!\n * Determines if the animation is complete or not.\n * @param {Rekapi} rekapi\n * @param {number} currentLoopIteration\n * @return {boolean}\n */\nexport const isAnimationComplete = (rekapi, currentLoopIteration) =>\n  currentLoopIteration >= rekapi._timesToIterate\n    && rekapi._timesToIterate !== -1;\n\n/*!\n * Stops the animation if it is complete.\n * @param {Rekapi} rekapi\n * @param {number} currentLoopIteration\n * @fires rekapi.animationComplete\n */\nexport const updatePlayState = (rekapi, currentLoopIteration) => {\n  if (isAnimationComplete(rekapi, currentLoopIteration)) {\n    rekapi.stop();\n    fireEvent(rekapi, 'animationComplete');\n  }\n};\n\n/*!\n * Calculate how far in the animation loop `rekapi` is, in milliseconds,\n * based on the current time.  Also overflows into a new loop if necessary.\n * @param {Rekapi} rekapi\n * @param {number} forMillisecond\n * @param {number} currentLoopIteration\n * @return {number}\n */\nexport const calculateLoopPosition = (rekapi, forMillisecond, currentLoopIteration) => {\n  const animationLength = rekapi.getAnimationLength();\n\n  return animationLength === 0 ?\n    0 :\n    isAnimationComplete(rekapi, currentLoopIteration) ?\n      animationLength :\n      forMillisecond % animationLength;\n};\n\n/*!\n * Calculate the timeline position and state for a given millisecond.\n * Updates the `rekapi` state internally and accounts for how many loop\n * iterations the animation runs for.\n * @param {Rekapi} rekapi\n * @param {number} forMillisecond\n * @fires rekapi.animationLooped\n */\nexport const updateToMillisecond = (rekapi, forMillisecond) => {\n  const currentIteration = determineCurrentLoopIteration(rekapi, forMillisecond);\n  const loopPosition = calculateLoopPosition(\n    rekapi, forMillisecond, currentIteration\n  );\n\n  rekapi._loopPosition = loopPosition;\n\n  const keyframeResetList = [];\n\n  if (currentIteration > rekapi._latestIteration) {\n    fireEvent(rekapi, 'animationLooped');\n\n    rekapi._actors.forEach(actor => {\n\n      const { _keyframeProperties } = actor;\n      const fnKeyframes = Object.keys(_keyframeProperties).reduce(\n        (acc, propertyId) => {\n          const property = _keyframeProperties[propertyId];\n\n          if (property.name === 'function') {\n            acc.push(property);\n          }\n\n          return acc;\n        },\n        []\n      );\n\n      const lastFnKeyframe = fnKeyframes[fnKeyframes.length - 1];\n\n      if (lastFnKeyframe && !lastFnKeyframe.hasFired) {\n        lastFnKeyframe.invoke();\n      }\n\n      keyframeResetList.push(...fnKeyframes);\n    });\n  }\n\n  rekapi._latestIteration = currentIteration;\n  rekapi.update(loopPosition, true);\n  updatePlayState(rekapi, currentIteration);\n\n  keyframeResetList.forEach(fnKeyframe => {\n    fnKeyframe.hasFired = false;\n  });\n};\n\n/*!\n * Calculate how far into the animation loop `rekapi` is, in milliseconds,\n * and update based on that time.\n * @param {Rekapi} rekapi\n */\nexport const updateToCurrentMillisecond = rekapi =>\n  updateToMillisecond(rekapi, calculateTimeSinceStart(rekapi));\n\n/*!\n * This is the heartbeat of an animation.  This updates `rekapi`'s state and\n * then calls itself continuously.\n * @param {Rekapi} rekapi\n */\nconst tick = rekapi =>\n  // Need to check for .call presence to get around an IE limitation.  See\n  // annotation for cancelLoop for more info.\n  rekapi._loopId = rekapi._scheduleUpdate.call ?\n    rekapi._scheduleUpdate.call(global, rekapi._updateFn, UPDATE_TIME) :\n    setTimeout(rekapi._updateFn, UPDATE_TIME);\n\n/*!\n * @return {Function}\n */\nconst getUpdateMethod = () =>\n  // requestAnimationFrame() shim by Paul Irish (modified for Rekapi)\n  // http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n  global.requestAnimationFrame       ||\n  global.webkitRequestAnimationFrame ||\n  global.oRequestAnimationFrame      ||\n  global.msRequestAnimationFrame     ||\n  (global.mozCancelRequestAnimationFrame && global.mozRequestAnimationFrame) ||\n  global.setTimeout;\n\n/*!\n * @return {Function}\n */\nconst getCancelMethod = () =>\n  global.cancelAnimationFrame           ||\n  global.webkitCancelAnimationFrame     ||\n  global.oCancelAnimationFrame          ||\n  global.msCancelAnimationFrame         ||\n  global.mozCancelRequestAnimationFrame ||\n  global.clearTimeout;\n\n/*!\n * Cancels an update loop.  This abstraction is needed to get around the fact\n * that in IE, clearTimeout is not technically a function\n * (https://twitter.com/kitcambridge/status/206655060342603777) and thus\n * Function.prototype.call cannot be used upon it.\n * @param {Rekapi} rekapi\n */\nconst cancelLoop = rekapi =>\n  rekapi._cancelUpdate.call ?\n    rekapi._cancelUpdate.call(global, rekapi._loopId) :\n    clearTimeout(rekapi._loopId);\n\nconst STOPPED = 'stopped';\nconst PAUSED = 'paused';\nconst PLAYING = 'playing';\n\n/*!\n * @type {Object.<function>} Contains the context init function to be called in\n * the Rekapi constructor.  This array is populated by modules in the\n * renderers/ directory.\n */\nexport const rendererBootstrappers = [];\n\n/**\n * If this is a rendered animation, the appropriate renderer is accessible as\n * `this.renderer`.  If provided, a reference to `context` is accessible\n * as `this.context`.\n * @param {(Object|CanvasRenderingContext2D|HTMLElement)} [context={}] Sets\n * {@link rekapi.Rekapi#context}. This determines how to render the animation.\n * {@link rekapi.Rekapi} will also automatically set up all necessary {@link\n * rekapi.Rekapi#renderers} based on this value:\n *\n * * If this is not provided or is a plain object (`{}`), the animation will\n * not render anything and {@link rekapi.Rekapi#renderers} will be empty.\n * * If this is a\n * [`CanvasRenderingContext2D`](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D),\n * {@link rekapi.Rekapi#renderers} will contain a {@link\n * rekapi.CanvasRenderer}.\n * * If this is a DOM element, {@link rekapi.Rekapi#renderers} will contain a\n * {@link rekapi.DOMRenderer}.\n * @constructs rekapi.Rekapi\n */\nexport class Rekapi {\n  constructor (context = {}) {\n    /**\n     * @member {(Object|CanvasRenderingContext2D|HTMLElement)}\n     * rekapi.Rekapi#context The rendering context for an animation.\n     * @default {}\n     */\n    this.context = context;\n    this._actors = [];\n    this._playState = STOPPED;\n\n    /**\n     * @member {(rekapi.actorSortFunction|null)} rekapi.Rekapi#sort Optional\n     * function for sorting the render order of {@link rekapi.Actor}s.  If set,\n     * this is called each frame before the {@link rekapi.Actor}s are rendered.\n     * If not set, {@link rekapi.Actor}s will render in the order they were\n     * added via {@link rekapi.Rekapi#addActor}.\n     *\n     * The following example assumes that all {@link rekapi.Actor}s are circles\n     * that have a `radius` {@link rekapi.KeyframeProperty}.  The circles will\n     * be rendered in order of the value of their `radius`, from smallest to\n     * largest.  This has the effect of layering larger circles on top of\n     * smaller circles, thus giving a sense of perspective.\n     *\n     *     const rekapi = new Rekapi();\n     *     rekapi.sort = actor => actor.get().radius;\n     * @default null\n     */\n    this.sort = null;\n\n    this._events = {\n      animationComplete: [],\n      playStateChange: [],\n      play: [],\n      pause: [],\n      stop: [],\n      beforeUpdate: [],\n      afterUpdate: [],\n      addActor: [],\n      removeActor: [],\n      beforeAddKeyframeProperty: [],\n      addKeyframeProperty: [],\n      removeKeyframeProperty: [],\n      removeKeyframePropertyComplete: [],\n      beforeRemoveKeyframeProperty: [],\n      addKeyframePropertyTrack: [],\n      removeKeyframePropertyTrack: [],\n      timelineModified: [],\n      animationLooped: []\n    };\n\n    // How many times to loop the animation before stopping\n    this._timesToIterate = -1;\n\n    // Millisecond duration of the animation\n    this._animationLength = 0;\n    this._animationLengthValid = false;\n\n    // The setTimeout ID of `tick`\n    this._loopId = null;\n\n    // The UNIX time at which the animation loop started\n    this._loopTimestamp = null;\n\n    // Used for maintaining position when the animation is paused\n    this._pausedAtTime = null;\n\n    // The last millisecond position that was updated\n    this._lastUpdatedMillisecond = 0;\n\n    // The most recent loop iteration a frame was calculated for\n    this._latestIteration = 0;\n\n    // The most recent millisecond position within the loop that the animation\n    // was updated to\n    this._loopPosition = null;\n\n    this._scheduleUpdate = getUpdateMethod();\n    this._cancelUpdate = getCancelMethod();\n\n    this._updateFn = () => {\n      tick(this);\n      updateToCurrentMillisecond(this);\n    };\n\n    /**\n     * @member {Array.<rekapi.renderer>} rekapi.Rekapi#renderers Instances of\n     * {@link rekapi.renderer} classes, as inferred by the `context`\n     * parameter provided to the {@link rekapi.Rekapi} constructor.  You can\n     * add more renderers to this list manually; see the {@tutorial\n     * multiple-renderers} tutorial for an example.\n     */\n    this.renderers = rendererBootstrappers\n      .map(renderer => renderer(this))\n      .filter(_ => _);\n  }\n\n  /**\n   * Add a {@link rekapi.Actor} to the animation.  Decorates the added {@link\n   * rekapi.Actor} with a reference to this {@link rekapi.Rekapi} instance as\n   * {@link rekapi.Actor#rekapi}.\n   *\n   * @method rekapi.Rekapi#addActor\n   * @param {(rekapi.Actor|Object)} [actor={}] If this is an `Object`, it is used to as\n   * the constructor parameters for a new {@link rekapi.Actor} instance that\n   * is created by this method.\n   * @return {rekapi.Actor} The {@link rekapi.Actor} that was added.\n   * @fires rekapi.addActor\n   */\n  addActor (actor = {}) {\n    const rekapiActor = actor instanceof Actor ?\n      actor :\n      new Actor(actor);\n\n    // You can't add an actor more than once.\n    if (~this._actors.indexOf(rekapiActor)) {\n      return rekapiActor;\n    }\n\n    rekapiActor.context = rekapiActor.context || this.context;\n    rekapiActor.rekapi = this;\n\n    // Store a reference to the actor internally\n    this._actors.push(rekapiActor);\n\n    invalidateAnimationLength(this);\n    rekapiActor.setup();\n\n    fireEvent(this, 'addActor', rekapiActor);\n\n    return rekapiActor;\n  }\n\n  /**\n   * @method rekapi.Rekapi#getActor\n   * @param {number} actorId\n   * @return {rekapi.Actor} A reference to an actor from the animation by its\n   * `id`.  You can use {@link rekapi.Rekapi#getActorIds} to get a list of IDs\n   * for all actors in the animation.\n   */\n  getActor (actorId) {\n    return this._actors.filter(actor => actor.id === actorId)[0];\n  }\n\n  /**\n   * @method rekapi.Rekapi#getActorIds\n   * @return {Array.<number>} The `id`s of all {@link rekapi.Actor}`s in the\n   * animation.\n   */\n  getActorIds () {\n    return this._actors.map(actor => actor.id);\n  }\n\n  /**\n   * @method rekapi.Rekapi#getAllActors\n   * @return {Array.<rekapi.Actor>} All {@link rekapi.Actor}s in the animation.\n   */\n  getAllActors () {\n    return this._actors.slice();\n  }\n\n  /**\n   * @method rekapi.Rekapi#getActorCount\n   * @return {number} The number of {@link rekapi.Actor}s in the animation.\n   */\n  getActorCount () {\n    return this._actors.length;\n  }\n\n  /**\n   * Remove an actor from the animation.  This does not destroy the actor, it\n   * only removes the link between it and this {@link rekapi.Rekapi} instance.\n   * This method calls the actor's {@link rekapi.Actor#teardown} method, if\n   * defined.\n   * @method rekapi.Rekapi#removeActor\n   * @param {rekapi.Actor} actor\n   * @return {rekapi.Actor} The {@link rekapi.Actor} that was removed.\n   * @fires rekapi.removeActor\n   */\n  removeActor (actor) {\n    // Remove the link between Rekapi and actor\n    this._actors = without(this._actors, actor);\n    delete actor.rekapi;\n\n    actor.teardown();\n    invalidateAnimationLength(this);\n\n    fireEvent(this, 'removeActor', actor);\n\n    return actor;\n  }\n\n  /**\n   * Remove all {@link rekapi.Actor}s from the animation.\n   * @method rekapi.Rekapi#removeAllActors\n   * @return {Array.<rekapi.Actor>} The {@link rekapi.Actor}s that were\n   * removed.\n   */\n  removeAllActors () {\n    return this.getAllActors().map(actor => this.removeActor(actor));\n  }\n\n  /**\n   * Play the animation.\n   *\n   * @method rekapi.Rekapi#play\n   * @param {number} [iterations=-1] If omitted, the animation will loop\n   * endlessly.\n   * @return {rekapi.Rekapi}\n   * @fires rekapi.playStateChange\n   * @fires rekapi.play\n   */\n  play (iterations = -1) {\n    cancelLoop(this);\n\n    if (this._playState === PAUSED) {\n      // Move the playhead to the correct position in the timeline if resuming\n      // from a pause\n      this._loopTimestamp += Tweenable.now() - this._pausedAtTime;\n    } else {\n      this._loopTimestamp = Tweenable.now();\n    }\n\n    this._timesToIterate = iterations;\n    this._playState = PLAYING;\n\n    // Start the update loop\n    tick(this);\n\n    fireEvent(this, 'playStateChange');\n    fireEvent(this, 'play');\n\n    return this;\n  }\n\n  /**\n   * Move to a specific millisecond on the timeline and play from there.\n   *\n   * @method rekapi.Rekapi#playFrom\n   * @param {number} millisecond\n   * @param {number} [iterations] Works as it does in {@link\n   * rekapi.Rekapi#play}.\n   * @return {rekapi.Rekapi}\n   */\n  playFrom (millisecond, iterations) {\n    this.play(iterations);\n    this._loopTimestamp = Tweenable.now() - millisecond;\n\n    this._actors.forEach(\n      actor => actor._resetFnKeyframesFromMillisecond(millisecond)\n    );\n\n    return this;\n  }\n\n  /**\n   * Play from the last frame that was rendered with {@link\n   * rekapi.Rekapi#update}.\n   *\n   * @method rekapi.Rekapi#playFromCurrent\n   * @param {number} [iterations] Works as it does in {@link\n   * rekapi.Rekapi#play}.\n   * @return {rekapi.Rekapi}\n   */\n  playFromCurrent (iterations) {\n    return this.playFrom(this._lastUpdatedMillisecond, iterations);\n  }\n\n  /**\n   * Pause the animation.  A \"paused\" animation can be resumed from where it\n   * left off with {@link rekapi.Rekapi#play}.\n   *\n   * @method rekapi.Rekapi#pause\n   * @return {rekapi.Rekapi}\n   * @fires rekapi.playStateChange\n   * @fires rekapi.pause\n   */\n  pause () {\n    if (this._playState === PAUSED) {\n      return this;\n    }\n\n    this._playState = PAUSED;\n    cancelLoop(this);\n    this._pausedAtTime = Tweenable.now();\n\n    fireEvent(this, 'playStateChange');\n    fireEvent(this, 'pause');\n\n    return this;\n  }\n\n  /**\n   * Stop the animation.  A \"stopped\" animation will start from the beginning\n   * if {@link rekapi.Rekapi#play} is called.\n   *\n   * @method rekapi.Rekapi#stop\n   * @return {rekapi.Rekapi}\n   * @fires rekapi.playStateChange\n   * @fires rekapi.stop\n   */\n  stop () {\n    this._playState = STOPPED;\n    cancelLoop(this);\n\n    // Also kill any shifty tweens that are running.\n    this._actors.forEach(actor =>\n      actor._resetFnKeyframesFromMillisecond(0)\n    );\n\n    fireEvent(this, 'playStateChange');\n    fireEvent(this, 'stop');\n\n    return this;\n  }\n\n  /**\n   * @method rekapi.Rekapi#isPlaying\n   * @return {boolean} Whether or not the animation is playing (meaning not paused or\n   * stopped).\n   */\n  isPlaying () {\n    return this._playState === PLAYING;\n  }\n\n  /**\n   * @method rekapi.Rekapi#isPaused\n   * @return {boolean} Whether or not the animation is paused (meaning not playing or\n   * stopped).\n   */\n  isPaused () {\n    return this._playState === PAUSED;\n  }\n\n  /**\n   * @method rekapi.Rekapi#isStopped\n   * @return {boolean} Whether or not the animation is stopped (meaning not playing or\n   * paused).\n   */\n  isStopped () {\n    return this._playState === STOPPED;\n  }\n\n  /**\n   * Render an animation frame at a specific point in the timeline.\n   *\n   * @method rekapi.Rekapi#update\n   * @param {number} [millisecond=this._lastUpdatedMillisecond] The point in\n   * the timeline at which to render.  If omitted, this renders the last\n   * millisecond that was rendered (it's a re-render).\n   * @param {boolean} [doResetLaterFnKeyframes=false] If `true`, allow all\n   * {@link rekapi.keyframeFunction}s later in the timeline to be run again.\n   * This is a low-level feature, it should not be `true` (or even provided)\n   * for most use cases.\n   * @return {rekapi.Rekapi}\n   * @fires rekapi.beforeUpdate\n   * @fires rekapi.afterUpdate\n   */\n  update (\n    millisecond = this._lastUpdatedMillisecond,\n    doResetLaterFnKeyframes = false\n  ) {\n    fireEvent(this, 'beforeUpdate');\n\n    const { sort } = this;\n\n    const renderOrder = sort ?\n      this._actors.sort((a, b) => sort(a) - sort(b)) :\n      this._actors;\n\n    // Update and render each of the actors\n    renderOrder.forEach(actor => {\n      actor._updateState(millisecond, doResetLaterFnKeyframes);\n\n      if (actor.wasActive) {\n        actor.render(actor.context, actor.get());\n      }\n    });\n\n    this._lastUpdatedMillisecond = millisecond;\n    fireEvent(this, 'afterUpdate');\n\n    return this;\n  }\n\n  /**\n   * @method rekapi.Rekapi#getLastPositionUpdated\n   * @return {number} The normalized timeline position (between 0 and 1) that\n   * was last rendered.\n   */\n  getLastPositionUpdated () {\n    return (this._lastUpdatedMillisecond / this.getAnimationLength());\n  }\n\n  /**\n   * @method rekapi.Rekapi#getLastMillisecondUpdated\n   * @return {number} The millisecond that was last rendered.\n   */\n  getLastMillisecondUpdated () {\n    return this._lastUpdatedMillisecond;\n  }\n\n  /**\n   * @method rekapi.Rekapi#getAnimationLength\n   * @return {number} The length of the animation timeline, in milliseconds.\n   */\n  getAnimationLength () {\n    if (!this._animationLengthValid) {\n      this._animationLength = Math.max.apply(\n        Math,\n        this._actors.map(actor => actor.getEnd())\n      );\n\n      this._animationLengthValid = true;\n    }\n\n    return this._animationLength;\n  }\n\n  /**\n   * Bind a {@link rekapi.eventHandler} function to a Rekapi event.\n   * @method rekapi.Rekapi#on\n   * @param {string} eventName\n   * @param {rekapi.eventHandler} handler The event handler function.\n   * @return {rekapi.Rekapi}\n   */\n  on (eventName, handler) {\n    if (!this._events[eventName]) {\n      return this;\n    }\n\n    this._events[eventName].push(handler);\n\n    return this;\n  }\n\n  /**\n   * Manually fire a Rekapi event, thereby calling all {@link\n   * rekapi.eventHandler}s bound to that event.\n   * @param {string} eventName The name of the event to trigger.\n   * @param {any} [data] Optional data to provide to the `eventName` {@link\n   * rekapi.eventHandler}s.\n   * @method rekapi.Rekapi#trigger\n   * @return {rekapi.Rekapi}\n   * @fires *\n   */\n  trigger (eventName, data) {\n    fireEvent(this, eventName, data);\n\n    return this;\n  }\n\n  /**\n   * Unbind one or more handlers from a Rekapi event.\n   * @method rekapi.Rekapi#off\n   * @param {string} eventName Valid values correspond to the list under\n   * {@link rekapi.Rekapi#on}.\n   * @param {rekapi.eventHandler} [handler] A reference to the {@link\n   * rekapi.eventHandler} to unbind.  If omitted, all {@link\n   * rekapi.eventHandler}s bound to `eventName` are unbound.\n   * @return {rekapi.Rekapi}\n   */\n  off (eventName, handler) {\n    if (!this._events[eventName]) {\n      return this;\n    }\n\n    this._events[eventName] = handler ?\n      without(this._events[eventName], handler) :\n      [];\n\n    return this;\n  }\n\n  /**\n   * Export the timeline to a `JSON.stringify`-friendly `Object`.\n   *\n   * @method rekapi.Rekapi#exportTimeline\n   * @param {Object} [config]\n   * @param {boolean} [config.withId=false] If `true`, include internal `id`\n   * values in exported data.\n   * @return {rekapi.timelineData} This data can later be consumed by {@link\n   * rekapi.Rekapi#importTimeline}.\n   */\n  exportTimeline ({ withId = false } = {}) {\n    const exportData = {\n      duration: this.getAnimationLength(),\n      actors: this._actors.map(actor => actor.exportTimeline({ withId }))\n    };\n\n    const { formulas } = Tweenable;\n\n    const filteredFormulas = Object.keys(formulas).filter(\n      formulaName => typeof formulas[formulaName].x1 === 'number'\n    );\n\n    const pickProps = ['displayName', 'x1', 'y1', 'x2', 'y2'];\n\n    exportData.curves = filteredFormulas.reduce((acc, formulaName) => {\n        const formula = formulas[formulaName];\n        acc[formula.displayName] = pick(formula, pickProps);\n\n        return acc;\n      },\n      {}\n    );\n\n    return exportData;\n  }\n\n  /**\n   * Import data that was created by {@link rekapi.Rekapi#exportTimeline}.\n   * This sets up all actors, keyframes, and custom easing curves specified in\n   * the `rekapiData` parameter.  These two methods collectively allow you\n   * serialize an animation (for sending to a server for persistence, for\n   * example) and later recreating an identical animation.\n   *\n   * @method rekapi.Rekapi#importTimeline\n   * @param {rekapi.timelineData} rekapiData Any object that has the same data\n   * format as the object generated from {@link rekapi.Rekapi#exportTimeline}.\n   */\n  importTimeline (rekapiData) {\n    each(rekapiData.curves, (curve, curveName) =>\n      setBezierFunction(\n        curveName,\n        curve.x1,\n        curve.y1,\n        curve.x2,\n        curve.y2\n      )\n    );\n\n    rekapiData.actors.forEach(actorData => {\n      const actor = new Actor();\n      actor.importTimeline(actorData);\n      this.addActor(actor);\n    });\n  }\n\n  /**\n   * @method rekapi.Rekapi#getEventNames\n   * @return {Array.<string>} The list of event names that this Rekapi instance\n   * supports.\n   */\n  getEventNames () {\n    return Object.keys(this._events);\n  }\n\n  /**\n   * Get a reference to a {@link rekapi.renderer} that was initialized for this\n   * animation.\n   * @method rekapi.Rekapi#getRendererInstance\n   * @param {rekapi.renderer} rendererConstructor The type of {@link\n   * rekapi.renderer} subclass (such as {@link rekapi.CanvasRenderer} or {@link\n   * rekapi.DOMRenderer}) to look up an instance of.\n   * @return {rekapi.renderer|undefined} The matching {@link rekapi.renderer},\n   * if any.\n   */\n  getRendererInstance (rendererConstructor) {\n    return this.renderers.filter(renderer =>\n      renderer instanceof rendererConstructor\n    )[0];\n  }\n\n  /**\n   * Move a {@link rekapi.Actor} around within the internal render order list.\n   * By default, a {@link rekapi.Actor} is rendered in the order it was added\n   * with {@link rekapi.Rekapi#addActor}.\n   *\n   * This method has no effect if {@link rekapi.Rekapi#sort} is set.\n   *\n   * @method rekapi.Rekapi#moveActorToPosition\n   * @param {rekapi.Actor} actor\n   * @param {number} layer This should be within `0` and the total number of\n   * {@link rekapi.Actor}s in the animation.  That number can be found with\n   * {@link rekapi.Rekapi#getActorCount}.\n   * @return {rekapi.Rekapi}\n   */\n  moveActorToPosition (actor, position) {\n    if (position < this._actors.length && position > -1) {\n      this._actors = without(this._actors, actor);\n      this._actors.splice(position, 0, actor);\n    }\n\n    return this;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/rekapi.js","/**\n * @param {Object} obj\n * @return {Object}\n */\nexport const clone = obj => Object.assign({}, obj);\n\n/**\n * Simplified version of https://lodash.com/docs/4.17.4#difference\n * @param {Array.<any>} arr\n * @param {Array.<any>} values\n * @return {Array.<any>}\n */\nexport const difference = (arr, values) =>\n  arr.filter(value => !~values.indexOf(value));\n\n/**\n * Simplified version of https://lodash.com/docs/4.17.4#forEach, but only for\n * Objects.\n * @param {Object.<any>} obj\n * @param {Function(any)} fn\n */\nexport const each = (obj, fn) =>\n  Object.keys(obj).forEach(key => fn(obj[key], key));\n\n/*!\n * Simplified version of https://lodash.com/docs/4.17.4#intersection\n * @param {Array.<any>} arr1\n * @param {Array.<any>} arr2\n * @return {Array.<any>}\n */\nexport const intersection =\n  (arr1, arr2) => arr1.filter(el => ~arr2.indexOf(el));\n\n/**\n * Simplified version of https://lodash.com/docs/4.17.4#pick\n * @param {Object.<any>} obj\n * @param {Array.<string>} keyNames\n */\nexport const pick = (obj, keyNames) =>\n  keyNames.reduce(\n    (acc, keyName) => {\n      const val = obj[keyName];\n\n      if (typeof val !== 'undefined') {\n        acc[keyName] = val;\n      }\n\n      return acc;\n    },\n    {}\n  );\n\n/**\n * Simplified version of https://lodash.com/docs/4.17.4#reject\n * @param {Array.<any>} arr\n * @param {Function(any)} fn\n * @return {Array.<any>}\n */\nexport const reject = (arr, fn) => arr.filter(el => !fn(el));\n\n/**\n * Simplified version of https://lodash.com/docs/4.17.4#uniq\n * @param {Array.<any>} arr\n * @return {Array.<any>}\n */\nexport const uniq = arr =>\n  arr.reduce((acc, value) => {\n    if (!~acc.indexOf(value)) {\n      acc.push(value);\n    }\n\n    return acc;\n  }, []);\n\nlet incrementer = 0;\n/**\n * @param {string} [prefix]\n * @return {string}\n */\nexport const uniqueId = (prefix = '') => prefix + incrementer++;\n\n/**\n * Simplified version of https://lodash.com/docs/4.17.4#without\n * @param {Array.<any>} array\n * @param {...any} values\n * @return {Array.<any>}\n */\nexport const without = (array, ...values) =>\n  array.filter(value => !~values.indexOf(value));\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils.js","module.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"shifty\"\n// module id = 2\n// module chunks = 0","import { Tweenable } from 'shifty';\nimport { KeyframeProperty } from './keyframe-property';\nimport {\n  fireEvent,\n  invalidateAnimationLength,\n  DEFAULT_EASING\n} from './rekapi';\n\nimport {\n  clone,\n  each,\n  pick,\n  uniqueId\n} from './utils';\n\nimport sortedIndexBy from 'lodash.sortedindexby';\n\nconst noop = () => {};\n\n/*!\n * @param {Object} obj\n * @return {number} millisecond\n */\nconst getMillisecond = obj => obj.millisecond;\n\n// TODO: Make this a prototype method\n/*!\n * @param {Actor} actor\n * @param {string} event\n * @param {any} [data]\n */\nconst fire = (actor, event, data) =>\n  actor.rekapi && fireEvent(actor.rekapi, event, data);\n\n/*!\n * Retrieves the most recent property cache entry for a given millisecond.\n * @param {Actor} actor\n * @param {number} millisecond\n * @return {(Object|undefined)} undefined if there is no property cache for\n * the millisecond, i.e. an empty cache.\n */\nconst getPropertyCacheEntryForMillisecond = (actor, millisecond) => {\n  const { _timelinePropertyCache } = actor;\n  const index = sortedIndexBy(\n    _timelinePropertyCache,\n    { _millisecond: millisecond },\n    obj => obj._millisecond\n  );\n\n  if (!_timelinePropertyCache[index]) {\n    return;\n  }\n\n  return _timelinePropertyCache[index]._millisecond === millisecond ?\n    _timelinePropertyCache[index] :\n      index >= 1 ?\n        _timelinePropertyCache[index - 1] :\n        _timelinePropertyCache[0];\n};\n\n/*!\n * Search property track `track` and find the correct index to insert a\n * new element at `millisecond`.\n * @param {Array(KeyframeProperty)} track\n * @param {number} millisecond\n * @return {number} index\n */\nconst insertionPointInTrack = (track, millisecond) =>\n  sortedIndexBy(track, { millisecond }, getMillisecond);\n\n/*!\n * Gets all of the current and most recent Rekapi.KeyframeProperties for a\n * given millisecond.\n * @param {Actor} actor\n * @param {number} forMillisecond\n * @return {Object} An Object containing Rekapi.KeyframeProperties\n */\nconst getLatestProperties = (actor, forMillisecond) => {\n  const latestProperties = {};\n\n  each(actor._propertyTracks, (propertyTrack, propertyName) => {\n    const index = insertionPointInTrack(propertyTrack, forMillisecond);\n\n    latestProperties[propertyName] =\n      propertyTrack[index] && propertyTrack[index].millisecond === forMillisecond ?\n        // Found forMillisecond exactly.\n        propertyTrack[index] :\n          index >= 1 ?\n            // forMillisecond doesn't exist in the track and index is\n            // where we'd need to insert it, therefore the previous\n            // keyframe is the most recent one before forMillisecond.\n            propertyTrack[index - 1] :\n            // Return first property.  This is after forMillisecond.\n            propertyTrack[0];\n  });\n\n  return latestProperties;\n};\n\n/*!\n * Search property track `track` and find the index to the element that is\n * at `millisecond`.  Returns `undefined` if not found.\n * @param {Array(KeyframeProperty)} track\n * @param {number} millisecond\n * @return {number} index or -1 if not present\n */\nconst propertyIndexInTrack = (track, millisecond) => {\n  const index = insertionPointInTrack(track, millisecond);\n\n  return track[index] && track[index].millisecond === millisecond ?\n    index : -1;\n};\n\n/*!\n * Mark the cache of internal KeyframeProperty data as invalid.  The cache\n * will be rebuilt on the next call to ensurePropertyCacheValid.\n * @param {Actor}\n */\nconst invalidateCache = actor => actor._timelinePropertyCacheValid = false;\n\n/*!\n * Empty out and rebuild the cache of internal KeyframeProperty data if it\n * has been marked as invalid.\n * @param {Actor}\n */\nconst ensurePropertyCacheValid = actor => {\n  if (actor._timelinePropertyCacheValid) {\n    return;\n  }\n\n  actor._timelinePropertyCache = [];\n  actor._timelineFunctionCache = [];\n\n  const {\n    _keyframeProperties,\n    _timelineFunctionCache,\n    _timelinePropertyCache\n  } = actor;\n\n  // Build the cache map\n  const props = Object.keys(_keyframeProperties)\n    .map(key => _keyframeProperties[key])\n    .sort((a, b) => a.millisecond - b.millisecond);\n\n  let curCacheEntry = getLatestProperties(actor, 0);\n\n  curCacheEntry._millisecond = 0;\n  _timelinePropertyCache.push(curCacheEntry);\n\n  props.forEach(property => {\n    if (property.millisecond !== curCacheEntry._millisecond) {\n      curCacheEntry = clone(curCacheEntry);\n      curCacheEntry._millisecond = property.millisecond;\n      _timelinePropertyCache.push(curCacheEntry);\n    }\n\n    curCacheEntry[property.name] = property;\n\n    if (property.name === 'function') {\n      _timelineFunctionCache.push(property);\n    }\n  });\n\n  actor._timelinePropertyCacheValid = true;\n};\n\n/*!\n * Remove any property tracks that are empty.\n * @param {Actor} actor\n * @fires rekapi.removeKeyframePropertyTrack\n */\nconst removeEmptyPropertyTracks = actor => {\n  const { _propertyTracks } = actor;\n\n  Object.keys(_propertyTracks).forEach(trackName => {\n    if (!_propertyTracks[trackName].length) {\n      delete _propertyTracks[trackName];\n      fire(actor, 'removeKeyframePropertyTrack', trackName);\n    }\n  });\n};\n\n/*!\n * Stably sort all of the property tracks of an actor\n * @param {Actor} actor\n */\nconst sortPropertyTracks = actor => {\n  each(actor._propertyTracks, (propertyTrack, trackName) => {\n    propertyTrack = propertyTrack.sort(\n      (a, b) => a.millisecond - b.millisecond\n    );\n\n    propertyTrack.forEach((keyframeProperty, i) =>\n      keyframeProperty.linkToNext(propertyTrack[i + 1])\n    );\n\n    actor._propertyTracks[trackName] = propertyTrack;\n  });\n};\n\n/*!\n * Updates internal Rekapi and Actor data after a KeyframeProperty\n * modification method is called.\n *\n * @param {Actor} actor\n * @fires rekapi.timelineModified\n */\nconst cleanupAfterKeyframeModification = actor => {\n  sortPropertyTracks(actor);\n  invalidateCache(actor);\n\n  if (actor.rekapi) {\n    invalidateAnimationLength(actor.rekapi);\n  }\n\n  fire(actor, 'timelineModified');\n};\n\n/**\n * A {@link rekapi.Actor} represents an individual component of an animation.\n * An animation may have one or many {@link rekapi.Actor}s.\n *\n * @param {Object} [config={}]\n * @param {(Object|CanvasRenderingContext2D|HTMLElement)} [config.context] Sets\n * {@link rekapi.Actor#context}.\n * @param {Function} [config.setup] Sets {@link rekapi.Actor#setup}.\n * @param {rekapi.render} [config.render] Sets {@link rekapi.Actor#render}.\n * @param {Function} [config.teardown] Sets {@link rekapi.Actor#teardown}.\n * @constructs rekapi.Actor\n */\nexport class Actor extends Tweenable {\n  constructor (config = {}) {\n    super();\n\n    /**\n     * @member {rekapi.Rekapi|undefined} rekapi.Actor#rekapi The {@link\n     * rekapi.Rekapi} instance to which this {@link rekapi.Actor} belongs, if\n     * any.\n     */\n\n    Object.assign(this, {\n      _propertyTracks: {},\n      _timelinePropertyCache: [],\n      _timelineFunctionCache: [],\n      _timelinePropertyCacheValid: false,\n      _keyframeProperties: {},\n\n      /**\n       * @member {string} rekapi.Actor#id The unique ID of this {@link rekapi.Actor}.\n       */\n      id: uniqueId(),\n\n      /**\n        * @member {(Object|CanvasRenderingContext2D|HTMLElement|undefined)}\n        * [rekapi.Actor#context] If this {@link rekapi.Actor} was created by or\n        * provided as an argument to {@link rekapi.Rekapi#addActor}, then this\n        * member is a reference to that {@link rekapi.Rekapi}'s {@link\n        * rekapi.Rekapi#context}.\n        */\n      context: config.context,\n\n      /**\n       * @member {Function} rekapi.Actor#setup Gets called when an actor is\n       * added to an animation by {@link rekapi.Rekapi#addActor}.\n       */\n      setup: config.setup || noop,\n\n      /**\n       * @member {rekapi.render} rekapi.Actor#render The function that renders\n       * this {@link rekapi.Actor}.\n       */\n      render: config.render || noop,\n\n      /**\n       * @member {Function} rekapi.Actor#teardown Gets called when an actor is\n       * removed from an animation by {@link rekapi.Rekapi#removeActor}.\n       */\n      teardown: config.teardown || noop,\n\n      /**\n       * @member {boolean} rekapi.Actor#wasActive A flag that records whether\n       * this {@link rekapi.Actor} had any state in the previous updated cycle.\n       * Handy for immediate-mode renderers (such as {@link\n       * rekapi.CanvasRenderer}) to prevent unintended renders after the actor\n       * has no state. Also used to prevent redundant {@link\n       * rekapi.keyframeFunction} calls.\n       */\n      wasActive: true\n    });\n  }\n\n  /**\n   * Create a keyframe for the actor.  The animation timeline begins at `0`.\n   * The timeline's length will automatically \"grow\" to accommodate new\n   * keyframes as they are added.\n   *\n   * `state` should contain all of the properties that define this keyframe's\n   * state.  These properties can be any value that can be tweened by\n   * [Shifty](http://jeremyckahn.github.io/shifty/doc/) (numbers,\n   * RGB/hexadecimal color strings, and CSS property strings).  `state` can\n   * also be a [function]{@link rekapi.keyframeFunction}, but\n   * [this works differently]{@tutorial keyframes-in-depth}.\n   *\n   * __Note:__ Internally, this creates {@link rekapi.KeyframeProperty}s and\n   * places them on a \"track.\" Tracks are automatically named to match the\n   * relevant {@link rekapi.KeyframeProperty#name}s.  These {@link\n   * rekapi.KeyframeProperty}s are managed for you by the {@link rekapi.Actor}\n   * APIs.\n   *\n   * ## [Click to learn about keyframes in depth]{@tutorial keyframes-in-depth}\n   * @method rekapi.Actor#keyframe\n   * @param {number} millisecond Where on the timeline to set the keyframe.\n   * @param {(Object|rekapi.keyframeFunction)} state The state properties of\n   * the keyframe.  If this is an Object, the properties will be interpolated\n   * between this and those of the following keyframe for a given point on the\n   * animation timeline.  If this is a function ({@link\n   * rekapi.keyframeFunction}), it will be called at the keyframe specified by\n   * `millisecond`.\n   * @param {(string|Object)} [easing] Optional easing string or Object.  If\n   * `state` is a function, this is ignored.\n   * @return {rekapi.Actor}\n   * @fires rekapi.timelineModified\n   */\n  keyframe (millisecond, state, easing = DEFAULT_EASING) {\n    if (state instanceof Function) {\n      state = { 'function': state };\n    }\n\n    each(state, (value, name) =>\n      this.addKeyframeProperty(\n        new KeyframeProperty(\n          millisecond,\n          name,\n          value,\n          typeof easing === 'string' ?\n            easing :\n            (easing[name] || DEFAULT_EASING)\n        )\n      )\n    );\n\n    if (this.rekapi) {\n      invalidateAnimationLength(this.rekapi);\n    }\n\n    invalidateCache(this);\n    fire(this, 'timelineModified');\n\n    return this;\n  }\n\n  /**\n   * @method rekapi.Actor#hasKeyframeAt\n   * @param {number} millisecond Point on the timeline to query.\n   * @param {rekapi.KeyframeProperty#name} [trackName] Optionally scope the\n   * lookup to a particular track.\n   * @return {boolean} Whether or not the actor has any {@link\n   * rekapi.KeyframeProperty}s set at `millisecond`.\n   */\n  hasKeyframeAt (millisecond, trackName = undefined) {\n    const { _propertyTracks } = this;\n\n    if (trackName && !_propertyTracks[trackName]) {\n      return false;\n    }\n\n    const propertyTracks = trackName ?\n      pick(_propertyTracks, [trackName]) :\n      _propertyTracks;\n\n    return Object.keys(propertyTracks).some(track =>\n      propertyTracks.hasOwnProperty(track) &&\n      !!this.getKeyframeProperty(track, millisecond)\n    );\n  }\n\n  /**\n   * Copies all of the {@link rekapi.KeyframeProperty}s from one point on the\n   * actor's timeline to another. This is particularly useful for animating an\n   * actor back to its original position.\n   *\n   *     actor\n   *       .keyframe(0, {\n   *         x: 10,\n   *         y: 15\n   *       }).keyframe(1000, {\n   *         x: 50,\n   *         y: 75\n   *       });\n   *\n   *     // Return the actor to its original position\n   *     actor.copyKeyframe(0, 2000);\n   *\n   * @method rekapi.Actor#copyKeyframe\n   * @param {number} copyFrom The timeline millisecond to copy {@link\n   * rekapi.KeyframeProperty}s from.\n   * @param {number} copyTo The timeline millisecond to copy {@link\n   * rekapi.KeyframeProperty}s to.\n   * @return {rekapi.Actor}\n   */\n  copyKeyframe (copyFrom, copyTo) {\n    // Build the configuation objects to be passed to Actor#keyframe\n    const sourcePositions = {};\n    const sourceEasings = {};\n\n    each(this._propertyTracks, (propertyTrack, trackName) => {\n      const keyframeProperty =\n        this.getKeyframeProperty(trackName, copyFrom);\n\n      if (keyframeProperty) {\n        sourcePositions[trackName] = keyframeProperty.value;\n        sourceEasings[trackName] = keyframeProperty.easing;\n      }\n    });\n\n    this.keyframe(copyTo, sourcePositions, sourceEasings);\n\n    return this;\n  }\n\n  /**\n   * Moves all of the {@link rekapi.KeyframeProperty}s from one point on the\n   * actor's timeline to another.  Although this method does error checking for\n   * you to make sure the operation can be safely performed, an effective\n   * pattern is to use {@link rekapi.Actor#hasKeyframeAt} to see if there is\n   * already a keyframe at the requested `to` destination.\n   *\n   * @method rekapi.Actor#moveKeyframe\n   * @param {number} from The millisecond of the keyframe to be moved.\n   * @param {number} to The millisecond of where the keyframe should be moved\n   * to.\n   * @return {boolean} Whether or not the keyframe was successfully moved.\n   */\n  moveKeyframe (from, to) {\n    if (!this.hasKeyframeAt(from) || this.hasKeyframeAt(to)) {\n      return false;\n    }\n\n    // Move each of the relevant KeyframeProperties to the new location in the\n    // timeline\n    each(this._propertyTracks, (propertyTrack, trackName) => {\n      const oldIndex = propertyIndexInTrack(propertyTrack, from);\n\n      if (oldIndex !== -1) {\n        propertyTrack[oldIndex].millisecond = to;\n      }\n    });\n\n    cleanupAfterKeyframeModification(this);\n\n    return true;\n  }\n\n  /**\n   * Augment the `value` or `easing` of the {@link rekapi.KeyframeProperty}s\n   * at a given millisecond.  Any {@link rekapi.KeyframeProperty}s omitted in\n   * `state` or `easing` are not modified.\n   *\n   *     actor.keyframe(0, {\n   *       'x': 10,\n   *       'y': 20\n   *     }).keyframe(1000, {\n   *       'x': 20,\n   *       'y': 40\n   *     }).keyframe(2000, {\n   *       'x': 30,\n   *       'y': 60\n   *     })\n   *\n   *     // Changes the state of the keyframe at millisecond 1000.\n   *     // Modifies the value of 'y' and the easing of 'x.'\n   *     actor.modifyKeyframe(1000, {\n   *       'y': 150\n   *     }, {\n   *       'x': 'easeFrom'\n   *     });\n   *\n   * @method rekapi.Actor#modifyKeyframe\n   * @param {number} millisecond\n   * @param {Object} state\n   * @param {Object} [easing={}]\n   * @return {rekapi.Actor}\n   */\n  modifyKeyframe (millisecond, state, easing = {}) {\n    each(this._propertyTracks, (propertyTrack, trackName) => {\n      const property = this.getKeyframeProperty(trackName, millisecond);\n\n      if (property) {\n        property.modifyWith({\n          value: state[trackName],\n          easing: easing[trackName]\n        });\n      } else if (state[trackName]) {\n        this.addKeyframeProperty(\n          new KeyframeProperty(\n            millisecond,\n            trackName,\n            state[trackName],\n            easing[trackName]\n          )\n        );\n      }\n    });\n\n    cleanupAfterKeyframeModification(this);\n\n    return this;\n  }\n\n  /**\n   * Remove all {@link rekapi.KeyframeProperty}s set\n   * on the actor at a given millisecond in the animation.\n   *\n   * @method rekapi.Actor#removeKeyframe\n   * @param {number} millisecond The location on the timeline of the keyframe\n   * to remove.\n   * @return {rekapi.Actor}\n   * @fires rekapi.timelineModified\n   */\n  removeKeyframe (millisecond) {\n    each(this._propertyTracks, (propertyTrack, propertyName) => {\n      const index = propertyIndexInTrack(propertyTrack, millisecond);\n\n      if (index !== -1) {\n        const keyframeProperty = propertyTrack[index];\n        this._deleteKeyframePropertyAt(propertyTrack, index);\n        keyframeProperty.detach();\n      }\n    });\n\n    removeEmptyPropertyTracks(this);\n    cleanupAfterKeyframeModification(this);\n    fire(this, 'timelineModified');\n\n    return this;\n  }\n\n  /**\n   * Remove all {@link rekapi.KeyframeProperty}s set\n   * on the actor.\n   *\n   * **NOTE**: This method does _not_ fire the `beforeRemoveKeyframeProperty`\n   * or `removeKeyframePropertyComplete` events.  This method is a bulk\n   * operation that is more efficient than calling {@link\n   * rekapi.Actor#removeKeyframeProperty} many times individually, but\n   * foregoes firing events.\n   *\n   * @method rekapi.Actor#removeAllKeyframes\n   * @return {rekapi.Actor}\n   */\n  removeAllKeyframes () {\n    each(this._propertyTracks, propertyTrack =>\n      propertyTrack.length = 0\n    );\n\n    each(this._keyframeProperties, keyframeProperty =>\n      keyframeProperty.detach()\n    );\n\n    removeEmptyPropertyTracks(this);\n    this._keyframeProperties = {};\n\n    // Calling removeKeyframe performs some necessary post-removal cleanup, the\n    // earlier part of this method skipped all of that for the sake of\n    // efficiency.\n    return this.removeKeyframe(0);\n  }\n\n  /**\n   * @method rekapi.Actor#getKeyframeProperty\n   * @param {string} property The name of the property track.\n   * @param {number} millisecond The millisecond of the property in the\n   * timeline.\n   * @return {(rekapi.KeyframeProperty|undefined)} A {@link\n   * rekapi.KeyframeProperty} that is stored on the actor, as specified by the\n   * `property` and `millisecond` parameters. This is `undefined` if no\n   * properties were found.\n   */\n  getKeyframeProperty (property, millisecond) {\n    const propertyTrack = this._propertyTracks[property];\n\n    return propertyTrack[propertyIndexInTrack(propertyTrack, millisecond)];\n  }\n\n  /**\n   * Modify a {@link rekapi.KeyframeProperty} stored on an actor.\n   * Internally, this calls {@link rekapi.KeyframeProperty#modifyWith} and\n   * then performs some cleanup.\n   *\n   * @method rekapi.Actor#modifyKeyframeProperty\n   * @param {string} property The name of the {@link rekapi.KeyframeProperty}\n   * to modify.\n   * @param {number} millisecond The timeline millisecond of the {@link\n   * rekapi.KeyframeProperty} to modify.\n   * @param {Object} newProperties The properties to augment the {@link\n   * rekapi.KeyframeProperty} with.\n   * @return {rekapi.Actor}\n   */\n  modifyKeyframeProperty (property, millisecond, newProperties) {\n    const keyframeProperty = this.getKeyframeProperty(property, millisecond);\n\n    if (keyframeProperty) {\n      if ('millisecond' in newProperties &&\n          this.hasKeyframeAt(newProperties.millisecond, property)\n        ) {\n        throw new Error(\n          `Tried to move ${property} to ${newProperties.millisecond}ms, but a keyframe property already exists there`\n        );\n      }\n\n      keyframeProperty.modifyWith(newProperties);\n      cleanupAfterKeyframeModification(this);\n    }\n\n    return this;\n  }\n\n  /**\n   * Remove a single {@link rekapi.KeyframeProperty}\n   * from the actor.\n   * @method rekapi.Actor#removeKeyframeProperty\n   * @param {string} property The name of the {@link rekapi.KeyframeProperty}\n   * to remove.\n   * @param {number} millisecond Where in the timeline the {@link\n   * rekapi.KeyframeProperty} to remove is.\n   * @return {(rekapi.KeyframeProperty|undefined)} The removed\n   * KeyframeProperty, if one was found.\n   * @fires rekapi.beforeRemoveKeyframeProperty\n   * @fires rekapi.removeKeyframePropertyComplete\n   */\n  removeKeyframeProperty (property, millisecond) {\n    const { _propertyTracks } = this;\n\n    if (_propertyTracks[property]) {\n      const propertyTrack = _propertyTracks[property];\n      const index = propertyIndexInTrack(propertyTrack, millisecond);\n      const keyframeProperty = propertyTrack[index];\n\n      fire(this, 'beforeRemoveKeyframeProperty', keyframeProperty);\n      this._deleteKeyframePropertyAt(propertyTrack, index);\n      keyframeProperty.detach();\n\n      removeEmptyPropertyTracks(this);\n      cleanupAfterKeyframeModification(this);\n      fire(this, 'removeKeyframePropertyComplete', keyframeProperty);\n\n      return keyframeProperty;\n    }\n  }\n\n  /**\n   *\n   * @method rekapi.Actor#getTrackNames\n   * @return {Array.<rekapi.KeyframeProperty#name>} A list of all the track\n   * names for a {@link rekapi.Actor}.\n   */\n  getTrackNames () {\n    return Object.keys(this._propertyTracks);\n  }\n\n  /**\n   * Get all of the {@link rekapi.KeyframeProperty}s for a track.\n   * @method rekapi.Actor#getPropertiesInTrack\n   * @param {rekapi.KeyframeProperty#name} trackName The track name to query.\n   * @return {Array(rekapi.KeyframeProperty)}\n   */\n  getPropertiesInTrack (trackName) {\n    return (this._propertyTracks[trackName] || []).slice(0);\n  }\n\n  /**\n   * @method rekapi.Actor#getStart\n   * @param {rekapi.KeyframeProperty#name} [trackName] Optionally scope the\n   * lookup to a particular track.\n   * @return {number} The millisecond of the first animating state of a {@link\n   * rekapi.Actor} (for instance, if the first keyframe is later than\n   * millisecond `0`).  If there are no keyframes, this is `0`.\n   */\n  getStart (trackName = undefined) {\n    const { _propertyTracks } = this;\n    const starts = [];\n\n    // Null check to see if trackName was provided and is valid\n    if (_propertyTracks.hasOwnProperty(trackName)) {\n      const firstKeyframeProperty = _propertyTracks[trackName][0];\n\n      if (firstKeyframeProperty) {\n        starts.push(firstKeyframeProperty.millisecond);\n      }\n    } else {\n      // Loop over all property tracks and accumulate the first\n      // keyframeProperties from non-empty tracks\n      each(_propertyTracks, propertyTrack => {\n        if (propertyTrack.length) {\n          starts.push(propertyTrack[0].millisecond);\n        }\n      });\n    }\n\n    return starts.length > 0 ?\n      Math.min.apply(Math, starts) :\n      0;\n  }\n\n  /**\n   * @method rekapi.Actor#getEnd\n   * @param {rekapi.KeyframeProperty#name} [trackName] Optionally scope the\n   * lookup to a particular keyframe track.\n   * @return {number} The millisecond of the last state of an actor (the point\n   * in the timeline in which it is done animating).  If there are no\n   * keyframes, this is `0`.\n   */\n  getEnd (trackName = undefined) {\n    const endingTracks = [0];\n\n    const tracksToInspect = trackName ?\n      { [trackName]: this._propertyTracks[trackName] } :\n      this._propertyTracks;\n\n    each(tracksToInspect, propertyTrack => {\n      if (propertyTrack.length) {\n        endingTracks.push(propertyTrack[propertyTrack.length - 1].millisecond);\n      }\n    });\n\n    return Math.max.apply(Math, endingTracks);\n  }\n\n  /**\n   * @method rekapi.Actor#getLength\n   * @param {rekapi.KeyframeProperty#name} [trackName] Optionally scope the\n   * lookup to a particular track.\n   * @return {number} The length of time in milliseconds that the actor\n   * animates for.\n   */\n  getLength (trackName = undefined) {\n    return this.getEnd(trackName) - this.getStart(trackName);\n  }\n\n  /**\n   * Extend the last state on this actor's timeline to simulate a pause.\n   * Internally, this method copies the final state of the actor in the\n   * timeline to the millisecond defined by `until`.\n   *\n   * @method rekapi.Actor#wait\n   * @param {number} until At what point in the animation the Actor should wait\n   * until (relative to the start of the animation timeline).  If this number\n   * is less than the value returned from {@link rekapi.Actor#getLength},\n   * this method does nothing.\n   * @return {rekapi.Actor}\n   */\n  wait (until) {\n    const end = this.getEnd();\n\n    if (until <= end) {\n      return this;\n    }\n\n    const latestProps = getLatestProperties(this, this.getEnd());\n    const serializedProps = {};\n    const serializedEasings = {};\n\n    each(latestProps, (latestProp, propName) => {\n      serializedProps[propName] = latestProp.value;\n      serializedEasings[propName] = latestProp.easing;\n    });\n\n    this.modifyKeyframe(end, serializedProps, serializedEasings);\n    this.keyframe(until, serializedProps, serializedEasings);\n\n    return this;\n  }\n\n  /*!\n   * Insert a `KeyframeProperty` into a property track at `index`.  The linked\n   * list structure of the property track is maintained.\n   * @method rekapi.Actor#_insertKeyframePropertyAt\n   * @param {KeyframeProperty} keyframeProperty\n   * @param {Array(KeyframeProperty)} propertyTrack\n   * @param {number} index\n   */\n  _insertKeyframePropertyAt (keyframeProperty, propertyTrack, index) {\n    propertyTrack.splice(index, 0, keyframeProperty);\n  }\n\n  /*!\n   * Remove the `KeyframeProperty` at `index` from a property track.  The linked\n   * list structure of the property track is maintained.  The removed property\n   * is not modified or unlinked internally.\n   * @method rekapi.Actor#_deleteKeyframePropertyAt\n   * @param {Array(KeyframeProperty)} propertyTrack\n   * @param {number} index\n   */\n  _deleteKeyframePropertyAt (propertyTrack, index) {\n    propertyTrack.splice(index, 1);\n  }\n\n  /**\n   * Associate a {@link rekapi.KeyframeProperty} to this {@link rekapi.Actor}.\n   * Updates {@link rekapi.KeyframeProperty#actor} to maintain a link between\n   * the two objects.  This is a lower-level method and it is generally better\n   * to use {@link rekapi.Actor#keyframe}.  This is mostly useful for adding a\n   * {@link rekapi.KeyframeProperty} back to an actor after it was {@link\n   * rekapi.KeyframeProperty#detach}ed.\n   * @method rekapi.Actor#addKeyframeProperty\n   * @param {rekapi.KeyframeProperty} keyframeProperty\n   * @return {rekapi.Actor}\n   * @fires rekapi.beforeAddKeyframeProperty\n   * @fires rekapi.addKeyframePropertyTrack\n   * @fires rekapi.addKeyframeProperty\n   */\n  addKeyframeProperty (keyframeProperty) {\n    if (this.rekapi) {\n      fire(this, 'beforeAddKeyframeProperty', keyframeProperty);\n    }\n\n    keyframeProperty.actor = this;\n    this._keyframeProperties[keyframeProperty.id] = keyframeProperty;\n\n    const { name } = keyframeProperty;\n    const { _propertyTracks, rekapi } = this;\n\n    if (!this._propertyTracks[name]) {\n      _propertyTracks[name] = [keyframeProperty];\n\n      if (rekapi) {\n        fire(this, 'addKeyframePropertyTrack', keyframeProperty);\n      }\n    } else {\n      const index = insertionPointInTrack(_propertyTracks[name], keyframeProperty.millisecond);\n\n      if (_propertyTracks[name][index]) {\n        const newMillisecond = keyframeProperty.millisecond;\n        const targetMillisecond = _propertyTracks[name][index].millisecond;\n\n        if (targetMillisecond === newMillisecond) {\n          throw new Error(\n            `Cannot add duplicate ${name} keyframe property @ ${newMillisecond}ms`\n          );\n        } else if (rekapi && rekapi._warnOnOutOfOrderKeyframes) {\n          console.warn(\n            new Error(\n              `Added a keyframe property before end of ${name} track @ ${newMillisecond}ms (< ${targetMillisecond}ms)`\n            )\n          );\n        }\n      }\n\n      this._insertKeyframePropertyAt(keyframeProperty, _propertyTracks[name], index);\n      cleanupAfterKeyframeModification(this);\n    }\n\n    if (rekapi) {\n      fire(this, 'addKeyframeProperty', keyframeProperty);\n    }\n\n    return this;\n  }\n\n  /*!\n   * TODO: Explain the use case for this method\n   * Set the actor to be active or inactive starting at `millisecond`.\n   * @method rekapi.Actor#setActive\n   * @param {number} millisecond The time at which to change the actor's active state\n   * @param {boolean} isActive Whether the actor should be active or inactive\n   * @return {rekapi.Actor}\n   */\n  setActive (millisecond, isActive) {\n    const hasActiveTrack = !!this._propertyTracks._active;\n    const activeProperty = hasActiveTrack\n        && this.getKeyframeProperty('_active', millisecond);\n\n    if (activeProperty) {\n      activeProperty.value = isActive;\n    } else {\n      this.addKeyframeProperty(\n        new KeyframeProperty(millisecond, '_active', isActive)\n      );\n    }\n\n    return this;\n  }\n\n  /*!\n   * Calculate and set the actor's position at `millisecond` in the animation.\n   * @method rekapi.Actor#_updateState\n   * @param {number} millisecond\n   * @param {boolean} [resetLaterFnKeyframes] If true, allow all function\n   * keyframes later in the timeline to be run again.\n   */\n  _updateState (millisecond, resetLaterFnKeyframes = false) {\n    const start = this.getStart();\n    const end = this.getEnd();\n    const interpolatedObject = {};\n\n    millisecond = Math.min(end, millisecond);\n\n    ensurePropertyCacheValid(this);\n\n    const propertyCacheEntry = clone(\n      getPropertyCacheEntryForMillisecond(this, millisecond)\n    );\n\n    delete propertyCacheEntry._millisecond;\n\n    // All actors are active at time 0 unless otherwise specified;\n    // make sure a future time deactivation doesn't deactive the actor\n    // by default.\n    if (propertyCacheEntry._active\n        && millisecond >= propertyCacheEntry._active.millisecond) {\n\n      this.wasActive = propertyCacheEntry._active.getValueAt(millisecond);\n\n      if (!this.wasActive) {\n        return this;\n      }\n    } else {\n      this.wasActive = true;\n    }\n\n    if (start === end) {\n      // If there is only one keyframe, use that for the state of the actor\n      each(propertyCacheEntry, (keyframeProperty, propName) => {\n        if (keyframeProperty.shouldInvokeForMillisecond(millisecond)) {\n          keyframeProperty.invoke();\n          keyframeProperty.hasFired = false;\n          return;\n        }\n\n        interpolatedObject[propName] = keyframeProperty.value;\n      });\n\n    } else {\n      each(propertyCacheEntry, (keyframeProperty, propName) => {\n        if (this._beforeKeyframePropertyInterpolate !== noop) {\n          this._beforeKeyframePropertyInterpolate(keyframeProperty);\n        }\n\n        if (keyframeProperty.shouldInvokeForMillisecond(millisecond)) {\n          keyframeProperty.invoke();\n          return;\n        }\n\n        interpolatedObject[propName] =\n          keyframeProperty.getValueAt(millisecond);\n\n        if (this._afterKeyframePropertyInterpolate !== noop) {\n          this._afterKeyframePropertyInterpolate(\n            keyframeProperty, interpolatedObject);\n        }\n      });\n    }\n\n    this.set(interpolatedObject);\n\n    if (!resetLaterFnKeyframes) {\n      this._resetFnKeyframesFromMillisecond(millisecond);\n    }\n\n    return this;\n  }\n\n  /*!\n   * @method rekapi.Actor#_resetFnKeyframesFromMillisecond\n   * @param {number} millisecond\n   */\n  _resetFnKeyframesFromMillisecond (millisecond) {\n    const cache = this._timelineFunctionCache;\n    const { length } = cache;\n    let index = sortedIndexBy(cache, { millisecond: millisecond }, getMillisecond);\n\n    while (index < length) {\n      cache[index++].hasFired = false;\n    }\n  }\n\n  /**\n   * Export this {@link rekapi.Actor} to a `JSON.stringify`-friendly `Object`.\n   * @method rekapi.Actor#exportTimeline\n   * @param {Object} [config]\n   * @param {boolean} [config.withId=false] If `true`, include internal `id`\n   * values in exported data.\n   * @return {rekapi.actorData} This data can later be consumed by {@link\n   * rekapi.Actor#importTimeline}.\n   */\n  exportTimeline ({ withId = false } = {}) {\n    const exportData = {\n      start: this.getStart(),\n      end: this.getEnd(),\n      trackNames: this.getTrackNames(),\n      propertyTracks: {}\n    };\n\n    if (withId) {\n      exportData.id = this.id;\n    }\n\n    each(this._propertyTracks, (propertyTrack, trackName) => {\n      const track = [];\n\n      propertyTrack.forEach(keyframeProperty => {\n        track.push(keyframeProperty.exportPropertyData({ withId }));\n      });\n\n      exportData.propertyTracks[trackName] = track;\n    });\n\n    return exportData;\n  }\n\n  /**\n   * Import an Object to augment this actor's state.  This does not remove\n   * keyframe properties before importing new ones.\n   * @method rekapi.Actor#importTimeline\n   * @param {rekapi.actorData} actorData Any object that has the same data\n   * format as the object generated from {@link rekapi.Actor#exportTimeline}.\n   */\n  importTimeline (actorData) {\n    each(actorData.propertyTracks, propertyTrack => {\n      propertyTrack.forEach(property => {\n        this.keyframe(\n          property.millisecond,\n          { [property.name]: property.value },\n          property.easing\n        );\n      });\n    });\n  }\n}\n\nObject.assign(Actor.prototype, {\n  /*!\n   * @method rekapi.Actor#_beforeKeyframePropertyInterpolate\n   * @param {KeyframeProperty} keyframeProperty\n   * @abstract\n   */\n  _beforeKeyframePropertyInterpolate: noop,\n\n  /*!\n   * @method rekapi.Actor#_afterKeyframePropertyInterpolate\n   * @param {KeyframeProperty} keyframeProperty\n   * @param {Object} interpolatedObject\n   * @abstract\n   */\n  _afterKeyframePropertyInterpolate: noop\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/actor.js","import { interpolate } from 'shifty';\nimport {\n  fireEvent\n} from './rekapi';\nimport {\n  pick,\n  uniqueId\n} from './utils';\n\nconst DEFAULT_EASING = 'linear';\n\n/**\n * Represents an individual component of an {@link rekapi.Actor}'s keyframe\n * state.  In most cases you won't need to deal with this object directly, as\n * the {@link rekapi.Actor} APIs abstract a lot of what this Object does away\n * for you.\n * @param {number} millisecond Sets {@link\n * rekapi.KeyframeProperty#millisecond}.\n * @param {string} name Sets {@link rekapi.KeyframeProperty#name}.\n * @param {(number|string|boolean|rekapi.keyframeFunction)} value Sets {@link\n * rekapi.KeyframeProperty#value}.\n * @param {string} [easing=\"linear\"] Sets {@link\n * rekapi.KeyframeProperty#easing}.\n * @constructs rekapi.KeyframeProperty\n */\nexport class KeyframeProperty {\n  constructor (millisecond, name, value, easing = DEFAULT_EASING) {\n    /**\n     * @member {string} rekapi.KeyframeProperty#id The unique ID of this {@link\n     * rekapi.KeyframeProperty}.\n     */\n    this.id = uniqueId('keyframeProperty_');\n\n    /**\n     * @member {boolean} rekapi.KeyframeProperty#hasFired Flag to determine if\n     * this {@link rekapi.KeyframeProperty}'s {@link rekapi.keyframeFunction}\n     * should be invoked in the current animation loop.\n     */\n    this.hasFired = null;\n\n    /**\n     * @member {(rekapi.Actor|undefined)} rekapi.KeyframeProperty#actor The\n     * {@link rekapi.Actor} to which this {@link rekapi.KeyframeProperty}\n     * belongs, if any.\n     */\n\n    /**\n     * @member {(rekapi.KeyframeProperty|null)}\n     * rekapi.KeyframeProperty#nextProperty A reference to the {@link\n      * rekapi.KeyframeProperty} that follows this one in a {@link\n      * rekapi.Actor}'s property track.\n     */\n    this.nextProperty = null;\n\n    Object.assign(this, {\n      /**\n       * @member {number} rekapi.KeyframeProperty#millisecond Where on the\n       * animation timeline this {@link rekapi.KeyframeProperty} is.\n       */\n      millisecond,\n      /**\n       * @member {string} rekapi.KeyframeProperty#name This {@link\n       * rekapi.KeyframeProperty}'s name, such as `\"x\"` or `\"opacity\"`.\n       */\n      name,\n      /**\n       * @member {number|string|boolean|rekapi.keyframeFunction}\n       * rekapi.KeyframeProperty#value The value that this {@link\n       * rekapi.KeyframeProperty} represents.\n       */\n      value,\n      /**\n       * @member {string} rekapi.KeyframeProperty#easing The easing curve by\n       * which this {@link rekapi.KeyframeProperty} should be animated.\n       */\n      easing\n    });\n  }\n\n  /**\n   * Modify this {@link rekapi.KeyframeProperty}.\n   * @method rekapi.KeyframeProperty#modifyWith\n   * @param {Object} newProperties Valid values are:\n   * @param {number} [newProperties.millisecond] Sets {@link\n   * rekapi.KeyframeProperty#millisecond}.\n   * @param {string} [newProperties.name] Sets {@link rekapi.KeyframeProperty#name}.\n   * @param {(number|string|boolean|rekapi.keyframeFunction)} [newProperties.value] Sets {@link\n   * rekapi.KeyframeProperty#value}.\n   * @param {string} [newProperties.easing] Sets {@link\n   * rekapi.KeyframeProperty#easing}.\n   */\n  modifyWith (newProperties) {\n    Object.assign(this, newProperties);\n  }\n\n  /**\n   * Calculate the midpoint between this {@link rekapi.KeyframeProperty} and\n   * the next {@link rekapi.KeyframeProperty} in a {@link rekapi.Actor}'s\n   * property track.\n   *\n   * In just about all cases, `millisecond` should be between this {@link\n   * rekapi.KeyframeProperty}'s `millisecond` and the `millisecond` of the\n   * {@link rekapi.KeyframeProperty} that follows it in the animation\n   * timeline, but it is valid to specify a value outside of this range.\n   * @method rekapi.KeyframeProperty#getValueAt\n   * @param {number} millisecond The millisecond in the animation timeline to\n   * compute the state value for.\n   * @return {(number|string|boolean|rekapi.keyframeFunction|rekapi.KeyframeProperty#value)}\n   */\n  getValueAt (millisecond) {\n    const nextProperty = this.nextProperty;\n\n    if (typeof this.value === 'boolean') {\n      return this.value;\n    } else if (nextProperty) {\n      const boundedMillisecond = Math.min(\n        Math.max(millisecond, this.millisecond),\n        nextProperty.millisecond\n      );\n\n      const { name } = this;\n      const delta = nextProperty.millisecond - this.millisecond;\n      const interpolatePosition =\n        (boundedMillisecond - this.millisecond) / delta;\n\n      return interpolate(\n        { [name]: this.value },\n        { [name]: nextProperty.value },\n        interpolatePosition,\n        nextProperty.easing\n      )[name];\n    } else {\n      return this.value;\n    }\n  }\n\n  /**\n   * Create the reference to the {@link rekapi.KeyframeProperty} that follows\n   * this one on a {@link rekapi.Actor}'s property track.  Property tracks\n   * are just linked lists of {@link rekapi.KeyframeProperty}s.\n   * @method rekapi.KeyframeProperty#linkToNext\n   * @param {KeyframeProperty=} nextProperty The {@link\n   * rekapi.KeyframeProperty} that should immediately follow this one on the\n   * animation timeline.\n   */\n  linkToNext (nextProperty = null) {\n    this.nextProperty = nextProperty;\n  }\n\n  /**\n   * Disassociates this {@link rekapi.KeyframeProperty} from its {@link\n   * rekapi.Actor}.  This is called by various {@link rekapi.Actor} methods\n   * and triggers the [removeKeyframeProperty]{@link rekapi.Rekapi#on} event\n   * on the associated {@link rekapi.Rekapi} instance.\n   * @method rekapi.KeyframeProperty#detach\n   * @fires rekapi.removeKeyframeProperty\n   */\n  detach () {\n    const { actor } = this;\n\n    if (actor && actor.rekapi) {\n      fireEvent(actor.rekapi, 'removeKeyframeProperty', this);\n      delete actor._keyframeProperties[this.id];\n      this.actor = null;\n    }\n\n    return this;\n  }\n\n  /**\n   * Export this {@link rekapi.KeyframeProperty} to a `JSON.stringify`-friendly\n   * `Object`.\n   * @method rekapi.KeyframeProperty#exportPropertyData\n   * @param {Object} [config]\n   * @param {boolean} [config.withId=false] If `true`, include internal `id`\n   * value in exported data.\n   * @return {rekapi.propertyData}\n   */\n  exportPropertyData ({ withId = false } = {}) {\n    const props = ['millisecond', 'name', 'value', 'easing'];\n\n    if (withId) {\n      props.push('id');\n    }\n\n    return pick(this, props);\n  }\n\n  /*!\n   * Whether or not this is a function keyframe and should be invoked for the\n   * current frame.  Helper method for Actor.\n   * @method rekapi.KeyframeProperty#shouldInvokeForMillisecond\n   * @return {boolean}\n   */\n  shouldInvokeForMillisecond (millisecond) {\n    return (millisecond >= this.millisecond &&\n      this.name === 'function' &&\n      !this.hasFired\n    );\n  }\n\n  /**\n   * Calls {@link rekapi.KeyframeProperty#value} if it is a {@link\n   * rekapi.keyframeFunction}.\n   * @method rekapi.KeyframeProperty#invoke\n   * @return {any} Whatever value is returned for this {@link\n   * rekapi.KeyframeProperty}'s {@link rekapi.keyframeFunction}.\n   */\n  invoke () {\n    const drift = this.actor.rekapi._loopPosition - this.millisecond;\n    const returnValue = this.value(this.actor, drift);\n    this.hasFired = true;\n\n    return returnValue;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/keyframe-property.js","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n// WEBPACK FOOTER //\n// (webpack)/buildin/global.js","import Rekapi, {\n  rendererBootstrappers\n} from '../rekapi';\n\n// PRIVATE UTILITY FUNCTIONS\n//\n\n/*!\n * Gets (and optionally sets) height or width on a canvas.\n * @param {HTMLCanvas} canvas\n * @param {string} heightOrWidth The dimension (either \"height\" or \"width\")\n * to get or set.\n * @param {number=} newSize The new value to set for `dimension`.\n * @return {number}\n */\nconst dimension = (canvas, heightOrWidth, newSize = undefined) => {\n  if (newSize !== undefined) {\n    canvas[heightOrWidth] = newSize;\n    canvas.style[heightOrWidth] = `${newSize}px`;\n  }\n\n  return canvas[heightOrWidth];\n};\n\n// CANVAS RENDERER OBJECT\n//\n\n/**\n * You can use Rekapi to render animations to an HTML5 `<canvas>`.  To do so,\n * just provide a\n * [`CanvasRenderingContext2D`](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D)\n * instance to the {@link rekapi.Rekapi} constructor to\n * automatically set up the renderer:\n *\n *     const rekapi = new Rekapi(document.createElement('canvas').getContext('2d'));\n *\n *  To use this renderer's API, get a reference to the initialized object:\n *\n *     const canvasRenderer = rekapi.getRendererInstance(CanvasRenderer);\n *\n * __Note__: {@link rekapi.CanvasRenderer} is added to {@link\n * rekapi.Rekapi#renderers} automatically, there is no reason to call the\n * constructor yourself in most cases.\n * @param {rekapi.Rekapi} rekapi The {@link rekapi.Rekapi} instance to render for.\n * @param {CanvasRenderingContext2D=} context See [the canvas\n * docs](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D).\n * @constructor rekapi.CanvasRenderer\n * @extends {rekapi.renderer}\n */\nexport class CanvasRenderer {\n\n  constructor (rekapi, context = undefined) {\n    Object.assign(this, {\n      rekapi,\n      canvasContext: context || rekapi.context\n    });\n\n    rekapi.on('beforeUpdate', () => this.clear());\n  }\n\n  /**\n   * Get and optionally set the height of the associated `<canvas>` element.\n   * @method rekapi.CanvasRenderer#height\n   * @param {number} [height] The height to optionally set.\n   * @return {number}\n   */\n  height (height = undefined) {\n    return dimension(this.canvasContext.canvas, 'height', height);\n  }\n\n  /**\n   * Get and optionally set the width of the associated `<canvas>` element.\n   * @method rekapi.CanvasRenderer#width\n   * @param {number} [width] The width to optionally set.\n   * @return {number}\n   */\n  width (width = undefined) {\n    return dimension(this.canvasContext.canvas, 'width', width);\n  }\n\n  /**\n   * Erase the `<canvas>`.\n   * @method rekapi.CanvasRenderer#clear\n   * @return {rekapi.CanvasRenderer}\n   */\n  clear () {\n    this.canvasContext.clearRect(0, 0, this.width(), this.height());\n\n    return this;\n  }\n}\n\n/*!\n * Sets up an instance of CanvasRenderer and attaches it to a `Rekapi`\n * instance.  Also augments the Rekapi instance with canvas-specific\n * functions.\n * @param {Rekapi} rekapi\n */\nrendererBootstrappers.push(rekapi => {\n  if (typeof CanvasRenderingContext2D === 'undefined' ||\n    !(rekapi.context instanceof CanvasRenderingContext2D)) {\n\n    return;\n  }\n\n  return new CanvasRenderer(rekapi);\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/renderers/canvas.js","import { Tweenable } from 'shifty';\nimport Rekapi, {\n  rendererBootstrappers,\n  fireEvent\n} from '../rekapi';\n\nimport {\n  clone,\n  difference,\n  each,\n  intersection,\n  pick,\n  reject,\n  uniq,\n  without\n} from '../utils';\n\nconst { now } = Tweenable;\n\nconst vendorTransforms = [\n  'transform',\n  'webkitTransform',\n  'MozTransform',\n  'oTransform',\n  'msTransform'\n];\n\nexport const transformFunctions = [\n  'translateX',\n  'translateY',\n  'translateZ',\n  'scale',\n  'scaleX',\n  'scaleY',\n  'perspective',\n  'rotate',\n  'rotateX',\n  'rotateY',\n  'rotateZ',\n  'skewX',\n  'skewY'\n];\n\nconst DEFAULT_FPS = 30;\nexport const TRANSFORM_TOKEN = 'TRANSFORM';\nexport const VENDOR_TOKEN = 'VENDOR';\nconst R_TRANSFORM_TOKEN = new RegExp(TRANSFORM_TOKEN, 'g');\nconst R_VENDOR_TOKEN = new RegExp(VENDOR_TOKEN, 'g');\nconst VENDOR_PREFIXES = {\n  microsoft: '-ms-',\n  mozilla: '-moz-',\n  opera: '-o-',\n  w3: '',\n  webkit: '-webkit-'\n};\nconst BEZIERS = {\n  linear: '.25,.25,.75,.75',\n  easeInQuad: '.55,.085,.68,.53',\n  easeInCubic: '.55,.055,.675,.19',\n  easeInQuart: '.895,.03,.685,.22',\n  easeInQuint: '.755,.05,.855,.06',\n  easeInSine: '.47,0,.745,.715',\n  easeInExpo: '.95,.05,.795,.035',\n  easeInCirc: '.6,.04,.98, .335',\n  easeOutQuad: '.25,.46,.45,.94',\n  easeOutCubic: '.215,.61,.355,1',\n  easeOutQuart: '.165,.84,.44,1',\n  easeOutQuint: '.23,1,.32,1',\n  easeOutSine: '.39,.575,.565,1',\n  easeOutExpo: '.19,1,.22,1',\n  easeOutCirc: '.075,.82,.165,1',\n  easeInOutQuad: '.455,.03,.515,.955',\n  easeInOutCubic: '.645,.045,.355,1',\n  easeInOutQuart: '.77,0,.175,1',\n  easeInOutQuint: '.86,0.07,1',\n  easeInOutSine: '.445,.05,.55,.95',\n  easeInOutExpo: '1,0,0,1',\n  easeInOutCirc: '.785,.135,.15,.86'\n};\n\n// The timer to remove an injected style isn't likely to match the actual\n// length of the CSS animation, so give it some extra time to complete so it\n// doesn't cut off the end.\nconst INJECTED_STYLE_REMOVAL_BUFFER_MS = 250;\n\nconst R_3D_RULE = /3d\\(/g;\nconst _3D_RULE = '3d(';\nconst _3D_TOKEN = '__THREED__';\n\n// PRIVATE UTILITY FUNCTIONS\n//\n\n/*!\n * http://stackoverflow.com/a/3886106\n *\n * @param {number} number\n */\nconst isInt = number => number % 1 === 0;\n\n/*!\n * @return {string}\n */\nconst vendorPrefix = (() => {\n  if (typeof document === 'undefined') {\n    return;\n  }\n\n  const { style } = document.body;\n\n  return (\n    '-webkit-animation' in style ? 'webkit'    :\n    '-moz-animation'    in style ? 'mozilla'   :\n    '-ms-animation'     in style ? 'microsoft' :\n    '-o-animation'      in style ? 'opera'     :\n    'animation'         in style ? 'w3'        :\n    ''\n  );\n})();\n\n/*!\n * @param {Actor} actor\n * @return {string} The default CSS class that is targeted by {@link\n * rekapi.DOMRenderer#getCss} if a custom class is not specified.  This may be\n * useful for getting a standard and consistent CSS class name for an actor's\n * DOM element.\n */\nconst getActorClassName = actor => `actor-${actor.id}`;\n\n/*!\n * Fixes a really bizarre issue that only seems to affect Presto and Blink.\n * In some situations, DOM nodes will not detect dynamically injected <style>\n * elements.  Explicitly re-inserting DOM nodes seems to fix the issue.  Not\n * sure what causes this issue.  Not sure why this fixes it.\n *\n * @param {Rekapi} rekapi\n */\nconst forceStyleReset = rekapi => {\n  const dummyDiv = document.createElement('div');\n\n  rekapi.getAllActors().forEach(actor => {\n    if (actor.context.nodeType === 1) {\n      const { context } = actor;\n      const { parentElement } = context;\n\n      parentElement.replaceChild(dummyDiv, context);\n      parentElement.replaceChild(context, dummyDiv);\n    }\n  });\n};\n\nlet styleID = 0;\n/*!\n * @param {Rekapi} rekapi\n * @param {string} css The css content that the <style> element should have.\n * @return {HTMLStyleElement} The unique ID of the injected <style> element.\n */\nconst injectStyle = (rekapi, css) => {\n  const style = document.createElement('style');\n  const id = `rekapi-${styleID++}`;\n  style.id = id;\n  style.innerHTML = css;\n  document.head.appendChild(style);\n  forceStyleReset(rekapi);\n\n  return style;\n};\n\n/*!\n * @param {HTMLElement} element\n * @param {string} styleName\n * @param {string|number} styleValue\n */\nconst setStyle = (element, styleName, styleValue) =>\n  element.style[styleName] = styleValue;\n\n/*!\n * @param {string} name A transform function name\n * @return {boolean}\n */\nconst isTransformFunction = name => ~transformFunctions.indexOf(name);\n\n/*!\n * Builds a concatenated string of given transform property values in order.\n *\n * @param {Array.<string>} orderedTransforms Array of ordered transform\n *     function names\n * @param {Object} transformProperties Transform properties to build together\n * @return {string}\n */\nconst buildTransformValue = (orderedTransforms, transformProperties) => {\n  const transformComponents = [];\n\n  orderedTransforms.forEach(functionName => {\n    if (transformProperties[functionName] !== undefined) {\n      transformComponents.push(\n        `${functionName}(${transformProperties[functionName]})`\n      );\n    }\n  });\n\n  return transformComponents.join(' ');\n};\n\n/*!\n * Sets value for all vendor prefixed transform properties on an element\n *\n * @param {HTMLElement} element The actor's DOM element\n * @param {string} transformValue The transform style value\n */\nconst setTransformStyles = (element, transformValue) =>\n  vendorTransforms.forEach(prefixedTransform =>\n    setStyle(element, prefixedTransform, transformValue)\n  );\n\n/*!\n * @param {Actor} actor\n * @param {HTMLElement} element\n * @param {Object} state\n */\nconst actorRender = (actor, element, state) => {\n  const propertyNames = Object.keys(state);\n  // TODO:  Optimize the following code so that propertyNames is not looped\n  // over twice.\n  const transformFunctionNames = propertyNames.filter(isTransformFunction);\n  const otherProperties = pick(\n    state,\n    reject(propertyNames, isTransformFunction)\n  );\n\n  if (transformFunctionNames.length) {\n    setTransformStyles(element,\n      buildTransformValue(\n        actor._transformOrder,\n        pick(state, transformFunctionNames)\n      )\n    );\n  } else if (state.transform) {\n    setTransformStyles(element, state.transform);\n  }\n\n  each(otherProperties, (styleValue, styleName) =>\n    setStyle(element, styleName, styleValue)\n  );\n};\n\n/*!\n * @param {Actor} actor\n */\nconst actorTeardown = actor => {\n  const { context } = actor;\n  const classList = context.className.match(/\\S+/g);\n  const sanitizedClassList =\n    without(classList, getActorClassName(actor));\n  context.className = sanitizedClassList.join(' ');\n};\n\n/*!\n * transform properties like translate3d and rotate3d break the cardinality\n * of multi-ease easing strings, because the \"3\" gets treated like a\n * tweenable value.  Transform \"3d(\" to \"__THREED__\" to prevent this, and\n * transform it back in _afterKeyframePropertyInterpolate.\n *\n * @param {KeyframeProperty} keyframeProperty\n */\nconst _beforeKeyframePropertyInterpolate = keyframeProperty => {\n  if (keyframeProperty.name !== 'transform') {\n    return;\n  }\n\n  const { value, nextProperty } = keyframeProperty;\n\n  if (nextProperty && value.match(R_3D_RULE)) {\n    keyframeProperty.value = value.replace(R_3D_RULE, _3D_TOKEN);\n    nextProperty.value = nextProperty.value.replace(R_3D_RULE, _3D_TOKEN);\n  }\n};\n\n/*!\n * @param {KeyframeProperty} keyframeProperty\n * @param {Object} interpolatedObject\n */\nconst _afterKeyframePropertyInterpolate = (keyframeProperty, interpolatedObject) => {\n  if (keyframeProperty.name !== 'transform') {\n    return;\n  }\n\n  const { value, nextProperty, name } = keyframeProperty;\n\n  if (nextProperty && value.match(_3D_TOKEN)) {\n    keyframeProperty.value = value.replace(_3D_TOKEN, _3D_RULE);\n    nextProperty.value = nextProperty.value.replace(_3D_TOKEN, _3D_RULE);\n    interpolatedObject[name] =\n      interpolatedObject[name].replace(_3D_TOKEN, _3D_RULE);\n  }\n};\n\n/*!\n * @param {Rekapi} rekapi\n * @param {Actor} actor\n */\nconst onAddActor = (rekapi, actor) => {\n  const { context } = actor;\n\n  if (context.nodeType !== 1) {\n    return;\n  }\n\n  const className = getActorClassName(actor);\n\n  // Add the class if it's not already there.\n  // Using className instead of classList to make IE happy.\n  if (!context.className.match(className)) {\n    context.className += ` ${className}`;\n  }\n\n  Object.assign(actor, {\n    render: actorRender.bind(actor, actor),\n    teardown: actorTeardown.bind(actor, actor),\n    _transformOrder: transformFunctions.slice(0),\n    _beforeKeyframePropertyInterpolate,\n    _afterKeyframePropertyInterpolate\n  });\n};\n\n/*!\n * @param {string} keyframes\n * @param {vendor} vendor\n * @return {string}\n */\nexport const applyVendorPropertyPrefixes = (keyframes, vendor) =>\n  keyframes\n    .replace(\n      R_VENDOR_TOKEN,\n      VENDOR_PREFIXES[vendor]\n    )\n    .replace(\n      R_TRANSFORM_TOKEN,\n      `${VENDOR_PREFIXES[vendor]}transform`\n    );\n\n/*!\n * @param {string} toKeyframes Generated keyframes to wrap in boilerplates\n * @param {string} animName\n * @param {Array.<string>=} vendors Vendor boilerplates to be applied.\n *     Should be any of the values in Rekapi.util.VENDOR_PREFIXES.\n * @return {string}\n */\nexport const applyVendorBoilerplates = (toKeyframes, animName, vendors = ['w3']) =>\n  vendors.map(vendor =>\n    applyVendorPropertyPrefixes(\n      `@${VENDOR_PREFIXES[vendor]}keyframes ${animName}-keyframes {\n${''  }${toKeyframes}\n${''  }}`,\n      vendor)\n  ).join('\\n');\n\n/*!\n * @param {KeyframeProperty} property\n * @param {number} fromPercent\n * @param {number} toPercent\n * @return {string}\n */\nexport const generateOptimizedKeyframeSegment = (\n  property,\n  fromPercent,\n  toPercent\n) => {\n  const name = property.name === 'transform' ?\n    TRANSFORM_TOKEN :\n    property.name;\n\n  const { nextProperty, value } = property;\n  const from = isInt(fromPercent) ? fromPercent : fromPercent.toFixed(2);\n  const to = isInt(toPercent) ? toPercent : toPercent.toFixed(2);\n  const bezier = BEZIERS[nextProperty.easing.split(' ')[0]];\n\n  return (\n `  ${from}% {${name}:${value};${''\n  }${VENDOR_TOKEN}animation-timing-function: cubic-bezier(${bezier});${''\n  }}\n  ${to}% {${name}:${nextProperty.value};}`\n  );\n};\n\n/*!\n * @param {Object} propsToSerialize\n * @param {Array.<string>} transformNames\n * @return {Object}\n */\nexport const combineTransformProperties = (propsToSerialize, transformNames) => {\n  if (Object.keys(pick(propsToSerialize, transformFunctions)).length) {\n    const serializedProps = clone(propsToSerialize);\n\n    serializedProps[TRANSFORM_TOKEN] = transformNames.reduce(\n      (combinedProperties, transformFunction) => {\n      if (serializedProps.hasOwnProperty(transformFunction)) {\n        combinedProperties +=\n          ` ${transformFunction}(${serializedProps[transformFunction]})`;\n\n        delete serializedProps[transformFunction];\n      }\n\n      return combinedProperties;\n    }, '').slice(1);\n\n    return serializedProps;\n  } else {\n    return propsToSerialize;\n  }\n};\n\n/*!\n * @param {Actor} actor\n * @param {string=} targetProp\n * @return {string}\n */\nexport const serializeActorStep = (actor, targetProp = undefined) => {\n  const transformProperties = combineTransformProperties(\n    targetProp ?\n      { [targetProp]: actor.get()[targetProp] } :\n      actor.get(),\n    actor._transformOrder\n  );\n\n  const data = Object.keys(transformProperties)\n    .reduce(\n      (acc, key) =>\n        `${acc}${\n          key === 'transform' ? TRANSFORM_TOKEN : key\n        }:${transformProperties[key]};`,\n      ''\n  );\n\n  return `{${data}}`;\n};\n\n/*!\n * @param {Actor} actor\n * @param {number} increments\n * @param {number} incrementSize\n * @param {number} actorStart\n * @param {number} fromPercent\n * @param {KeyframeProperty=} fromProp\n * @return {Array.<string>}\n */\nexport const generateActorTrackSegment = (\n  actor,\n  increments,\n  incrementSize,\n  actorStart,\n  fromPercent,\n  fromProp = undefined\n) => {\n\n  const accumulator = [];\n  const length = actor.getLength();\n\n  for (let i = 0; i < increments; i++) {\n    const percent = fromPercent + (i * incrementSize);\n\n    actor._updateState(\n      ((percent / 100) * length) + actorStart,\n      true\n    );\n\n    const step = serializeActorStep(actor, fromProp && fromProp.name);\n\n    accumulator.push(`  ${+percent.toFixed(2)}% ${step}`);\n  }\n\n  return accumulator;\n};\n\n/*!\n * @param {Actor} actor\n * @param {number} steps\n * @return {string}\n */\nconst generateCombinedActorKeyframes = (actor, steps) =>\n  generateActorTrackSegment(actor, steps + 1, 100 / steps, 0, 0).join('\\n');\n\n/*!\n * @param {Actor} actor\n * @param {string} track\n * @param {number} actorStart\n * @return {string|undefined}\n */\nexport const simulateLeadingWait = (actor, track, actorStart) => {\n  const firstProp = actor._propertyTracks[track][0];\n\n  if (firstProp !== undefined && firstProp.millisecond !== actorStart) {\n    return generateActorTrackSegment(\n      actor,\n      1,\n      1,\n      firstProp.millisecond,\n      0,\n      firstProp\n    ).join('\\n');\n  }\n};\n\n/*!\n * @param {Actor} actor\n * @param {string} track\n * @param {number} actorStart\n * @param {number} actorEnd\n * @return {string|undefined}\n */\nexport const simulateTrailingWait = (actor, track, actorStart, actorEnd) => {\n  const [ lastProp ] = actor._propertyTracks[track].slice(-1);\n\n  if (lastProp !== undefined && lastProp.millisecond !== actorEnd) {\n    return generateActorTrackSegment(\n      actor,\n      1,\n      1,\n      actorStart,\n      100,\n      lastProp\n    ).join('\\n');\n  }\n};\n\n/*!\n * @param {KeyframeProperty} property\n * @param {number} actorStart\n * @param {number} actorLength\n * @return {number}\n */\nconst calculateStepPercent = (property, actorStart, actorLength) =>\n  ((property.millisecond - actorStart) / actorLength) * 100;\n\n/*!\n * @param {Actor} actor\n * @param {number} actorStart\n * @param {KeyframeProperty} fromProp\n * @param {KeyframeProperty} toProp\n * @param {number} fromPercent\n * @param {number} toPercent\n * @return {Array.<string>}\n */\nconst generateActorTrackWaitSegment = (\n  actor,\n  actorStart,\n  fromProp,\n  toProp,\n  fromPercent,\n  toPercent\n) =>\n  generateActorTrackSegment(\n    actor,\n    1,\n    toPercent - fromPercent,\n    actorStart,\n    fromPercent,\n    fromProp\n  );\n\n/*!\n * @param {KeyframeProperty} property\n * @param {KeyframeProperty} nextProperty\n * @return {boolean}\n */\nconst isSegmentAWait = (property, nextProperty) =>\n  property.name === nextProperty.name &&\n    property.value === nextProperty.value;\n\n/*!\n * @param {KeyframeProperty} property\n * @return {boolean}\n */\nexport const canOptimizeKeyframeProperty = property =>\n  !property.nextProperty ?\n    false :\n    isSegmentAWait(property, property.nextProperty) ?\n      true :\n      property.nextProperty.easing.split(' ').every((easing, i, easings) =>\n        !(!BEZIERS[easing] || (i > 0 && easings[i - 1] !== easing))\n      );\n\n/*!\n * @param {Actor} actor\n * @param {number} steps\n * @param {string} track\n * @return {string}\n */\nexport const generateActorKeyframes = (actor, steps, track) => {\n  // This function is completely crazy.  Simplify it?\n  const accumulator = [];\n  const end = actor.getEnd();\n  const start = actor.getStart();\n  const length = actor.getLength();\n  const leadingWait = simulateLeadingWait(actor, track, start);\n\n  if (leadingWait) {\n    accumulator.push(leadingWait);\n  }\n\n  let previousSegmentWasOptimized = false;\n  actor._propertyTracks[track].forEach(prop => {\n    const fromPercent = calculateStepPercent(prop, start, length);\n    const { nextProperty } = prop;\n\n    let toPercent, increments, incrementSize;\n\n    if (nextProperty) {\n      toPercent = calculateStepPercent(nextProperty, start, length);\n      const delta = toPercent - fromPercent;\n      increments = Math.floor((delta / 100) * steps) || 1;\n      incrementSize = delta / increments;\n    } else {\n      toPercent = 100;\n      increments = 1;\n      incrementSize = 1;\n    }\n\n    let trackSegment;\n    if (nextProperty && isSegmentAWait(prop, nextProperty)) {\n      trackSegment = generateActorTrackWaitSegment(\n        actor,\n        start,\n        prop,\n        nextProperty,\n        fromPercent,\n        toPercent\n      );\n\n      if (previousSegmentWasOptimized) {\n        trackSegment.shift();\n      }\n\n      previousSegmentWasOptimized = false;\n\n    } else if (canOptimizeKeyframeProperty(prop)) {\n      trackSegment = generateOptimizedKeyframeSegment(\n        prop,\n        fromPercent,\n        toPercent\n      );\n\n      // If this and the previous segment are optimized, remove the\n      // destination keyframe of the previous step.  The starting keyframe of\n      // the newest segment makes it redundant.\n      if (previousSegmentWasOptimized) {\n        accumulator[accumulator.length - 1] =\n          accumulator[accumulator.length - 1].split('\\n')[0];\n      }\n\n      previousSegmentWasOptimized = true;\n    } else {\n      trackSegment = generateActorTrackSegment(\n        actor,\n        increments,\n        incrementSize,\n        start,\n        fromPercent,\n        prop\n      );\n\n      if (previousSegmentWasOptimized) {\n        trackSegment.shift();\n      }\n\n      if (trackSegment.length) {\n        trackSegment = trackSegment.join('\\n');\n      }\n\n      previousSegmentWasOptimized = false;\n    }\n\n    if (trackSegment.length) {\n      accumulator.push(trackSegment);\n    }\n  });\n\n  const trailingWait = simulateTrailingWait(actor, track, start, end);\n\n  if (trailingWait) {\n    accumulator.push(trailingWait);\n  }\n\n  return accumulator.join('\\n');\n};\n\n/*!\n * @param {Actor} actor\n * @param {string} animName\n * @param {number} steps\n * @param {boolean} doCombineProperties\n * @param {Array.<string>=} vendors\n * @return {string}\n */\nexport const generateBoilerplatedKeyframes = (\n  actor,\n  animName,\n  steps,\n  doCombineProperties,\n  vendors = undefined\n) =>\n\n  doCombineProperties ?\n    applyVendorBoilerplates(\n      generateCombinedActorKeyframes(actor, steps),\n      animName,\n      vendors\n    ) :\n    actor.getTrackNames().map(trackName =>\n      applyVendorBoilerplates(\n        generateActorKeyframes(actor, steps, trackName),\n        `${animName}-${trackName}`,\n        vendors\n      )\n    ).join('\\n');\n\n/*!\n * @param {Actor} actor\n * @param {string} animName\n * @param {string} prefix\n * @param {boolean} doCombineProperties\n * @return {string}\n */\nexport const generateAnimationNameProperty = (\n  actor,\n  animationName,\n  prefix,\n  doCombineProperties\n) => {\n\n  let renderedName = `  ${prefix}animation-name:`;\n\n  if (doCombineProperties) {\n    renderedName += ` ${animationName}-keyframes;`;\n  } else {\n    const trackNames = actor.getTrackNames();\n\n    const trackNamesToPrint = intersection(trackNames, transformFunctions).length ?\n      difference(trackNames, transformFunctions).concat('transform') :\n      trackNames;\n\n    renderedName = trackNamesToPrint.reduce(\n      (renderedName, trackName) =>\n        `${renderedName} ${animationName}-${trackName}-keyframes,`,\n      renderedName\n    ).replace(/.$/, ';');\n  }\n\n  return renderedName;\n};\n\n/*!\n * @param {Rekapi} rekapi\n * @param {string} prefix\n * @param {number|string=} iterations\n * @return {string}\n */\nexport const generateAnimationIterationProperty = (\n  rekapi,\n  prefix,\n  iterations = undefined\n) =>\n  `  ${prefix}animation-iteration-count: ${iterations !== undefined ?\n    iterations :\n    rekapi._timesToIterate === -1 ?\n      'infinite' :\n      rekapi._timesToIterate\n   };`;\n\n/*!\n * @param {Actor} actor\n * @param {string} animName\n * @param {string} vendor\n * @param {boolean} doCombineProperties\n * @param {number|string=} iterations\n * @param {boolean=} isCentered\n * @return {string}\n */\nexport const generateCSSAnimationProperties = (\n  actor,\n  animName,\n  vendor,\n  doCombineProperties,\n  iterations = undefined,\n  isCentered = false\n) => {\n  const prefix = VENDOR_PREFIXES[vendor];\n  const start = actor.getStart();\n  const end = actor.getEnd();\n\n  const generatedProperties = [\n    generateAnimationNameProperty(actor, animName, prefix, doCombineProperties),\n    `  ${prefix}animation-duration: ${end - start}ms;`,\n    `  ${prefix}animation-delay: ${start}ms;`,\n    `  ${prefix}animation-fill-mode: forwards;`,\n    `  ${prefix}animation-timing-function: linear;`,\n    generateAnimationIterationProperty(actor.rekapi, prefix, iterations),\n  ];\n\n  if (isCentered) {\n    generatedProperties.push(`  ${prefix}transform-origin: 0 0;`);\n  }\n\n  return generatedProperties.join('\\n');\n};\n\n/*!\n * @param {Actor} actor\n * @param {string} animName\n * @param {boolean} doCombineProperties\n * @param {Array.<string>=} vendors\n * @param {number|string=} iterations\n * @param {boolean=} isCentered\n * @return {string}\n */\nexport const generateCSSClass = (\n    actor,\n    animName,\n    doCombineProperties,\n    vendors = ['w3'],\n    iterations = undefined,\n    isCentered = undefined\n  ) =>\n\n  `.${animName} {\n${  vendors.map(vendor =>\n      generateCSSAnimationProperties(\n        actor,\n        animName,\n        vendor,\n        doCombineProperties,\n        iterations,\n        isCentered\n      )\n    ).join('\\n')}\n}`;\n\n/*!\n * @param {Actor} actor\n * @return {boolean}\n */\nexport const canOptimizeAnyKeyframeProperties = (actor) =>\n  Object.keys(actor._keyframeProperties).some(\n    property =>\n      canOptimizeKeyframeProperty(actor._keyframeProperties[property])\n  ) &&\n  !intersection(\n    Object.keys(actor._propertyTracks),\n    transformFunctions\n  ).length;\n\n/*!\n * Creates the CSS `@keyframes` for an individual actor.\n * @param {Actor} actor\n * @param {Object=} options Same as options for Rekapi.prototype.toCSS.\n * @return {string}\n */\nexport const getActorCSS = (actor, options = {}) => {\n  const { name, vendors, iterations, isCentered } = options;\n\n  const animName = name ?\n    (actor.rekapi.getActorCount() > 1 ?\n      `${name}-${actor.id}` :\n      name\n    ) :\n    getActorClassName(actor);\n\n  const steps = Math.ceil(\n    (actor.rekapi.getAnimationLength() / 1000) * (options.fps || DEFAULT_FPS)\n  );\n\n  const doCombineProperties = !canOptimizeAnyKeyframeProperties(actor);\n\n  return [\n    generateCSSClass(\n      actor,\n      animName,\n      doCombineProperties,\n      vendors,\n      iterations,\n      isCentered\n    ),\n    generateBoilerplatedKeyframes(\n      actor,\n      animName,\n      steps,\n      doCombineProperties,\n      vendors\n    )\n  ].join('\\n');\n};\n\n/**\n * {@link rekapi.DOMRenderer} allows you to animate DOM elements.  This is\n * achieved either by [CSS `@keyframe`\n * animations](https://developer.mozilla.org/en-US/docs/Web/CSS/@keyframes), or\n * by per-frame inline style updates  keyframes are defined with the same API\n * in either case.  To render animations with the DOM, just supply any DOM\n * element to the {@link rekapi.Rekapi} constructor.  You may use\n * `document.body`, since it is generally always available:\n *\n *     const rekapi = new Rekapi(document.body);\n *\n *  To use this renderer's API, get a reference to the initialized object:\n *\n *     const domRenderer = rekapi.getRendererInstance(DOMRenderer);\n *\n * There are separate APIs for playing inline style animations and CSS\n * `@keyframe` animations.  For a detailed breakdown of how to choose between\n * these two APIs and use {@link rekapi.DOMRenderer} effectively, check out the\n * {@tutorial dom-rendering-in-depth} tutorial.\n *\n * __Note__: {@link rekapi.DOMRenderer} is added to {@link\n * rekapi.Rekapi#renderers} automatically, there is no reason to call the\n * constructor yourself in most cases.\n * @param {rekapi.Rekapi} rekapi The {@link rekapi.Rekapi} instance to render for.\n * @constructor rekapi.DOMRenderer\n * @extends {rekapi.renderer}\n */\nexport class DOMRenderer {\n  constructor (rekapi) {\n\n    Object.assign(this, {\n      rekapi,\n\n      // @private {number}\n      _playTimestamp: null,\n\n      // @private {string}\n      _cachedCSS: null,\n\n      // The HTMLStyleElement that gets injected into the DOM.\n      // @private {HTMLStyleElement)\n      _styleElement: null,\n\n      // @private {number}\n      _stopSetTimeoutHandle: null\n    });\n\n    rekapi.on('timelineModified', () => this._cachedCSS = null);\n    rekapi.on('addActor', onAddActor);\n  }\n\n  /**\n   * @method rekapi.DOMRenderer#canAnimateWithCSS\n   * @return {boolean} Whether or not the browser supports CSS `@keyframe`\n   * animations.\n   */\n  canAnimateWithCSS () {\n    return !!vendorPrefix;\n  }\n\n  /**\n   * Play the Rekapi animation as a CSS `@keyframe` animation.\n   *\n   * Note that this is not the same as {@link rekapi.Rekapi#play}.  That method\n   * controls inline style animations, while this method controls CSS\n   * `@keyframe` animations.\n   * @method rekapi.DOMRenderer#play\n   * @param {number} [iterations] How many times the animation should loop.\n   * This can be `null` or `0` if you want to loop the animation endlessly but\n   * also specify a value for `fps`.\n   * @param {number} [fps] How many `@keyframes` to generate per second of the\n   * animation.  A higher value results in a more precise CSS animation, but it\n   * will take longer to generate.  The default value is `30`.  You should not\n   * need to go higher than `60`.\n   * @fires rekapi.play\n   */\n  play (iterations = undefined, fps = undefined) {\n    if (this.isPlaying()) {\n      this.stop();\n    }\n\n    this._styleElement = injectStyle(\n      this.rekapi,\n      this._cachedCSS || this.prerender.apply(this, arguments)\n    );\n\n    this._playTimestamp = now();\n\n    if (iterations) {\n      const animationLength = (iterations * this.rekapi.getAnimationLength());\n      this._stopSetTimeoutHandle = setTimeout(\n        this.stop.bind(this, true),\n        animationLength + INJECTED_STYLE_REMOVAL_BUFFER_MS\n      );\n    }\n\n    fireEvent(this.rekapi, 'play');\n  }\n\n  /**\n   * Stop a CSS `@keyframe` animation.  This also removes any `<style>`\n   * elements that were dynamically injected into the DOM.\n   *\n   * Note that this is not the same as {@link rekapi.Rekapi#stop}.  That method\n   * controls inline style animations, while this method controls CSS\n   * `@keyframe` animations.\n   * @method rekapi.DOMRenderer#stop\n   * @param {boolean=} goToEnd If true, skip to the end of the animation.  If\n   * false or omitted, set inline styles on the {@link rekapi.Actor} elements\n   * to keep them in their current position.\n   * @fires rekapi.stop\n   */\n  stop (goToEnd = undefined) {\n    if (this.isPlaying()) {\n      clearTimeout(this._stopSetTimeoutHandle);\n\n      // Forces a style update in WebKit/Presto\n      this._styleElement.innerHTML = '';\n\n      document.head.removeChild(this._styleElement);\n      this._styleElement = null;\n      const animationLength = this.rekapi.getAnimationLength();\n\n      this.rekapi.update(\n        goToEnd ?\n          animationLength :\n          (now() - this._playTimestamp) % animationLength\n      );\n\n      fireEvent(this.rekapi, 'stop');\n    }\n  }\n\n  /**\n   * @method rekapi.DOMRenderer#isPlaying\n   * @return {boolean} Whether or not a CSS `@keyframe` animation is running.\n   */\n  isPlaying () {\n    return !!this._styleElement;\n  }\n\n  /**\n   * Prerender and cache the CSS animation so that it is immediately ready to\n   * be used when it is needed in the future.  The function signature is\n   * identical to {@link rekapi.DOMRenderer#play}.  This\n   * is necessary to play a CSS animation and will be automatically called for\n   * you if you don't call it manually, but calling it ahead of time (such as\n   * on page load) will prevent any perceived lag when a CSS `@keyframe`\n   * animation is started.  The prerendered animation is cached for reuse until\n   * the timeline or a keyframe is modified.\n   *\n   * @method rekapi.DOMRenderer#prerender\n   * @param {number=} iterations How many times the animation should loop.\n   * This can be `null` or `0` if you want to loop the animation endlessly but\n   * also specify a value for `fps`.\n   * @param {number=} fps How many `@keyframes` to generate per second of\n   * the animation.  A higher value results in a more precise CSS animation,\n   * but it will take longer to generate.  The default value is `30`.  You\n   * should not need to go higher than `60`.\n   * @return {string} The prerendered CSS string.  You likely won't need this,\n   * as it is also cached internally.\n   */\n  prerender (iterations = undefined, fps = undefined) {\n    return this._cachedCSS = this.getCss({\n      vendors: [vendorPrefix],\n      fps,\n      iterations\n    });\n  }\n\n  /**\n   * You can decouple transform components in order to animate each property\n   * with its own easing curve:\n   *\n   *     actor\n   *       .keyframe(0, {\n   *         translateX: '0px',\n   *         translateY: '0px',\n   *         rotate: '0deg'\n   *       })\n   *       .keyframe(1500, {\n   *         translateX: '200px',\n   *         translateY: '200px',\n   *         rotate: '90deg'\n   *       }, {\n   *         translateX: 'easeOutExpo',\n   *         translateY: 'easeInSine',\n   *         rotate: 'elastic'\n   *       });\n   *\n   * CSS transform string components are order-dependent, but JavaScript object\n   * properties have an unpredictable order.  Rekapi must combine transform\n   * properties supplied to {@link rekapi.Actor#keyframe} (as shown above) into\n   * a single string when it renders each frame.  This method lets you change\n   * that order from the default.\n   *\n   * However, if you prefer a more standards-oriented approach, Rekapi also\n   * supports combining the transform components yourself, obviating the need\n   * for {@link rekapi.DOMRenderer#setActorTransformOrder} entirely:\n   *\n   *     actor\n   *       .keyframe(0, {\n   *         transform: 'translateX(0px) translateY(0px) rotate(0deg)'\n   *       })\n   *       .keyframe(1500, {\n   *         transform: 'translateX(200px) translateY(200px) rotate(90deg)'\n   *       }, {\n   *         transform: 'easeOutExpo easeInSine elastic'\n   *       });\n   * @method rekapi.DOMRenderer#setActorTransformOrder\n   * @param {rekapi.Actor} actor The {@link rekapi.Actor} to apply the new\n   * transform order to.\n   * @param {Array.<string>} orderedTransforms The array of transform names.\n   * The supported array values (and default order) are:\n   *\n   * - `translateX`\n   * - `translateY`\n   * - `translateZ`\n   * - `scale`\n   * - `scaleX`\n   * - `scaleY`\n   * - `perspective`\n   * - `rotate`\n   * - `rotateX`\n   * - `rotateY`\n   * - `rotateZ`\n   * - `skewX`\n   * - `skewY`\n   * @return {rekapi.Rekapi}\n   */\n  setActorTransformOrder (actor, orderedTransforms) {\n    const unrecognizedTransforms = reject(orderedTransforms, isTransformFunction);\n\n    if (unrecognizedTransforms.length) {\n      throw `Unknown or unsupported transform functions: ${unrecognizedTransforms.join(', ')}`;\n    }\n\n    // Ignore duplicate transform function names in the array\n    actor._transformOrder = uniq(orderedTransforms);\n\n    return this.rekapi;\n  }\n\n  /**\n   * Convert the animation to CSS `@keyframes`.\n   * @method rekapi.DOMRenderer#getCss\n   * @param {Object} [options={}]\n   * @param {Array.<string>} [options.vendors=['w3']] The browser vendors you\n   * want to support. Valid values are:\n   *   * `'microsoft'`\n   *   * `'mozilla'`\n   *   * `'opera'`\n   *   * `'w3'`\n   *   * `'webkit'`\n   *\n   *\n   * @param {number} [options.fps=30]  Defines the number of CSS `@keyframe` frames\n   * rendered per second of an animation.  CSS `@keyframes` are comprised of a\n   * series of explicitly defined steps, and more steps will allow for a more\n   * complex animation.  More steps will also result in a larger CSS string,\n   * and more time needed to generate the string.\n   * @param {string} [options.name] Define a custom name for your animation.\n   * This becomes the class name targeted by the generated CSS.\n   * @param {boolean} [options.isCentered] If `true`, the generated CSS will\n   * contain `transform-origin: 0 0;`, which centers the DOM element along the\n   * path of motion.  If `false` or omitted, no `transform-origin` rule is\n   * specified and the element is aligned to the path of motion by its top-left\n   * corner.\n   * @param {number} [options.iterations] How many times the generated\n   * animation should repeat.  If omitted, the animation will loop\n   * indefinitely.\n   * @return {string}\n   */\n  getCss (options = {}) {\n    const animationCSS = [];\n\n    this.rekapi.getAllActors().forEach(actor => {\n      if (actor.context.nodeType === 1) {\n        animationCSS.push(getActorCSS(actor, options));\n      }\n    });\n\n    return animationCSS.join('\\n');\n  }\n}\n\n/*!\n * @param {Rekapi} rekapi\n */\nrendererBootstrappers.push(rekapi =>\n  // Node.nodeType 1 is an ELEMENT_NODE.\n  // https://developer.mozilla.org/en-US/docs/Web/API/Node.nodeType\n  rekapi.context.nodeType === 1 && new DOMRenderer(rekapi)\n);\n\n\n\n// WEBPACK FOOTER //\n// ./src/renderers/dom.js","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used to compose bitmasks for comparison styles. */\nvar UNORDERED_COMPARE_FLAG = 1,\n    PARTIAL_COMPARE_FLAG = 2;\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_SAFE_INTEGER = 9007199254740991;\n\n/** Used as references for the maximum length and index of an array. */\nvar MAX_ARRAY_LENGTH = 4294967295,\n    MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/,\n    reLeadingDot = /^\\./,\n    rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeFloor = Math.floor,\n    nativeKeys = overArg(Object.keys, Object),\n    nativeMin = Math.min;\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values ? values.length : 0;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\n/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  this.__data__ = new ListCache(entries);\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  return this.__data__['delete'](key);\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var cache = this.__data__;\n  if (cache instanceof ListCache) {\n    var pairs = cache.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      return this;\n    }\n    cache = this.__data__ = new MapCache(pairs);\n  }\n  cache.set(key, value);\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  // Safari 9 makes `arguments.length` enumerable in strict mode.\n  var result = (isArray(value) || isArguments(value))\n    ? baseTimes(value.length, String)\n    : [];\n\n  var length = result.length,\n      skipIndexes = !!length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = isKey(path, object) ? [path] : castPath(path);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\n/**\n * The base implementation of `getTag`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  return objectToString.call(value);\n}\n\n/**\n * The base implementation of `_.hasIn` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHasIn(object, key) {\n  return object != null && key in Object(object);\n}\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {boolean} [bitmask] The bitmask of comparison flags.\n *  The bitmask may be composed of the following flags:\n *     1 - Unordered comparison\n *     2 - Partial comparison\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, customizer, bitmask, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);\n}\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`\n *  for more details.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = arrayTag,\n      othTag = arrayTag;\n\n  if (!objIsArr) {\n    objTag = getTag(object);\n    objTag = objTag == argsTag ? objectTag : objTag;\n  }\n  if (!othIsArr) {\n    othTag = getTag(other);\n    othTag = othTag == argsTag ? objectTag : othTag;\n  }\n  var objIsObj = objTag == objectTag && !isHostObject(object),\n      othIsObj = othTag == objectTag && !isHostObject(other),\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, equalFunc, customizer, bitmask, stack)\n      : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);\n  }\n  if (!(bitmask & PARTIAL_COMPARE_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, equalFunc, customizer, bitmask, stack);\n}\n\n/**\n * The base implementation of `_.isMatch` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property values to match.\n * @param {Array} matchData The property names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */\nfunction baseIsMatch(object, source, matchData, customizer) {\n  var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer;\n\n  if (object == null) {\n    return !length;\n  }\n  object = Object(object);\n  while (index--) {\n    var data = matchData[index];\n    if ((noCustomizer && data[2])\n          ? data[1] !== object[data[0]]\n          : !(data[0] in object)\n        ) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0],\n        objValue = object[key],\n        srcValue = data[1];\n\n    if (noCustomizer && data[2]) {\n      if (objValue === undefined && !(key in object)) {\n        return false;\n      }\n    } else {\n      var stack = new Stack;\n      if (customizer) {\n        var result = customizer(objValue, srcValue, key, object, source, stack);\n      }\n      if (!(result === undefined\n            ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack)\n            : result\n          )) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[objectToString.call(value)];\n}\n\n/**\n * The base implementation of `_.iteratee`.\n *\n * @private\n * @param {*} [value=_.identity] The value to convert to an iteratee.\n * @returns {Function} Returns the iteratee.\n */\nfunction baseIteratee(value) {\n  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n  if (typeof value == 'function') {\n    return value;\n  }\n  if (value == null) {\n    return identity;\n  }\n  if (typeof value == 'object') {\n    return isArray(value)\n      ? baseMatchesProperty(value[0], value[1])\n      : baseMatches(value);\n  }\n  return property(value);\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.matches` which doesn't clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatches(source) {\n  var matchData = getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n  }\n  return function(object) {\n    return object === source || baseIsMatch(object, source, matchData);\n  };\n}\n\n/**\n * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatchesProperty(path, srcValue) {\n  if (isKey(path) && isStrictComparable(srcValue)) {\n    return matchesStrictComparable(toKey(path), srcValue);\n  }\n  return function(object) {\n    var objValue = get(object, path);\n    return (objValue === undefined && objValue === srcValue)\n      ? hasIn(object, path)\n      : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);\n  };\n}\n\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyDeep(path) {\n  return function(object) {\n    return baseGet(object, path);\n  };\n}\n\n/**\n * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`\n * which invokes `iteratee` for `value` and each element of `array` to compute\n * their sort ranking. The iteratee is invoked with one argument; (value).\n *\n * @private\n * @param {Array} array The sorted array to inspect.\n * @param {*} value The value to evaluate.\n * @param {Function} iteratee The iteratee invoked per element.\n * @param {boolean} [retHighest] Specify returning the highest qualified index.\n * @returns {number} Returns the index at which `value` should be inserted\n *  into `array`.\n */\nfunction baseSortedIndexBy(array, value, iteratee, retHighest) {\n  value = iteratee(value);\n\n  var low = 0,\n      high = array ? array.length : 0,\n      valIsNaN = value !== value,\n      valIsNull = value === null,\n      valIsSymbol = isSymbol(value),\n      valIsUndefined = value === undefined;\n\n  while (low < high) {\n    var mid = nativeFloor((low + high) / 2),\n        computed = iteratee(array[mid]),\n        othIsDefined = computed !== undefined,\n        othIsNull = computed === null,\n        othIsReflexive = computed === computed,\n        othIsSymbol = isSymbol(computed);\n\n    if (valIsNaN) {\n      var setLow = retHighest || othIsReflexive;\n    } else if (valIsUndefined) {\n      setLow = othIsReflexive && (retHighest || othIsDefined);\n    } else if (valIsNull) {\n      setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);\n    } else if (valIsSymbol) {\n      setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);\n    } else if (othIsNull || othIsSymbol) {\n      setLow = false;\n    } else {\n      setLow = retHighest ? (computed <= value) : (computed < value);\n    }\n    if (setLow) {\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n  return nativeMin(high, MAX_ARRAY_INDEX);\n}\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value) {\n  return isArray(value) ? value : stringToPath(value);\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} customizer The function to customize comparisons.\n * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`\n *  for more details.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, equalFunc, customizer, bitmask, stack) {\n  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & UNORDERED_COMPARE_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!seen.has(othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {\n              return seen.add(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, customizer, bitmask, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} customizer The function to customize comparisons.\n * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`\n *  for more details.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & PARTIAL_COMPARE_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= UNORDERED_COMPARE_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} customizer The function to customize comparisons.\n * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`\n *  for more details.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, equalFunc, customizer, bitmask, stack) {\n  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,\n      objProps = keys(object),\n      objLength = objProps.length,\n      othProps = keys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the property names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */\nfunction getMatchData(object) {\n  var result = keys(object),\n      length = result.length;\n\n  while (length--) {\n    var key = result[length],\n        value = object[key];\n\n    result[length] = [key, value, isStrictComparable(value)];\n  }\n  return result;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11,\n// for data views in Edge < 14, and promises in Node.js.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = objectToString.call(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : undefined;\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Checks if `path` exists on `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @param {Function} hasFunc The function to check properties.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n */\nfunction hasPath(object, path, hasFunc) {\n  path = isKey(path, object) ? [path] : castPath(path);\n\n  var result,\n      index = -1,\n      length = path.length;\n\n  while (++index < length) {\n    var key = toKey(path[index]);\n    if (!(result = object != null && hasFunc(object, key))) {\n      break;\n    }\n    object = object[key];\n  }\n  if (result) {\n    return result;\n  }\n  var length = object ? object.length : 0;\n  return !!length && isLength(length) && isIndex(key, length) &&\n    (isArray(object) || isArguments(object));\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */\nfunction isStrictComparable(value) {\n  return value === value && !isObject(value);\n}\n\n/**\n * A specialized version of `matchesProperty` for source values suitable\n * for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction matchesStrictComparable(key, srcValue) {\n  return function(object) {\n    if (object == null) {\n      return false;\n    }\n    return object[key] === srcValue &&\n      (srcValue !== undefined || (key in Object(object)));\n  };\n}\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoize(function(string) {\n  string = toString(string);\n\n  var result = [];\n  if (reLeadingDot.test(string)) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, string) {\n    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * This method is like `_.sortedIndex` except that it accepts `iteratee`\n * which is invoked for `value` and each element of `array` to compute their\n * sort ranking. The iteratee is invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {Array} array The sorted array to inspect.\n * @param {*} value The value to evaluate.\n * @param {Function} [iteratee=_.identity]\n *  The iteratee invoked per element.\n * @returns {number} Returns the index at which `value` should be inserted\n *  into `array`.\n * @example\n *\n * var objects = [{ 'x': 4 }, { 'x': 5 }];\n *\n * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });\n * // => 0\n *\n * // The `_.property` iteratee shorthand.\n * _.sortedIndexBy(objects, { 'x': 4 }, 'x');\n * // => 0\n */\nfunction sortedIndexBy(array, value, iteratee) {\n  return baseSortedIndexBy(array, value, baseIteratee(iteratee, 2));\n}\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result);\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Assign cache to `_.memoize`.\nmemoize.Cache = MapCache;\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nfunction isArguments(value) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&\n    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\n/**\n * Checks if `path` is a direct or inherited property of `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.hasIn(object, 'a');\n * // => true\n *\n * _.hasIn(object, 'a.b');\n * // => true\n *\n * _.hasIn(object, ['a', 'b']);\n * // => true\n *\n * _.hasIn(object, 'b');\n * // => false\n */\nfunction hasIn(object, path) {\n  return object != null && hasPath(object, path, baseHasIn);\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\n/**\n * Creates a function that returns the value at `path` of a given object.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': 2 } },\n *   { 'a': { 'b': 1 } }\n * ];\n *\n * _.map(objects, _.property('a.b'));\n * // => [2, 1]\n *\n * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n * // => [1, 2]\n */\nfunction property(path) {\n  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n}\n\nmodule.exports = sortedIndexBy;\n\n\n\n// WEBPACK FOOTER //\n// ./~/lodash.sortedindexby/index.js","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// (webpack)/buildin/module.js","/**\n * @namespace rekapi\n */\n\n/**\n * An Object that provides utilities for rendering a {@link rekapi.Actor}.\n * @typedef {Object} rekapi.renderer\n * @property {rekapi.render} render A function that renders a {@link\n * rekapi.Actor}.\n */\n\n/**\n * @typedef {Object} rekapi.propertyData\n * @property {number|string} value\n * @property {number} millisecond\n * @property {string} easing\n * @property {string} name\n * @property {string|undefined} id\n */\n\n/**\n * @typedef {Object} rekapi.actorData\n * @property {Array.<string>} trackNames The values of this array must\n * correspond 1:1 to the key names in `propertyTracks`.\n * @property {Object.<Array.<rekapi.propertyData>>} propertyTracks\n * @property {number} end\n * @property {number} start\n * @property {string|undefined} id\n */\n\n/**\n * The properties of this object are used as arguments provided to\n * [`shifty.setBezierFunction`](http://jeremyckahn.github.io/shifty/doc/shifty.html#.setBezierFunction).\n * @typedef {Object} rekapi.curveData\n * @property {number} x1\n * @property {number} x2\n * @property {number} y1\n * @property {number} y2\n * @property {string} displayName\n */\n\n/**\n * The `JSON.stringify`-friendly data format for serializing a Rekapi\n * animation.\n * @typedef {Object} rekapi.timelineData\n * @property {Array.<rekapi.actorData>} actors\n * @property {Object.<rekapi.curveData>} curves\n * @property {number} duration\n */\n\n/**\n * A function that is called when an event is fired.  See the events listed\n * below for details on the types of events that Rekapi supports.\n * @callback rekapi.eventHandler\n * @param {rekapi.Rekapi} rekapi A {@link rekapi.Rekapi} instance.\n * @param {Object} data Data provided from the event (see {@link\n * rekapi.Rekapi#on} for details).\n */\n\n/**\n * A function that gets called every time the actor's state is updated (once\n * every frame). This function should do something meaningful with the state of\n * the actor (for example, visually rendering to the screen).\n * @callback rekapi.render\n * @param {Object} context An actor's {@link rekapi.Actor#context} Object.\n * @param {Object} state An actor's current state properties.\n */\n\n/**\n * @callback rekapi.keyframeFunction\n * @param {rekapi.Actor} actor The {@link rekapi.Actor} to which this\n * {@link rekapi.keyframeFunction} was provided.\n * @param {number} drift A number that represents the delay between when the\n * function is called and when it was scheduled. There is typically some amount\n * of delay due to the nature of JavaScript timers.\n */\n\n/**\n * @callback rekapi.actorSortFunction\n * @param {rekapi.Actor} actor A {@link rekapi.Actor} that should expose a\n * `number` value to sort by.\n * @return {number}\n */\n\n/**\n * Fires when all animation loops have completed.\n * @event rekapi.animationComplete\n */\n/**\n * Fires when the animation is played, paused, or stopped.\n * @event rekapi.playStateChange\n */\n/**\n * Fires when the animation is {@link rekapi.Rekapi#play}ed.\n * @event rekapi.play\n */\n/**\n * Fires when the animation is {@link rekapi.Rekapi#pause}d.\n * @event rekapi.pause\n */\n/**\n * Fires when the animation is {@link rekapi.Rekapi#stop}ped.\n * @event rekapi.stop\n */\n/**\n * Fires each frame before all actors are rendered.\n * @event rekapi.beforeUpdate\n */\n/**\n * Fires each frame after all actors are rendered.\n * @event rekapi.afterUpdate\n */\n/**\n * @event rekapi.addActor\n * @param {rekapi.Actor} actor The {@link rekapi.Actor} that was added.\n */\n/**\n * @event rekapi.removeActor\n * @param {rekapi.Actor} actor The {@link rekapi.Actor} that was removed.\n */\n/**\n * Fires just before the point where a {@link rekapi.KeyframeProperty} is added\n * to the timeline.  This event is called before any modifications to the\n * timeline are done.\n * @event rekapi.beforeAddKeyframeProperty\n */\n/**\n * @event rekapi.addKeyframeProperty\n * @param {rekapi.KeyframeProperty} keyframeProperty The {@link\n * rekapi.KeyframeProperty} that was added.\n */\n/**\n * Fires just before the point where a {@link rekapi.KeyframeProperty} is\n * removed.  This event is called before any modifications to the timeline are\n * done.\n * @event rekapi.beforeRemoveKeyframeProperty\n */\n/**\n * Fires when a {@link rekapi.KeyframeProperty} is removed.  This event is\n * fired _before_ the internal state of the keyframe (but not the timeline, in\n * contrast to {@link rekapi.event:beforeRemoveKeyframeProperty}) has been\n * updated to reflect the keyframe property removal (this is in contrast to\n * {@link rekapi.event:removeKeyframePropertyComplete}).\n * @event rekapi.removeKeyframeProperty\n * @param {rekapi.KeyframeProperty} keyframeProperty The {@link\n * rekapi.KeyframeProperty} that was removed.\n */\n/**\n * Fires when a {@link rekapi.KeyframeProperty} has finished being removed from\n * the timeline.  Unlike {@link rekapi.event:removeKeyframeProperty}, this is\n * fired _after_ the internal state of Rekapi has been updated to reflect the\n * removal of the keyframe property.\n * @event rekapi.removeKeyframePropertyComplete\n * @param {rekapi.KeyframeProperty} keyframeProperty The {@link\n * rekapi.KeyframeProperty} that was removed.\n */\n/**\n * Fires when the a keyframe is added to an actor that creates a new keyframe\n * property track.\n * @event rekapi.addKeyframePropertyTrack\n * @param {rekapi.KeyframeProperty} keyframeProperty The {@link\n * rekapi.KeyframeProperty} that was added to create the property track.\n */\n/**\n * Fires when the last keyframe property in an actor's keyframe property track\n * is removed.  Rekapi automatically removes property tracks when they are\n * emptied out, which causes this event to be fired.\n * @event rekapi.removeKeyframePropertyTrack\n * @param {string} trackName name of the track that was removed.\n */\n/**\n * Fires when a keyframe is added, modified or removed.\n * @event rekapi.timelineModified\n */\n/**\n * Fires when an animation loop ends and a new one begins.\n * @event rekapi.animationLooped\n */\n\nexport { Rekapi } from './rekapi';\nexport { Actor } from './actor';\nexport { KeyframeProperty } from './keyframe-property';\nexport { CanvasRenderer } from './renderers/canvas';\nexport { DOMRenderer } from './renderers/dom';\n\n\n\n// WEBPACK FOOTER //\n// ./src/main.js"],"sourceRoot":""}