<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>renderers/dom/rekapi.renderer.dom.js - Rekapi</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../../../demo/img/rekapi-logo-200.png" title="Rekapi"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.4.5</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Rekapi.html">Rekapi</a></li>
            
                <li><a href="../classes/Rekapi.Actor.html">Rekapi.Actor</a></li>
            
                <li><a href="../classes/Rekapi.CanvasRenderer.html">Rekapi.CanvasRenderer</a></li>
            
                <li><a href="../classes/Rekapi.DOMRenderer.html">Rekapi.DOMRenderer</a></li>
            
                <li><a href="../classes/Rekapi.KeyframeProperty.html">Rekapi.KeyframeProperty</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: renderers/dom/rekapi.renderer.dom.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
rekapiModules.push(function (context) {

  &#x27;use strict&#x27;;

  var Rekapi = context.Rekapi;
  var _ = Rekapi._;
  var now = Rekapi.Tweenable.now;
  var vendorTransforms = [
    &#x27;transform&#x27;
    ,&#x27;webkitTransform&#x27;
    ,&#x27;MozTransform&#x27;
    ,&#x27;oTransform&#x27;
    ,&#x27;msTransform&#x27;];
  var transformFunctions = [
    &#x27;translateX&#x27;,
    &#x27;translateY&#x27;,
    &#x27;translateZ&#x27;,
    &#x27;scale&#x27;,
    &#x27;scaleX&#x27;,
    &#x27;scaleY&#x27;,
    &#x27;rotate&#x27;,
    &#x27;skewX&#x27;,
    &#x27;skewY&#x27;];

  // CONSTANTS
  //

  // The timer to remove an injected style isn&#x27;t likely to match the actual
  // length of the CSS animation, so give it some extra time to complete so it
  // doesn&#x27;t cut off the end.
  var INJECTED_STYLE_REMOVAL_BUFFER_MS = 250;

  // PRIVATE UTILITY FUNCTIONS
  //

  /*!
   * @param {string} formatter
   * @param {[string]} args
   * @return {string}
   */
  var printf = function (formatter, args) {
    var composedStr = formatter;
    _.each(args, function (arg) {
      composedStr = composedStr.replace(&#x27;%s&#x27;, arg);
    });

    return composedStr;
  };

  /*!
   * http://stackoverflow.com/a/3886106
   *
   * @param {number} number
   */
  function isInt (number) {
    return number % 1 === 0;
  }

  /*!
   * @param {Rekapi} rekapi
   */
  Rekapi._rendererInitHook.cssAnimate = function (rekapi) {
    // Node.nodeType 1 is an ELEMENT_NODE.
    // https://developer.mozilla.org/en-US/docs/Web/API/Node.nodeType
    if (rekapi.context.nodeType === 1) {
      rekapi.renderer = new DOMRenderer(rekapi);
    }
  };

  /*!
   * @return {string}
   */
  function getVendorPrefix () {
    var style = document.body.style;

    if (&#x27;-webkit-animation&#x27; in style) {
      return &#x27;webkit&#x27;;
    } else if (&#x27;-moz-animation&#x27; in style) {
      return &#x27;mozilla&#x27;;
    } else if (&#x27;-ms-animation&#x27; in style) {
      return &#x27;microsoft&#x27;;
    } else if (&#x27;-o-animation&#x27; in style) {
      return &#x27;opera&#x27;;
    } else if (&#x27;animation&#x27; in style) {
      return &#x27;w3&#x27;;
    }

    return &#x27;&#x27;;
  }

  var styleID = 0;
  /*!
   * @param {Rekapi} rekapi
   * @param {string} css The css content that the &lt;style&gt; element should have.
   * @return {HTMLStyleElement} The unique ID of the injected &lt;style&gt; element.
   */
  function injectStyle (rekapi, css) {
    var style = document.createElement(&#x27;style&#x27;);
    var id = &#x27;rekapi-&#x27; + styleID++;
    style.id = id;
    style.innerHTML = css;
    document.head.appendChild(style);
    forceStyleReset(rekapi);

    return style;
  }

  /*!
   * Fixes a really bizarre issue that only seems to affect Presto and Blink.
   * In some situations, DOM nodes will not detect dynamically injected &lt;style&gt;
   * elements.  Explicitly re-inserting DOM nodes seems to fix the issue.  Not
   * sure what causes this issue.  Not sure why this fixes it.
   *
   * @param {Rekapi} rekapi
   */
  function forceStyleReset (rekapi) {
    var dummyDiv = document.createElement(&#x27;div&#x27;);

    _.each(rekapi.getAllActors(), function (actor) {
      if (actor.context.nodeType === 1) {
        var actorEl = actor.context;
        var actorElParent = actorEl.parentElement;

        actorElParent.replaceChild(dummyDiv, actorEl);
        actorElParent.replaceChild(actorEl, dummyDiv);
      }
    });

    dummyDiv = null;
  }

  /*!
   * @param {HTMLElement} element
   * @param {string} styleName
   * @param {string|number} styleValue
   */
  function setStyle (element, styleName, styleValue) {
    element.style[styleName] = styleValue;
  }

  /*!
   * @param {string} name A transform function name
   * @return {boolean}
   */
  function isTransformFunction (name) {
    return _.contains(transformFunctions, name);
  }

  /*!
   * Builds a concatenated string of given transform property values in order.
   *
   * @param {Array.&lt;string&gt;} orderedTransforms Array of ordered transform
   *     function names
   * @param {Object} transformProperties Transform properties to build together
   * @return {string}
   */
  function buildTransformValue (orderedTransforms, transformProperties) {
    var transformComponents = [];

    _.each(orderedTransforms, function(functionName) {
      if (transformProperties[functionName]) {
        transformComponents.push(functionName + &#x27;(&#x27; +
          transformProperties[functionName] + &#x27;)&#x27;);
      }
    });

    return transformComponents.join(&#x27; &#x27;);
  }

  /*!
   * Sets value for all vendor prefixed transform properties on an element
   *
   * @param {HTMLElement} element The actor&#x27;s DOM element
   * @param {string} transformValue The transform style value
   */
  function setTransformStyles (element, transformValue) {
    _.each(vendorTransforms, function(prefixedTransform) {
      setStyle(element, prefixedTransform, transformValue);
    });
  }


  /*!
   * @param {Rekapi} rekapi
   * @param {Rekapi.Actor} actor
   */
  function onAddActor (rekapi, actor) {
    var actorElement = actor.context;

    if (actorElement.nodeType !== 1) {
      return;
    }

    var className = DOMRenderer.getActorClassName(actor);

    // Add the class if it&#x27;s not already there.
    // Using className instead of classList to make IE happy.
    if (!actorElement.className.match(className)) {
      actorElement.className += &#x27; &#x27; + className;
    }

    actor._transformOrder = transformFunctions.slice(0);
    actor._beforeKeyframePropertyInterpolate = actorBeforeInterpolate;
    actor._afterKeyframePropertyInterpolate = actorAfterInterpolate;
    actor.render = _.bind(actorRender, actor, actor);
    actor.teardown = _.bind(actorTeardown, actor, actor);
  }

  /*!
   * transform properties like translate3d and rotate3d break the cardinality
   * of multi-ease easing strings, because the &quot;3&quot; gets treated like a
   * tweenable value.  Transform &quot;3d(&quot; to &quot;__THREED__&quot; to prevent this, and
   * transform it back in _afterKeyframePropertyInterpolate.
   *
   * @param {Rekapi.KeyframeProperty} keyframeProperty
   */
  function actorBeforeInterpolate (keyframeProperty) {
    if (keyframeProperty.name !== &#x27;transform&#x27;) {
      return;
    }

    var value = keyframeProperty.value;
    var nextProp = keyframeProperty.nextProperty;

    if (nextProp &amp;&amp; value.match(/3d\(/g)) {
      keyframeProperty.value = value.replace(/3d\(/g, &#x27;__THREED__&#x27;);
      nextProp.value = nextProp.value.replace(/3d\(/g, &#x27;__THREED__&#x27;);
    }
  }

  /*!
   * @param {Rekapi.KeyframeProperty} keyframeProperty
   * @param {Object} interpolatedObject
   */
  function actorAfterInterpolate (keyframeProperty, interpolatedObject) {
    if (keyframeProperty.name !== &#x27;transform&#x27;) {
      return;
    }

    var value = keyframeProperty.value;
    var nextProp = keyframeProperty.nextProperty;

    if (nextProp &amp;&amp; value.match(/__THREED__/g)) {
      keyframeProperty.value = value.replace(/__THREED__/g, &#x27;3d(&#x27;);
      nextProp.value = nextProp.value.replace(/__THREED__/g, &#x27;3d(&#x27;);
      var keyPropName = keyframeProperty.name;
      interpolatedObject[keyPropName] =
          interpolatedObject[keyPropName].replace(/__THREED__/g, &#x27;3d(&#x27;);
    }
  }

  /*!
   * @param {Rekapi.Actor} actor
   * @param {HTMLElement} element
   * @param {Object} state
   */
  function actorRender (actor, element, state) {
    var propertyNames = _.keys(state);
    // TODO:  Optimize the following code so that propertyNames is not looped
    // over twice.
    var transformFunctionNames = _.filter(propertyNames, isTransformFunction);
    var otherPropertyNames = _.reject(propertyNames, isTransformFunction);
    var otherProperties = _.pick(state, otherPropertyNames);

    if (transformFunctionNames.length) {
      var transformProperties = _.pick(state, transformFunctionNames);
      var builtStyle = buildTransformValue(actor._transformOrder,
          transformProperties);
      setTransformStyles(element, builtStyle);
    } else if (state.transform) {
      setTransformStyles(element, state.transform);
    }

    _.each(otherProperties, function (styleValue, styleName) {
      setStyle(element, styleName, styleValue);
    });
  }

  /*!
   * @param {Rekapi.Actor} actor
   */
  function actorTeardown (actor) {
    var element = actor.context;
    var classList = element.className.match(/\S+/g);
    var sanitizedClassList =
        _.without(classList, DOMRenderer.getActorClassName(actor));
    element.className = sanitizedClassList.join(&#x27; &#x27;);
  }

  // CSS RENDERER OBJECT
  //

  /**
   * &#x60;Rekapi.DOMRenderer&#x60; allows you to animate DOM elements.  This is achieved
   * either by browser-accelerated [CSS &#x60;@keyframe&#x60;
   * animations](https://developer.mozilla.org/en-US/docs/Web/CSS/@keyframes),
   * or by traditional inline style updates on every frame (like how
   * [&#x60;jQuery.fn.animate&#x60;](http://api.jquery.com/animate/) works).  Animations
   * are defined with the same API in either case, but you can gracefully fall
   * back to the inline style approach if CSS &#x60;@keyframe&#x60; animations are not
   * supported by the browser or not preferred.  To render animations with the
   * DOM, just supply any DOM element to the &#x60;{{#crossLink
   * &quot;Rekapi&quot;}}{{/crossLink}}&#x60; constructor.  You may use &#x60;document.body&#x60;, since
   * it is generally always available:
   *
   *     var rekapi = new Rekapi(document.body);
   *     rekapi.renderer instanceof Rekapi.DOMRenderer; // true
   *
   * There are separate APIs for playing inline style animations and CSS
   * &#x60;@keyframe&#x60; animations.  Advantages of playing an animation with CSS
   * &#x60;@keyframes&#x60;:
   *
   *   - Smoother animations in newer browsers.
   *   - The JavaScript thread is freed from performing animation updates,
   *   making it available for other logic.
   *
   * Disadvantages:
   *
   *   - Not all browsers support CSS &#x60;@keyframe&#x60; animations.
   *   - Limited playback control: You can only play and stop an animation, you
   *   cannot jump to or start from a specific point in the timeline.
   *   - Generating the CSS for &#x60;@keyframe&#x60; animations can take a noticeable
   *   amount of time.  This blocks all other logic, including rendering, so
   *   you may have to be clever with how to spend the cycles to do it.
   *   - No &#x60;{{#crossLink &quot;Rekapi/on:method&quot;}}events{{/crossLink}}&#x60; can be
   *   bound to CSS &#x60;@keyframe&#x60; animations.
   *
   * So, the results are a little more predictable and flexible with inline
   * style animations, but CSS &#x60;@keyframe&#x60; may give you better performance.
   * Choose whichever approach makes the most sense for your needs.
   *
   * &#x60;Rekapi.DOMRenderer&#x60; can gracefully fall back to an inline style animation
   * if CSS &#x60;@keyframe&#x60; animations are not supported by the browser:
   *
   *      var rekapi = new Rekapi(document.body);
   *
   *      // Each actor needs a reference to the DOM element it represents
   *      var actor = rekapi.addActor({
   *        context: document.getElementById(&#x27;actor-1&#x27;)
   *      });
   *
   *      actor
   *        .keyframe(0,    { left: &#x27;0px&#x27;   })
   *        .keyframe(1000, { left: &#x27;250px&#x27; }, &#x27;easeOutQuad&#x27;);
   *
   *      // Feature detect for CSS @keyframe support
   *      if (rekapi.renderer.canAnimateWithCSS()) {
   *        // Animate with CSS @keyframes
   *        rekapi.renderer.play();
   *      } else {
   *        // Animate with inline styles instead
   *        rekapi.play();
   *      }
   *
   * ## &#x60;@keyframe&#x60; animations work differently than inline style animations
   *
   * Inline style animations are compatible with all of the playback and
   * timeline control methods defined by &#x60;{{#crossLink
   * &quot;Rekapi&quot;}}{{/crossLink}}&#x60;, such as &#x60;{{#crossLink
   * &quot;Rekapi/play:method&quot;}}{{/crossLink}}&#x60;, &#x60;{{#crossLink
   * &quot;Rekapi/playFrom:method&quot;}}{{/crossLink}}&#x60; and &#x60;{{#crossLink
   * &quot;Rekapi/update:method&quot;}}{{/crossLink}}&#x60;.  CSS &#x60;@keyframe&#x60; playback cannot
   * be controlled in all browsers, so &#x60;Rekapi.DOMRenderer&#x60; defines analogous,
   * renderer-specific CSS playback methods that you should use:
   *
   *   - {{#crossLink &quot;Rekapi.DOMRenderer/play:method&quot;}}{{/crossLink}}
   *   - {{#crossLink &quot;Rekapi.DOMRenderer/isPlaying:method&quot;}}{{/crossLink}}
   *   - {{#crossLink &quot;Rekapi.DOMRenderer/stop:method&quot;}}{{/crossLink}}
   *
   * __Note__: &#x60;Rekapi.DOMRenderer&#x60; is added to the &#x60;{{#crossLink
   * &quot;Rekapi&quot;}}{{/crossLink}}&#x60; instance automatically as &#x60;this.renderer&#x60;,
   * there is no reason to call the constructor yourself in most cases.
   *
   * __[Example](/renderers/dom/sample/play-many-actors.html)__
   *
   * @class Rekapi.DOMRenderer
   * @param {Rekapi} rekapi
   * @constructor
   */
  Rekapi.DOMRenderer = function (rekapi) {
    this.rekapi = rekapi;

    // @private {number}
    this._playTimestamp = null;

    // @private {string}
    this._cachedCSS = null;

    // The HTMLStyleElement that gets injected into the DOM.
    // @private {HTMLStyleElement)
    this._styleElement = null;

    // @private {number}
    this._stopSetTimeoutHandle = null;

    rekapi.on(&#x27;timelineModified&#x27;, _.bind(function () {
      this._cachedCSS = null;
    }, this));

    rekapi.on(&#x27;addActor&#x27;, onAddActor);

    return this;
  };
  var DOMRenderer = Rekapi.DOMRenderer;

  /**
   * @method canAnimateWithCSS
   * @return {boolean} Whether or not the browser supports CSS &#x60;@keyframe&#x60;
   * animations.
   */
  DOMRenderer.prototype.canAnimateWithCSS = function () {
    return !!getVendorPrefix();
  };

  /**
   * Play the Rekapi animation as a CSS &#x60;@keyframe&#x60; animation.
   *
   * Note that this is different from &#x60;{{#crossLink
   * &quot;Rekapi/play:method&quot;}}{{/crossLink}}&#x60;.  This method only applies to CSS
   * &#x60;@keyframe&#x60; animations.
   * @method play
   * @param {number=} opt_iterations How many times the animation should loop.
   * This can be &#x60;null&#x60; or &#x60;0&#x60; if you want to loop the animation endlessly but
   * also specify a value for &#x60;opt_fps&#x60;.
   * @param {number=} opt_fps How many &#x60;@keyframes&#x60; to generate per second of
   * the animation.  A higher value results in a more precise CSS animation,
   * but it will take longer to generate.  The default value is &#x60;30&#x60;.  You
   * should not need to go higher than &#x60;60&#x60;.
   */
  DOMRenderer.prototype.play = function (opt_iterations, opt_fps) {
    if (this.isPlaying()) {
      this.stop();
    }

    var css = this._cachedCSS || this.prerender.apply(this, arguments);
    this._styleElement = injectStyle(this.rekapi, css);
    this._playTimestamp = now();

    if (opt_iterations) {
      var animationLength = (opt_iterations * this.rekapi.getAnimationLength());
      this._stopSetTimeoutHandle = setTimeout(
          _.bind(this.stop, this, true),
          animationLength + INJECTED_STYLE_REMOVAL_BUFFER_MS);
    }

    fireEvent(this.rekapi, &#x27;play&#x27;, _);
  };

  /**
   * Stop a CSS &#x60;@keyframe&#x60; animation.  This also removes any &#x60;&lt;style&gt;&#x60;
   * elements that were dynamically injected into the DOM.
   *
   * Note that this is different from
   * &#x60;{{#crossLink &quot;Rekapi/stop:method&quot;}}{{/crossLink}}&#x60;.  This method only
   * applies to CSS &#x60;@keyframe&#x60; animations.
   * @method stop
   * @param {boolean=} opt_goToEnd If true, skip to the end of the animation.
   * If false or omitted, set inline styles on the actor elements to keep them
   * in their current position.
   */
  DOMRenderer.prototype.stop = function (opt_goToEnd) {
    if (this.isPlaying()) {
      clearTimeout(this._stopSetTimeoutHandle);

      // Forces a style update in WebKit/Presto
      this._styleElement.innerHTML = &#x27;&#x27;;

      document.head.removeChild(this._styleElement);
      this._styleElement = null;

      var updateTime;
      if (opt_goToEnd) {
        updateTime = this.rekapi.getAnimationLength();
      } else {
        updateTime = (now() - this._playTimestamp)
            % this.rekapi.getAnimationLength();
      }

      this.rekapi.update(updateTime);
      fireEvent(this.rekapi, &#x27;stop&#x27;, _);
    }
  };

  /**
   * @method isPlaying
   * @return {boolean} Whether or not a CSS &#x60;@keyframe&#x60; animation is running.
   */
  DOMRenderer.prototype.isPlaying = function () {
    return !!this._styleElement;
  };

  /**
   * Prerender and cache the CSS animation so that it is immediately ready to
   * be used when it is needed in the future.  The function signature is
   * identical to {{#crossLink
   * &quot;Rekapi.DOMRenderer/play:method&quot;}}{{/crossLink}}.  This is necessary to
   * play a CSS animation and will be automatically called for you if you don&#x27;t
   * call it manually, but calling it ahead of time (such as on page load) will
   * prevent any perceived lag when a CSS &#x60;@keyframe&#x60; animation is started.
   * The prerendered animation is cached for reuse until the timeline or a
   * keyframe is modified.
   *
   * @method prerender
   * @param {number=} opt_iterations How many times the animation should loop.
   * This can be &#x60;null&#x60; or &#x60;0&#x60; if you want to loop the animation endlessly but
   * also specify a value for &#x60;opt_fps&#x60;.
   * @param {number=} opt_fps How many &#x60;@keyframes&#x60; to generate per second of
   * the animation.  A higher value results in a more precise CSS animation,
   * but it will take longer to generate.  The default value is &#x60;30&#x60;.  You
   * should not need to go higher than &#x60;60&#x60;.
   * @return {string} The prerendered CSS string.  You likely won&#x27;t need this,
   * as it is also cached internally.
   */
  DOMRenderer.prototype.prerender = function (opt_iterations, opt_fps) {
    return this._cachedCSS = this.toString({
      &#x27;vendors&#x27;: [getVendorPrefix()]
      ,&#x27;fps&#x27;: opt_fps
      ,&#x27;iterations&#x27;: opt_iterations
    });
  };

  /**
   * You can decouple transform components in order to animate each property
   * with its own easing curve:
   *
   *     actor
   *       .keyframe(0, {
   *         translateX: &#x27;0px&#x27;,
   *         translateY: &#x27;0px&#x27;,
   *         rotate: &#x27;0deg&#x27;
   *       })
   *       .keyframe(1500, {
   *         translateX: &#x27;200px&#x27;,
   *         translateY: &#x27;200px&#x27;,
   *         rotate: &#x27;90deg&#x27;
   *       }, {
   *         translateX: &#x27;easeOutExpo&#x27;,
   *         translateY: &#x27;easeInSine&#x27;,
   *         rotate: &#x27;elastic&#x27;
   *       });
   *
   * CSS transform string components are order-dependent, but JavaScript object
   * properties have an unpredictable order.  Rekapi must combine transform
   * properties supplied to &#x60;{{#crossLink
   * &quot;Rekapi.Actor/keyframe:method&quot;}}{{/crossLink}}&#x60; (as shown above) into a
   * single string when it renders each frame.  This method lets you change
   * that order from the default.  The supported array values for
   * &#x60;orderedTransforms&#x60; are:
   *
   * - &#x60;translateX&#x60;
   * - &#x60;translateY&#x60;
   * - &#x60;translateZ&#x60;
   * - &#x60;scale&#x60;
   * - &#x60;scaleX&#x60;
   * - &#x60;scaleY&#x60;
   * - &#x60;rotate&#x60;
   * - &#x60;skewX&#x60;
   * - &#x60;skewY&#x60;
   *
   * If you prefer a more standards-oriented approach, Rekapi also supports
   * combining the transform components yourself:
   *
   *     actor
   *       .keyframe(0, {
   *         transform: &#x27;translateX(0px) translateY(0px) rotate(0deg)&#x27;
   *       })
   *       .keyframe(1500, {
   *         transform: &#x27;translateX(200px) translateY(200px) rotate(90deg)&#x27;
   *       }, {
   *         transform: &#x27;easeOutExpo easeInSine elastic&#x27;
   *       });
   *
   * This example and the one above it are equivalent.
   *
   * __Note__: The decoupled form of &#x60;transform&#x60; animations is not supported in
   * CSS &#x60;@keyframe&#x60; animations, only inline style animations.  This is due to
   * the tightly-coupled nature of the CSS &#x60;@keyframes&#x60; spec.  If you intend to
   * play a CSS-based &#x60;@keyframe&#x60; animation, __do not__ use the non-standard
   * decoupled API form for &#x60;transform&#x60; properties.
   *
   * @method setActorTransformOrder
   * @param {Rekapi.Actor} actor
   * @param {Array(string)} orderedTransforms The array of transform names.
   * @return {Rekapi}
   */
  DOMRenderer.prototype.setActorTransformOrder =
      function (actor, orderedTransforms) {
    // TODO: Document this better...
    var unknownFunctions = _.reject(orderedTransforms, isTransformFunction);

    if (unknownFunctions.length) {
      throw &#x27;Unknown or unsupported transform functions: &#x27; +
        unknownFunctions.join(&#x27;, &#x27;);
    }
    // Ignore duplicate transform function names in the array
    actor._transformOrder = _.uniq(orderedTransforms);

    return this.rekapi;
  };

  /**
   * @method getActorClassName
   * @param {Rekapi.Actor} actor
   * @return {string} The default CSS class that is targeted by &#x60;{{#crossLink
   * &quot;Rekapi.DOMRenderer/toString:method&quot;}}{{/crossLink}}&#x60; if a custom class is
   * not specified.  This may be useful for getting a standard and consistent
   * CSS class name for an actor&#x27;s DOM element.
   */
  DOMRenderer.getActorClassName = function (actor) {
    return &#x27;actor-&#x27; + actor.id;
  };

  // TODO: Don&#x27;t redefine toString with a method that takes parameters.  Name
  // this something else and deprecate DOMRenderer#toString.
  /**
   * Converts Rekapi animations to CSS &#x60;@keyframes&#x60;.
   * @method toString
   * @param {Object=} opts
   *   * __vendors__ _(Array(string))_: Defaults to &#x60;[&#x27;w3&#x27;]&#x60;.  The browser vendors you
   *   want to support. Valid values are:
   *     * &#x60;&#x27;microsoft&#x27;&#x60;
   *     * &#x60;&#x27;mozilla&#x27;&#x60;
   *     * &#x60;&#x27;opera&#x27;&#x60;
   *     * &#x60;&#x27;w3&#x27;&#x60;
   *     * &#x60;&#x27;webkit&#x27;&#x60;
   *
   *
   *   * __fps__ _(number)_: Defaults to 30.  Defines the number of CSS
   *   &#x60;@keyframe&#x60; frames rendered per second of an animation.  CSS &#x60;@keyframes&#x60;
   *   are comprised of a series of explicitly defined steps, and more steps
   *   will allow for a more complex animation.  More steps will also result in
   *   a larger CSS string, and more time needed to generate the string.
   *   * __name__ _(string)_: Define a custom name for your animation.  This
   *   becomes the class name targeted by the generated CSS.  The default value
   *   is determined by a call to {{#crossLink
   *   &quot;Rekapi.DOMRenderer/getActorClassName:method&quot;}}{{/crossLink}}.
   *   * __isCentered__ _(boolean)_: If &#x60;true&#x60;, the generated CSS will contain
   *   &#x60;transform-origin: 0 0;&#x60;, which centers the DOM element along the path of
   *   motion.  If &#x60;false&#x60; or omitted, no &#x60;transform-origin&#x60; rule is specified
   *   and the element is aligned to the path of motion with its top-left
   *   corner.
   *   * __iterations__ _(number)_: How many times the generated animation
   *   should repeat.  If omitted, the animation will loop indefinitely.
   * @return {string}
   */
  Rekapi.DOMRenderer.prototype.toString = function (opts) {
    opts = opts || {};
    var animationCSS = [];

    _.each(this.rekapi.getAllActors(), function (actor) {
      if (actor.context.nodeType === 1) {
        animationCSS.push(getActorCSS(actor, opts));
      }
    });

    return animationCSS.join(&#x27;\n&#x27;);
  };

  // DOMRenderer.prototype.toString-SPECIFIC CODE
  //

  // CONSTANTS
  //

  var DEFAULT_FPS = 30;
  var TRANSFORM_TOKEN = &#x27;TRANSFORM&#x27;;
  var VENDOR_TOKEN = &#x27;VENDOR&#x27;;
  var VENDOR_PREFIXES = {
    &#x27;microsoft&#x27;: &#x27;-ms-&#x27;
    ,&#x27;mozilla&#x27;: &#x27;-moz-&#x27;
    ,&#x27;opera&#x27;: &#x27;-o-&#x27;
    ,&#x27;w3&#x27;: &#x27;&#x27;
    ,&#x27;webkit&#x27;: &#x27;-webkit-&#x27;
  };
  var BEZIERS = {
    linear: &#x27;.25,.25,.75,.75&#x27;
    ,easeInQuad: &#x27;.55,.085,.68,.53&#x27;
    ,easeInCubic: &#x27;.55,.055,.675,.19&#x27;
    ,easeInQuart: &#x27;.895,.03,.685,.22&#x27;
    ,easeInQuint: &#x27;.755,.05,.855,.06&#x27;
    ,easeInSine: &#x27;.47,0,.745,.715&#x27;
    ,easeInExpo: &#x27;.95,.05,.795,.035&#x27;
    ,easeInCirc: &#x27;.6,.04,.98, .335&#x27;
    ,easeOutQuad: &#x27;.25,.46,.45,.94&#x27;
    ,easeOutCubic: &#x27;.215,.61,.355,1&#x27;
    ,easeOutQuart: &#x27;.165,.84,.44,1&#x27;
    ,easeOutQuint: &#x27;.23,1,.32,1&#x27;
    ,easeOutSine: &#x27;.39,.575,.565,1&#x27;
    ,easeOutExpo: &#x27;.19,1,.22,1&#x27;
    ,easeOutCirc: &#x27;.075,.82,.165,1&#x27;
    ,easeInOutQuad: &#x27;.455,.03,.515,.955&#x27;
    ,easeInOutCubic: &#x27;.645,.045,.355,1&#x27;
    ,easeInOutQuart: &#x27;.77,0,.175,1&#x27;
    ,easeInOutQuint: &#x27;.86,0.07,1&#x27;
    ,easeInOutSine: &#x27;.445,.05,.55,.95&#x27;
    ,easeInOutExpo: &#x27;1,0,0,1&#x27;
    ,easeInOutCirc: &#x27;.785,.135,.15,.86&#x27;
  };

  // TEMPLATES
  //

  /*!
   * [0]: vendor
   * [1]: animation name
   * [2]: keyframes
   */
  var KEYFRAME_TEMPLATE = [
    &#x27;@%skeyframes %s-keyframes {&#x27;
    ,&#x27;%s&#x27;
    ,&#x27;}&#x27;
  ].join(&#x27;\n&#x27;);

  /*!
   * [0] class name
   * [1] class attributes
   */
  var CLASS_BOILERPLATE = [
    &#x27;.%s {&#x27;
    ,&#x27;%s&#x27;
    ,&#x27;}&#x27;
  ].join(&#x27;\n&#x27;);

  /*!
   * Creates the CSS &#x60;@keyframes&#x60; for an individual actor.
   * @param {Rekapi.Actor} actor
   * @param {Object=} opts Same as opts for Rekapi.prototype.toCSS.
   * @return {string}
   */
  function getActorCSS (actor, opts) {
    opts = opts || {};
    var actorCSS = [];
    var animName = opts.name || DOMRenderer.getActorClassName(actor);
    var fps = opts.fps || DEFAULT_FPS;
    var steps = Math.ceil((actor.rekapi.getAnimationLength() / 1000) * fps);
    var combineProperties = !canOptimizeAnyKeyframeProperties(actor);
    var actorClass = generateCSSClass(
        actor, animName, combineProperties, opts.vendors, opts.iterations,
        opts.isCentered);
    var boilerplatedKeyframes = generateBoilerplatedKeyframes(
        actor, animName, steps, combineProperties, opts.vendors);

    actorCSS.push(actorClass);
    actorCSS.push(boilerplatedKeyframes);

    return actorCSS.join(&#x27;\n&#x27;);
  }

  // toString-SPECIFIC PRIVATE UTILITY FUNCTIONS
  //

  /*!
   * @param {Rekapi.Actor} actor
   * @param {string} animName
   * @param {number} steps
   * @param {boolean} combineProperties
   * @param {Array.&lt;string&gt;=} opt_vendors
   * @return {string}
   */
  function generateBoilerplatedKeyframes (
      actor, animName, steps, combineProperties, opt_vendors) {

    var trackNames = actor.getTrackNames();
    var cssTracks = [];

    if (combineProperties) {
      cssTracks.push(generateCombinedActorKeyframes(actor, steps));
    } else {
      _.each(trackNames, function (trackName) {
        cssTracks.push(
          generateActorKeyframes(actor, steps, trackName));
      });
    }

    var boilerplatedKeyframes = [];

    if (combineProperties) {
      boilerplatedKeyframes.push(applyVendorBoilerplates(
        cssTracks[0], (animName), opt_vendors));
    } else {
      _.each(trackNames, function (trackName, i) {
        boilerplatedKeyframes.push(applyVendorBoilerplates(
          cssTracks[i], (animName + &#x27;-&#x27; + trackName), opt_vendors));
      });
    }

    boilerplatedKeyframes = boilerplatedKeyframes.join(&#x27;\n&#x27;);

    return boilerplatedKeyframes;
  }

  /*!
   * @param {string} toKeyframes Generated keyframes to wrap in boilerplates
   * @param {string} animName
   * @param {Array.&lt;string&gt;=} opt_vendors Vendor boilerplates to be applied.
   *     Should be any of the values in Rekapi.util.VENDOR_PREFIXES.
   * @return {string}
   */
  function applyVendorBoilerplates (toKeyframes, animName, opt_vendors) {
    opt_vendors = opt_vendors || [&#x27;w3&#x27;];
    var renderedKeyframes = [];

    _.each(opt_vendors, function (vendor) {
      var renderedChunk = printf(KEYFRAME_TEMPLATE,
          [VENDOR_PREFIXES[vendor], animName, toKeyframes]);
      var prefixedKeyframes =
          applyVendorPropertyPrefixes(renderedChunk, vendor);
      renderedKeyframes.push(prefixedKeyframes);
    });

    return renderedKeyframes.join(&#x27;\n&#x27;);
  }

  /*!
   * @param {string} keyframes
   * @param {vendor} vendor
   * @return {string}
   */
  function applyVendorPropertyPrefixes (keyframes, vendor) {
    var transformRegExp = new RegExp(TRANSFORM_TOKEN, &#x27;g&#x27;);
    var prefixedTransformKey = VENDOR_PREFIXES[vendor] + &#x27;transform&#x27;;
    var generalPrefixRegExp = new RegExp(VENDOR_TOKEN, &#x27;g&#x27;);
    var generalPrefixedKey = VENDOR_PREFIXES[vendor];
    var prefixedKeyframes = keyframes
        .replace(generalPrefixRegExp, generalPrefixedKey)
        .replace(transformRegExp, prefixedTransformKey);

    return prefixedKeyframes;
  }

  /*!
   * @param {Rekapi.Actor} actor
   * @param {string} animName
   * @param {boolean} combineProperties
   * @param {Array.&lt;string&gt;=} opt_vendors
   * @param {number|string=} opt_iterations
   * @param {boolean=} opt_isCentered
   * @return {string}
   */
  function generateCSSClass (
      actor, animName, combineProperties, opt_vendors, opt_iterations,
      opt_isCentered) {

    opt_vendors = opt_vendors || [&#x27;w3&#x27;];
    var classAttrs = [];
    var vendorAttrs;

    _.each(opt_vendors, function (vendor) {
      vendorAttrs = generateCSSAnimationProperties(
          actor, animName, vendor, combineProperties, opt_iterations,
          opt_isCentered);
      classAttrs.push(vendorAttrs);
    });

    var boilerplatedClass = printf(CLASS_BOILERPLATE
        ,[animName, classAttrs.join(&#x27;\n&#x27;)]);

    return boilerplatedClass;
  }

  /*!
   * @param {Rekapi.Actor} actor
   * @param {string} animName
   * @param {string} vendor
   * @param {boolean} combineProperties
   * @param {number|string=} opt_iterations
   * @param {boolean=} opt_isCentered
   * @return {string}
   */
  function generateCSSAnimationProperties (
      actor, animName, vendor, combineProperties, opt_iterations,
      opt_isCentered) {
    var generatedProperties = [];
    var prefix = VENDOR_PREFIXES[vendor];

    generatedProperties.push(generateAnimationNameProperty(
          actor, animName, prefix, combineProperties));
    generatedProperties.push(
        generateAnimationDurationProperty(actor, prefix));
    generatedProperties.push(generateAnimationDelayProperty(actor, prefix));
    generatedProperties.push(generateAnimationFillModeProperty(prefix));
    generatedProperties.push(generateAnimationTimingFunctionProperty(prefix));
    generatedProperties.push(generateAnimationIterationProperty(
        actor.rekapi, prefix, opt_iterations));

    if (opt_isCentered) {
      generatedProperties.push(generateAnimationCenteringRule(prefix));
    }

    return generatedProperties.join(&#x27;\n&#x27;);
  }

  /*!
   * @param {Rekapi.Actor} actor
   * @param {string} animName
   * @param {string} prefix
   * @param {boolean} combineProperties
   * @return {string}
   */
  function generateAnimationNameProperty (
      actor, animName, prefix, combineProperties) {

    var animationName = printf(&#x27;  %sanimation-name:&#x27;, [prefix]);

    var tracks = actor.getTrackNames();

    if (combineProperties) {
      animationName += printf(&#x27; %s-keyframes;&#x27;, [animName]);
    } else {
      _.each(tracks, function (trackName) {
        animationName += printf(&#x27; %s-%s-keyframes,&#x27;, [animName, trackName]);
      });
      animationName = animationName.slice(0, animationName.length - 1);
      animationName += &#x27;;&#x27;;
    }

    return animationName;
  }

  /*!
   * @param {Rekapi.Actor} actor
   * @param {string} animName
   * @return {string}
   */
  function generateAnimationDurationProperty (actor, prefix) {
    return printf(&#x27;  %sanimation-duration: %sms;&#x27;
        ,[prefix, actor.getEnd() - actor.getStart()]);
  }

  /*!
   * @param {Rekapi.Actor} actor
   * @param {number|string} delay
   * @return {string}
   */
  function generateAnimationDelayProperty (actor, prefix) {
    return printf(&#x27;  %sanimation-delay: %sms;&#x27;, [prefix, actor.getStart()]);
  }

  /*!
   * @param {string} prefix
   * @return {string}
   */
  function generateAnimationFillModeProperty (prefix) {
    return printf(&#x27;  %sanimation-fill-mode: forwards;&#x27;, [prefix]);
  }

  /*!
   * @param {string} prefix
   * @return {string}
   */
  function generateAnimationTimingFunctionProperty (prefix) {
    return printf(&#x27;  %sanimation-timing-function: linear;&#x27;, [prefix]);
  }

  /*!
   * @param {Rekapi} rekapi
   * @param {string} prefix
   * @param {number|string=} opt_iterations
   * @return {string}
   */
  function generateAnimationIterationProperty (rekapi, prefix, opt_iterations) {
    var iterationCount;
    if (opt_iterations) {
      iterationCount = opt_iterations;
    } else {
      iterationCount = rekapi._timesToIterate === -1
        ? &#x27;infinite&#x27;
        : rekapi._timesToIterate;
    }

    var ruleTemplate = &#x27;  %sanimation-iteration-count: %s;&#x27;;

    return printf(ruleTemplate, [prefix, iterationCount]);
  }

  /*!
   * @param {string} prefix
   * @return {string}
   */
  function generateAnimationCenteringRule (prefix) {
    return printf(&#x27;  %stransform-origin: 0 0;&#x27;, [prefix]);
  }

  // OPTIMIZED OUTPUT GENERATOR FUNCTIONS
  //

  /*!
   * @param {Rekapi.KeyframeProperty} property
   * @return {boolean}
   */
  function canOptimizeKeyframeProperty (property) {
    var canOptimize = false;
    var nextProperty = property.nextProperty;

    if (nextProperty) {
      if (isSegmentAWait(property, nextProperty)) {
        return true;
      }

      var easingChunks = nextProperty.easing.split(&#x27; &#x27;);

      var i = 0, len = easingChunks.length;
      var previousChunk = easingChunks[0];
      var currentChunk;
      for (i; i &lt; len; i++) {
        currentChunk = easingChunks[i];
        if (!(BEZIERS[currentChunk])
            || previousChunk !== currentChunk) {
          canOptimize = false;
          break;
        } else {
          canOptimize = true;
        }

        previousChunk = currentChunk;
      }
    }

    return canOptimize;
  }

  /*!
   * @param {Rekapi.KeyframeProperty} property
   * @param {Rekapi.KeyframeProperty} nextProperty
   * @return {boolean}
   */
  function isSegmentAWait (property, nextProperty) {
    if (property.name === nextProperty.name &amp;&amp;
        property.value === nextProperty.value) {
      return true;
    }

    return false;
  }

  /*!
   * @param {Rekapi.Actor} actor
   * @return {boolean}
   */
  function canOptimizeAnyKeyframeProperties (actor) {
    return _.any(actor._keyframeProperties, canOptimizeKeyframeProperty);
  }

  /*!
   * @param {Rekapi.KeyframeProperty} property
   * @param {number} fromPercent
   * @param {number} toPercent
   * @return {string}
   */
  function generateOptimizedKeyframeSegment (
      property, fromPercent, toPercent) {

    var accumulator = [];
    var generalName = property.name;

    if (property.name === &#x27;transform&#x27;) {
      generalName = TRANSFORM_TOKEN;
    }

    var easingFormula = BEZIERS[property.nextProperty.easing.split(&#x27; &#x27;)[0]];
    var timingFnChunk = printf(&#x27;cubic-bezier(%s)&#x27;, [easingFormula]);

    var adjustedFromPercent = isInt(fromPercent) ?
        fromPercent : fromPercent.toFixed(2);
    var adjustedToPercent = isInt(toPercent) ?
        toPercent : toPercent.toFixed(2);

    accumulator.push(printf(&#x27;  %s% {%s:%s;%sanimation-timing-function: %s;}&#x27;,
          [adjustedFromPercent, generalName, property.value, VENDOR_TOKEN
          ,timingFnChunk]));
    accumulator.push(printf(&#x27;  %s% {%s:%s;}&#x27;,
          [adjustedToPercent, generalName, property.nextProperty.value]));

    return accumulator.join(&#x27;\n&#x27;);
  }

  // UN-OPTIMIZED OUTPUT GENERATOR FUNCTIONS
  //

  /*!
   * @param {Rekapi.Actor} actor
   * @param {number} steps
   * @param {string} track
   * @return {string}
   */
  function generateActorKeyframes (actor, steps, track) {
    var accumulator = [];
    var actorEnd = actor.getEnd();
    var actorStart = actor.getStart();
    var actorLength = actor.getLength();
    var leadingWait = simulateLeadingWait(actor, track, actorStart);

    if (leadingWait) {
      accumulator.push(leadingWait);
    }

    var previousSegmentWasOptimized = false;
    _.each(actor._propertyTracks[track], function (prop, propName) {
      var fromPercent = calculateStepPercent(prop, actorStart, actorLength);
      var nextProp = prop.nextProperty;

      var toPercent, increments, incrementSize;
      if (nextProp) {
        toPercent = calculateStepPercent(nextProp, actorStart, actorLength);
        var delta = toPercent - fromPercent;
        increments = Math.floor((delta / 100) * steps) || 1;
        incrementSize = delta / increments;
      } else {
        toPercent = 100;
        increments = 1;
        incrementSize = 1;
      }

      var trackSegment;
      if (nextProp &amp;&amp; isSegmentAWait(prop, nextProp)) {
        trackSegment = generateActorTrackWaitSegment(
            actor, actorStart, prop, nextProp, fromPercent, toPercent);

        if (previousSegmentWasOptimized) {
          trackSegment.shift();
        }

        previousSegmentWasOptimized = false;

      } else if (canOptimizeKeyframeProperty(prop)) {
        trackSegment = generateOptimizedKeyframeSegment(
            prop, fromPercent, toPercent);

        // If this and the previous segment are optimized, remove the
        // destination keyframe of the previous step.  The starting keyframe of
        // the newest segment makes it redundant.
        if (previousSegmentWasOptimized) {
          var accumulatorLength = accumulator.length;
          var previousTrackSegment = accumulator[accumulatorLength - 1];
          var optimizedPreviousTrackSegment =
              previousTrackSegment.split(&#x27;\n&#x27;)[0];
          accumulator[accumulatorLength - 1] = optimizedPreviousTrackSegment;
        }

        previousSegmentWasOptimized = true;
      } else {
        trackSegment = generateActorTrackSegment(
            actor, increments, incrementSize, actorStart, fromPercent, prop);

        if (previousSegmentWasOptimized) {
          trackSegment.shift();
        }

        if (trackSegment.length) {
          trackSegment = trackSegment.join(&#x27;\n&#x27;);
        }

        previousSegmentWasOptimized = false;
      }

      if (trackSegment.length) {
        accumulator.push(trackSegment);
      }
    });

    var trailingWait =
        simulateTrailingWait(actor, track, actorStart, actorEnd);

    if (trailingWait) {
      accumulator.push(trailingWait);
    }

    return accumulator.join(&#x27;\n&#x27;);
  }

  /*!
   * @param {Rekapi.Actor} actor
   * @param {number} steps
   * @return {string}
   */
  function generateCombinedActorKeyframes (actor, steps) {
    return generateActorTrackSegment(
        actor, steps + 1, 100 / steps, 0, 0).join(&#x27;\n&#x27;);
  }

  /*!
   * @param {Rekapi.Actor} actor
   * @param {string} track
   * @param {number} actorStart
   * @return {string|undefined}
   */
  function simulateLeadingWait (actor, track, actorStart) {
    var firstProp = actor._propertyTracks[track][0];

    if (typeof firstProp !== &#x27;undefined&#x27;
        &amp;&amp; firstProp.millisecond !== actorStart) {
      var fakeFirstProp = generateActorTrackSegment(
          actor, 1, 1, firstProp.millisecond, 0, firstProp);
      return fakeFirstProp.join(&#x27;\n&#x27;);
    }
  }

  /*!
   * @param {Rekapi.Actor} actor
   * @param {string} track
   * @param {number} actorStart
   * @param {number} actorEnd
   * @return {string|undefined}
   */
  function simulateTrailingWait (actor, track, actorStart, actorEnd) {
    var lastProp = _.last(actor._propertyTracks[track]);

    if (typeof lastProp !== &#x27;undefined&#x27;
        &amp;&amp; lastProp.millisecond !== actorEnd) {
      var fakeLastProp = generateActorTrackSegment(
          actor, 1, 1, actorStart, 100, lastProp);
      return fakeLastProp.join(&#x27;\n&#x27;);
    }
  }

  /*!
   * @param {Rekapi.KeyframeProperty} property
   * @param {number} actorStart
   * @param {number} actorLength
   * @return {number}
   */
  function calculateStepPercent (property, actorStart, actorLength) {
    return ((property.millisecond - actorStart) / actorLength) * 100;
  }

  /*!
   * @param {Rekapi.Actor} actor
   * @param {number} increments
   * @param {number} incrementSize
   * @param {number} actorStart
   * @param {number} fromPercent
   * @param {Rekapi.KeyframeProperty=} opt_fromProp
   * @return {Array.&lt;string&gt;}
   */
  function generateActorTrackSegment (
      actor, increments, incrementSize, actorStart, fromPercent,
      opt_fromProp) {

    var accumulator = [];
    var actorLength = actor.getLength();
    var i, adjustedPercent, stepPrefix;

    for (i = 0; i &lt; increments; i++) {
      adjustedPercent = fromPercent + (i * incrementSize);
      actor._updateState(
          ((adjustedPercent / 100) * actorLength) + actorStart);
      stepPrefix = +adjustedPercent.toFixed(2) + &#x27;% &#x27;;

      if (opt_fromProp) {
        accumulator.push(
            &#x27;  &#x27; + stepPrefix + serializeActorStep(actor, opt_fromProp.name));
      } else {
        accumulator.push(&#x27;  &#x27; + stepPrefix + serializeActorStep(actor));
      }
    }

    return accumulator;
  }

  /*!
   * @param {Rekapi.Actor} actor
   * @param {number} actorStart
   * @param {Rekapi.KeyframeProperty} fromProp
   * @param {Rekapi.KeyframeProperty} toProp
   * @param {number} fromPercent
   * @param {number} toPercent
   * @return {Array.&lt;string&gt;}
   */
  function generateActorTrackWaitSegment (
      actor, actorStart, fromProp, toProp, fromPercent, toPercent) {
    var segment = generateActorTrackSegment(
        actor, 1, toPercent - fromPercent, actorStart, fromPercent, fromProp);
    return segment;
  }

  /*!
   * @param {Rekapi.Actor} actor
   * @param {string=} opt_targetProp
   * @return {string}
   */
  function serializeActorStep (actor, opt_targetProp) {
    var serializedProps = [&#x27;{&#x27;];

    var propsToSerialize;
    if (opt_targetProp) {
      propsToSerialize = {};

      var currentPropState = actor.get()[opt_targetProp];
      if (typeof currentPropState !== &#x27;undefined&#x27;) {
        propsToSerialize[opt_targetProp] = currentPropState;
      }
    } else {
      propsToSerialize = actor.get();
    }

    var printVal;
    _.each(propsToSerialize, function (val, key) {
      printVal = val;
      var printKey = key;

      if (key === &#x27;transform&#x27;) {
        printKey = TRANSFORM_TOKEN;
      }

      serializedProps.push(printKey + &#x27;:&#x27; + printVal + &#x27;;&#x27;);
    });

    serializedProps.push(&#x27;}&#x27;);
    return serializedProps.join(&#x27;&#x27;);
  }

  // Exposes helper functions for unit testing.  Gets compiled away in build
  // process.
  if (REKAPI_DEBUG) {
    Rekapi._private.cssRenderer = {
      &#x27;TRANSFORM_TOKEN&#x27;: TRANSFORM_TOKEN
      ,&#x27;VENDOR_TOKEN&#x27;: VENDOR_TOKEN
      ,&#x27;applyVendorBoilerplates&#x27;: applyVendorBoilerplates
      ,&#x27;applyVendorPropertyPrefixes&#x27;: applyVendorPropertyPrefixes
      ,&#x27;generateBoilerplatedKeyframes&#x27;: generateBoilerplatedKeyframes
      ,&#x27;generateCSSClass&#x27;: generateCSSClass
      ,&#x27;generateCSSAnimationProperties&#x27;: generateCSSAnimationProperties
      ,&#x27;generateActorKeyframes&#x27;: generateActorKeyframes
      ,&#x27;generateActorTrackSegment&#x27;: generateActorTrackSegment
      ,&#x27;serializeActorStep&#x27;: serializeActorStep
      ,&#x27;generateAnimationNameProperty&#x27;: generateAnimationNameProperty
      ,&#x27;generateAnimationDurationProperty&#x27;: generateAnimationDurationProperty
      ,&#x27;generateAnimationDelayProperty&#x27;: generateAnimationDelayProperty
      ,&#x27;generateAnimationFillModeProperty&#x27;: generateAnimationFillModeProperty
      ,&#x27;generateAnimationTimingFunctionProperty&#x27;:
          generateAnimationTimingFunctionProperty
      ,&#x27;generateAnimationIterationProperty&#x27;: generateAnimationIterationProperty
      ,&#x27;generateAnimationCenteringRule&#x27;: generateAnimationCenteringRule
      ,&#x27;simulateLeadingWait&#x27;: simulateLeadingWait
      ,&#x27;simulateTrailingWait&#x27;: simulateTrailingWait
      ,&#x27;canOptimizeKeyframeProperty&#x27;: canOptimizeKeyframeProperty
      ,&#x27;canOptimizeAnyKeyframeProperties&#x27;: canOptimizeAnyKeyframeProperties
      ,&#x27;generateOptimizedKeyframeSegment&#x27;: generateOptimizedKeyframeSegment
      ,&#x27;getActorCSS&#x27;: getActorCSS
    };
  }
});

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
