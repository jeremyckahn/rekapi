<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/rekapi.actor.js - Rekapi</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../../../demo/img/rekapi-logo-200.png" title="Rekapi"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.7.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Rekapi.html">Rekapi</a></li>
            
                <li><a href="../classes/Rekapi.Actor.html">Rekapi.Actor</a></li>
            
                <li><a href="../classes/Rekapi.CanvasRenderer.html">Rekapi.CanvasRenderer</a></li>
            
                <li><a href="../classes/Rekapi.DOMRenderer.html">Rekapi.DOMRenderer</a></li>
            
                <li><a href="../classes/Rekapi.KeyframeProperty.html">Rekapi.KeyframeProperty</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src/rekapi.actor.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
rekapiModules.push(function (context) {

  &#x27;use strict&#x27;;

  var DEFAULT_EASING = &#x27;linear&#x27;;
  var Rekapi = context.Rekapi;
  var Tweenable = Rekapi.Tweenable;
  var _ = Rekapi._;

  /*!
   * @param {Object} obj
   * @return {number} millisecond
   */
  function getMillisecond(obj) {
    return obj.millisecond;
  }

  /*!
   * @param {Object} obj
   * @return {number} millisecond
   */
  function get_Millisecond(obj) {
    return obj._millisecond;
  }

  /*!
   * @param {Rekapi.Actor} actor
   * @param {string} event
   * @param {any=} opt_data
   */
  function fireRekapiEventForActor (actor, event, opt_data) {
    if (actor.rekapi) {
      fireEvent(actor.rekapi, event, _, opt_data);
    }
  }

  /*!
   * Retrieves the most recent property cache entry for a given millisecond.
   * @param {Rekapi.Actor} actor
   * @param {number} millisecond
   * @return {Object|undefined} undefined if there is no property cache for
   * the millisecond, i.e. an empty cache.
   */
  function getPropertyCacheEntryForMillisecond (actor, millisecond) {
    var cache = actor._timelinePropertyCache;

    var index = _.sortedIndex(cache, { _millisecond: millisecond }, get_Millisecond);

    if (cache[index] &amp;&amp; cache[index]._millisecond === millisecond) {
      return cache[index];
    } else if (index &gt;= 1) {
      return cache[index - 1];
    } else {
      return cache[0];
    }
  }

  /*!
   * Gets all of the current and most recent Rekapi.KeyframeProperties for a
   * given millisecond.
   * @param {Rekapi.Actor} actor
   * @param {number} forMillisecond
   * @return {Object} An Object containing Rekapi.KeyframeProperties
   */
  function getLatestProperties (actor, forMillisecond) {
    var latestProperties = {};

    _.each(actor._propertyTracks, function (propertyTrack, propertyName) {
      var index = insertionPointInTrack(propertyTrack, forMillisecond);
      if (propertyTrack[index] &amp;&amp; propertyTrack[index].millisecond === forMillisecond) {
        // Found forMillisecond exactly.
        latestProperties[propertyName] = propertyTrack[index];
      } else if (index &gt;= 1) {
        // forMillisecond doesn&#x27;t exist in the track and index is
        // where we&#x27;d need to insert it, therefore the previous
        // keyframe is the most recent one before forMillisecond.
        latestProperties[propertyName] = propertyTrack[index - 1];
      } else {
        // Return first property.  This is after forMillisecond.
        latestProperties[propertyName] = propertyTrack[0];
      }
    });

    return latestProperties;
  }

  /*!
   * Search property track &#x60;track&#x60; and find the correct index to insert a
   * new element at &#x60;millisecond&#x60;.
   * @param {Array(Rekapi.KeyframeProperty)} track
   * @param {number} millisecond
   * @return {number} index
   */
  function insertionPointInTrack (track, millisecond) {
    return _.sortedIndex(track, { millisecond: millisecond }, getMillisecond);
  }

  /*!
   * Search property track &#x60;track&#x60; and find the index to the element that is
   * at &#x60;millisecond&#x60;.  Returns &#x60;undefined&#x60; if not found.
   * @param {Array(Rekapi.KeyframeProperty)} track
   * @param {number} millisecond
   * @return {number|undefined} index or undefined if not present
   */
  function propertyIndexInTrack (track, millisecond) {
    var index = insertionPointInTrack(track, millisecond);
    if (track[index] &amp;&amp; track[index].millisecond === millisecond) {
      return index;
    }
  }

  /*!
   * Mark the cache of internal KeyframeProperty data as invalid.  The cache
   * will be rebuilt on the next call to ensurePropertyCacheValid.
   * @param {Rekapi.Actor}
   */
  function invalidatePropertyCache (actor) {
    actor._timelinePropertyCacheValid = false;
  }

  /*!
   * Empty out and rebuild the cache of internal KeyframeProperty data if it
   * has been marked as invalid.
   * @param {Rekapi.Actor}
   */
  function ensurePropertyCacheValid (actor) {
    if (actor._timelinePropertyCacheValid) {
      return;
    }

    actor._timelinePropertyCache = [];
    actor._timelineFunctionCache = [];
    var timelinePropertyCache = actor._timelinePropertyCache;

    // Build the cache map
    var props = _.values(actor._keyframeProperties);
    props.sort(function (a, b) { return a.millisecond - b.millisecond });

    var curCacheEntry = getLatestProperties(actor, 0);
    curCacheEntry._millisecond = 0;
    timelinePropertyCache.push(curCacheEntry);
    _.each(props, function (property) {
      if (property.millisecond !== curCacheEntry._millisecond) {
        curCacheEntry = _.clone(curCacheEntry);
        curCacheEntry._millisecond = property.millisecond;
        timelinePropertyCache.push(curCacheEntry);
      }
      curCacheEntry[property.name] = property;
      if (property.name === &#x27;function&#x27;) {
        actor._timelineFunctionCache.push(property);
      }
    });

    actor._timelinePropertyCacheValid = true;
  }

  /*!
   * Remove any property tracks that are empty.
   *
   * @param {Rekapi.Actor} actor
   */
  function removeEmptyPropertyTracks (actor) {
    var trackNameRemovalList = [];
    var propertyTracks = actor._propertyTracks;

    _.each(propertyTracks, function (propertyTrack, trackName) {
      if (!propertyTrack.length) {
        trackNameRemovalList.push(trackName);
      }
    });

    _.each(trackNameRemovalList, function (trackName) {
      delete propertyTracks[trackName];
      fireRekapiEventForActor(actor, &#x27;removeKeyframePropertyTrack&#x27;, trackName);
    });
  }

  /*!
   * Stably sort all of the property tracks of an actor
   * @param {Rekapi.Actor} actor
   */
  function sortPropertyTracks (actor) {
    _.each(actor._propertyTracks, function (propertyTrack, trackName) {
      actor._propertyTracks[trackName] = _.sortBy(propertyTrack, &#x27;millisecond&#x27;);
      propertyTrack = actor._propertyTracks[trackName];

      _.each(propertyTrack, function (keyframeProperty, i) {
        keyframeProperty.linkToNext(propertyTrack[i + 1]);
      });
    });
  }

  /*!
   * Updates internal Rekapi and Actor data after a KeyframeProperty
   * modification method is called.
   *
   * TODO: This should be moved to core.
   *
   * @param {Rekapi.Actor} actor
   */
  function cleanupAfterKeyframeModification (actor) {
    sortPropertyTracks(actor);
    invalidatePropertyCache(actor);

    if (actor.rekapi) {
      invalidateAnimationLength(actor.rekapi);
    }

    fireRekapiEventForActor(actor, &#x27;timelineModified&#x27;);
  }

  /**
   * An actor represents an individual component of an animation.  An animation
   * may have one or many actors.
   *
   * @class Rekapi.Actor
   * @param {Object=} opt_config Valid properties:
   *   - __context__ (_Object|CanvasRenderingContext2D|HTMLElement_): The
   *   rendering context for this actor. If omitted, this Actor gets the parent
   *   &#x60;{{#crossLink &quot;Rekapi&quot;}}{{/crossLink}}&#x60; instance&#x27;s &#x60;context&#x60; when it is
   *   added with &#x60;{{#crossLink &quot;Rekapi/addActor:method&quot;}}{{/crossLink}}&#x60;.
   *   - __setup__ (_Function_): A function that gets called when the actor is
   *     added to an animation with
   *     &#x60;{{#crossLink &quot;Rekapi/addActor:method&quot;}}{{/crossLink}}&#x60;.
   *   - __render__ (_Function(Object, Object)_): A function that gets called
   *   every time the actor&#x27;s state is updated (once every frame). This
   *   function should do something meaningful with state of the actor (for
   *   example, visually rendering to the screen).  This function receives two
   *   parameters: The first is a reference to the actor&#x27;s &#x60;context&#x60; and the
   *   second is an Object containing the current state properties.
   *   - __teardown__ (_Function_): A function that gets called when the actor
   *   is removed from an animation with
   *   &#x60;{{#crossLink &quot;Rekapi/removeActor:method&quot;}}{{/crossLink}}&#x60;.
   * @constructor
   */
  Rekapi.Actor = function (opt_config) {

    opt_config = opt_config || {};

    // Steal the &#x60;Tweenable&#x60; constructor.
    Tweenable.call(this);

    _.extend(this, {
      &#x27;_propertyTracks&#x27;: {}
      ,&#x27;_timelinePropertyCache&#x27;: []
      ,&#x27;_timelineFunctionCache&#x27;: []
      ,&#x27;_timelinePropertyCacheValid&#x27;: false
      ,&#x27;_keyframeProperties&#x27;: {}
      ,&#x27;id&#x27;: _.uniqueId()
      ,&#x27;context&#x27;: opt_config.context // This may be undefined
      ,&#x27;setup&#x27;: opt_config.setup || noop
      ,&#x27;render&#x27;: opt_config.render || noop
      ,&#x27;teardown&#x27;: opt_config.teardown || noop
      ,&#x27;data&#x27;: {}
      ,&#x27;wasActive&#x27;: true
    });

    return this;
  };
  var Actor = Rekapi.Actor;

  // Kind of a fun way to set up an inheritance chain.  &#x60;ActorMethods&#x60; prevents
  // methods on &#x60;Actor.prototype&#x60; from polluting &#x60;Tweenable&#x60;&#x27;s prototype with
  // &#x60;Actor&#x60; specific methods.
  var ActorMethods = function () {};
  ActorMethods.prototype = Tweenable.prototype;
  Actor.prototype = new ActorMethods();
  // But the magic doesn&#x27;t stop here!  &#x60;Actor&#x60;&#x27;s constructor steals the
  // &#x60;Tweenable&#x60; constructor.

  /**
   * Create a keyframe for the actor.  The animation timeline begins at &#x60;0&#x60;.
   * The timeline&#x27;s length will automatically &quot;grow&quot; to accommodate new
   * keyframes as they are added.
   *
   * &#x60;state&#x60; should contain all of the properties that define this
   * keyframe&#x27;s state.  These properties can be any value that can be tweened
   * by [Shifty](http://jeremyckahn.github.io/shifty/) (numbers,
   * RGB/hexadecimal color strings, and CSS property strings).  &#x60;state&#x60; can
   * also be a function, but this works differently (see &quot;Function keyframes&quot;
   * below).
   *
   * __Note:__ Internally, this creates &#x60;{{#crossLink
   * &quot;Rekapi.KeyframeProperty&quot;}}{{/crossLink}}&#x60;s and places them on a &quot;track.&quot;
   * These &#x60;{{#crossLink &quot;Rekapi.KeyframeProperty&quot;}}{{/crossLink}}&#x60;s are
   * managed for you by the &#x60;{{#crossLink &quot;Rekapi.Actor&quot;}}{{/crossLink}}&#x60; APIs.
   *
   * ## Keyframe inheritance
   *
   * Keyframes always inherit missing properties from the previous keyframe.
   * For example:
   *
   *     actor.keyframe(0, {
   *       &#x27;x&#x27;: 100
   *     }).keyframe(1000, {
   *       // Implicitly specifies the &#x60;x: 100&#x60; from above
   *       &#x27;y&#x27;: 50
   *     });
   *
   * Keyframe &#x60;1000&#x60; will have a &#x60;y&#x60; of &#x60;50&#x60;, and an &#x60;x&#x60; of &#x60;100&#x60;, because &#x60;x&#x60;
   * was inherited from keyframe &#x60;0&#x60;.
   *
   * ## Function keyframes
   *
   * Instead of providing an Object to be used to interpolate state values, you
   * can provide a function to be called at a specific point on the timeline.
   * This function does not need to return a value, as it does not get used to
   * render the actor state.  Function keyframes are called once per animation
   * loop and do not have any tweening relationship with one another.  This is
   * a primarily a mechanism for scheduling arbitrary code to be executed at
   * specific points in an animation.
   *
   *     // drift is the number of milliseconds that this function was executed
   *     // after the scheduled time.  There is typically some amount of delay
   *     // due to the nature of JavaScript timers.
   *     actor.keyframe(1000, function (drift) {
   *       console.log(this); // Logs the actor instance
   *     });
   *
   * ## Easing
   *
   * &#x60;opt_easing&#x60;, if provided, can be a string or an Object.  If &#x60;opt_easing&#x60;
   * is a string, all animated properties will have the same easing curve
   * applied to them.  For example:
   *
   *     actor.keyframe(1000, {
   *         &#x27;x&#x27;: 100,
   *         &#x27;y&#x27;: 100
   *       }, &#x27;easeOutSine&#x27;);
   *
   * Both &#x60;x&#x60; and &#x60;y&#x60; will have &#x60;easeOutSine&#x60; applied to them.  You can also
   * specify multiple easing curves with an Object:
   *
   *     actor.keyframe(1000, {
   *         &#x27;x&#x27;: 100,
   *         &#x27;y&#x27;: 100
   *       }, {
   *         &#x27;x&#x27;: &#x27;easeinSine&#x27;,
   *         &#x27;y&#x27;: &#x27;easeOutSine&#x27;
   *       });
   *
   * &#x60;x&#x60; will ease with &#x60;easeInSine&#x60;, and &#x60;y&#x60; will ease with &#x60;easeOutSine&#x60;.
   * Any unspecified properties will ease with &#x60;linear&#x60;.  If &#x60;opt_easing&#x60; is
   * omitted, all properties will default to &#x60;linear&#x60;.
   * @method keyframe
   * @param {number} millisecond Where on the timeline to set the keyframe.
   * @param {Object|Function(number)} state The state properties of the
   * keyframe.  If this is an Object, the properties will be interpolated
   * between this and those of the following keyframe for a given point on the
   * animation timeline.  If this is a function, it will be executed at the
   * specified keyframe.  The function will receive a number that represents
   * the delay between when the function is called and when it was scheduled.
   * @param {string|Object=} opt_easing Optional easing string or Object.  If
   * &#x60;state&#x60; is a function, this is ignored.
   * @chainable
   */
  Actor.prototype.keyframe = function keyframe (
    millisecond, state, opt_easing) {

    if (state instanceof Function) {
      state = { &#x27;function&#x27;: state };
    }

    opt_easing = opt_easing || DEFAULT_EASING;
    var easing = Tweenable.composeEasingObject(state, opt_easing);
    var newKeyframeProperty;

    // Create and add all of the KeyframeProperties
    _.each(state, function (value, name) {
      newKeyframeProperty = new Rekapi.KeyframeProperty(
        millisecond, name, value, easing[name]);

      this.addKeyframeProperty(newKeyframeProperty);
    }, this);

    if (this.rekapi) {
      invalidateAnimationLength(this.rekapi);
    }

    invalidatePropertyCache(this);
    fireRekapiEventForActor(this, &#x27;timelineModified&#x27;);

    return this;
  };

  /**
   * @method hasKeyframeAt
   * @param {number} millisecond Point on the timeline to query.
   * @param {string=} opt_trackName Optionally scope the lookup to a particular
   * track.
   * @return {boolean} Whether or not the actor has any &#x60;{{#crossLink
   * &quot;Rekapi.KeyframeProperty&quot;}}{{/crossLink}}&#x60;s set at &#x60;millisecond&#x60;.
   */
  Actor.prototype.hasKeyframeAt = function (millisecond, opt_trackName) {
    var tracks = this._propertyTracks;

    if (opt_trackName) {
      if (!_.has(tracks, opt_trackName)) {
        return false;
      }
      tracks = _.pick(tracks, opt_trackName);
    }

    // Search through the tracks and determine if a property can be found.
    var track;
    for (track in tracks) {
      if (tracks.hasOwnProperty(track)
         &amp;&amp; this.getKeyframeProperty(track, millisecond)) {
        return true;
      }
    }

    return false;
  };

  /**
   * Copies all of the &#x60;{{#crossLink
   * &quot;Rekapi.KeyframeProperty&quot;}}{{/crossLink}}&#x60;s from one point on the actor&#x27;s
   * timeline to another. This is particularly useful for animating an actor
   * back to its original position.
   *
   *     actor
   *       .keyframe(0, {
   *         x: 10,
   *         y: 15
   *       }).keyframe(1000, {
   *         x: 50,
   *         y: 75
   *       });
   *
   *     // Return the actor to its original position
   *     actor.copyKeyframe(2000, 0);
   *
   * __[Example](../../../../docs/examples/actor_copy_keyframe.html)__
   * @method copyKeyframe
   * @param {number} copyTo The timeline millisecond to copy KeyframeProperties
   * to.
   * @param {number} copyFrom The timeline millisecond to copy
   * KeyframeProperties from.
   * @chainable
   */
  Actor.prototype.copyKeyframe = function (copyTo, copyFrom) {
    // Build the configuation objects to be passed to Actor#keyframe
    var sourcePositions = {};
    var sourceEasings = {};

    _.each(this._propertyTracks, function (propertyTrack, trackName) {
      var keyframeProperty =
      this.getKeyframeProperty(trackName, copyFrom);

      if (keyframeProperty) {
        sourcePositions[trackName] = keyframeProperty.value;
        sourceEasings[trackName] = keyframeProperty.easing;
      }
    }, this);

    this.keyframe(copyTo, sourcePositions, sourceEasings);
    return this;
  };

  /**
   * Moves all of the
   * &#x60;{{#crossLink &quot;Rekapi.KeyframeProperty&quot;}}{{/crossLink}}&#x60;s from one
   * point on the actor&#x27;s timeline to another.  Although this method does error
   * checking for you to make sure the operation can be safely performed, an
   * effective pattern is to use &#x60;{{#crossLink
   * &quot;Rekapi.Actor/hasKeyframeAt:method&quot;}}{{/crossLink}}&#x60; to see if there is
   * already a keyframe at the requested &#x60;to&#x60; destination.
   *
   * __[Example](../../../../docs/examples/actor_move_keyframe.html)__
   * @method moveKeyframe
   * @param {number} from The millisecond of the keyframe to be moved.
   * @param {number} to The millisecond of where the keyframe should be moved
   * to.
   * @return {boolean} Whether or not the keyframe was successfully moved.
   */
  Actor.prototype.moveKeyframe = function (from, to) {
    if (!this.hasKeyframeAt(from) || this.hasKeyframeAt(to)) {
      return false;
    }

    // Move each of the relevant KeyframeProperties to the new location in the
    // timeline
    _.each(this._propertyTracks, function (propertyTrack, trackName) {
      var oldIndex = propertyIndexInTrack(propertyTrack, from);
      if (typeof oldIndex !== &#x27;undefined&#x27;) {
        var property = propertyTrack[oldIndex];
        property.millisecond = to;
      }
    }, this);

    cleanupAfterKeyframeModification(this);

    return true;
  };

  /**
   * Augment the &#x60;value&#x60; or &#x60;easing&#x60; of the &#x60;{{#crossLink
   * &quot;Rekapi.KeyframeProperty&quot;}}{{/crossLink}}&#x60;s at a given millisecond.  Any
   * &#x60;{{#crossLink &quot;Rekapi.KeyframeProperty&quot;}}{{/crossLink}}&#x60;s omitted in
   * &#x60;stateModification&#x60; or &#x60;opt_easing&#x60; are not modified.
   *
   *     actor.keyframe(0, {
   *       &#x27;x&#x27;: 10,
   *       &#x27;y&#x27;: 20
   *     }).keyframe(1000, {
   *       &#x27;x&#x27;: 20,
   *       &#x27;y&#x27;: 40
   *     }).keyframe(2000, {
   *       &#x27;x&#x27;: 30,
   *       &#x27;y&#x27;: 60
   *     })
   *
   *     // Changes the state of the keyframe at millisecond 1000.
   *     // Modifies the value of &#x27;y&#x27; and the easing of &#x27;x.&#x27;
   *     actor.modifyKeyframe(1000, {
   *       &#x27;y&#x27;: 150
   *     }, {
   *       &#x27;x&#x27;: &#x27;easeFrom&#x27;
   *     });
   *
   * __[Example](../../../../docs/examples/actor_modify_keyframe.html)__
   * @method modifyKeyframe
   * @param {number} millisecond
   * @param {Object} stateModification
   * @param {Object=} opt_easingModification
   * @chainable
   */
  Actor.prototype.modifyKeyframe = function (
    millisecond, stateModification, opt_easingModification) {
    opt_easingModification = opt_easingModification || {};

    _.each(this._propertyTracks, function (propertyTrack, trackName) {
      var property = this.getKeyframeProperty(trackName, millisecond);

      if (property) {
        property.modifyWith({
          &#x27;value&#x27;: stateModification[trackName]
          ,&#x27;easing&#x27;: opt_easingModification[trackName]
        });
      } else if (typeof stateModification[trackName] !== &#x27;undefined&#x27;) {
        property = new Rekapi.KeyframeProperty(
          millisecond, trackName,
          stateModification[trackName],
          opt_easingModification[trackName]);

        this.addKeyframeProperty(property);
      }
    }, this);

    cleanupAfterKeyframeModification(this);

    return this;
  };

  /**
   * Remove all &#x60;{{#crossLink &quot;Rekapi.KeyframeProperty&quot;}}{{/crossLink}}&#x60;s set
   * on the actor at a given millisecond in the animation.
   *
   * __[Example](../../../../docs/examples/actor_remove_keyframe.html)__
   * @method removeKeyframe
   * @param {number} millisecond The location on the timeline of the keyframe
   * to remove.
   * @chainable
   */
  Actor.prototype.removeKeyframe = function (millisecond) {
    var propertyTracks = this._propertyTracks;

    _.each(this._propertyTracks, function (propertyTrack, propertyName) {
      var index = propertyIndexInTrack(propertyTrack, millisecond);
      if (typeof index !== &#x27;undefined&#x27;) {
        var keyframeProperty = propertyTrack[index];
        this._deleteKeyframePropertyAt(propertyTrack, index);
        keyframeProperty.detach();
      }
    }, this);

    removeEmptyPropertyTracks(this);
    cleanupAfterKeyframeModification(this);
    fireRekapiEventForActor(this, &#x27;timelineModified&#x27;);

    return this;
  };

  /**
   * Remove all &#x60;{{#crossLink &quot;Rekapi.KeyframeProperty&quot;}}{{/crossLink}}&#x60;s set
   * on the actor.
   *
   * **NOTE**: This method does _not_ fire the &#x60;beforeRemoveKeyframeProperty&#x60;
   * or &#x60;removeKeyframePropertyComplete&#x60; events.  This method is a bulk
   * operation that is more efficient than calling &#x60;{{#crossLink
   * &quot;Rekapi.Actor/removeKeyframeProperty:method&quot;}}{{/crossLink}}&#x60; many times
   * individually, but foregoes firing events.
   *
   * __[Example](../../../../docs/examples/actor_remove_all_keyframes.html)__
   * @method removeAllKeyframes
   * @chainable
   */
  Actor.prototype.removeAllKeyframes = function () {
    _.each(this._propertyTracks, function (propertyTrack) {
      propertyTrack.length = 0;
    });

    _.each(this._keyframeProperties, function (keyframeProperty) {
      keyframeProperty.detach();
    }, this);

    removeEmptyPropertyTracks(this);
    this._keyframeProperties = {};

    // Calling removeKeyframe performs some necessary post-removal cleanup, the
    // earlier part of this method skipped all of that for the sake of
    // efficiency.
    return this.removeKeyframe(0);
  };

  /**
   * @method getKeyframeProperty
   * @param {string} property The name of the property track.
   * @param {number} millisecond The millisecond of the property in the
   * timeline.
   * @return {Rekapi.KeyframeProperty|undefined} A &#x60;{{#crossLink
   * &quot;Rekapi.KeyframeProperty&quot;}}{{/crossLink}}&#x60; that is stored on the actor, as
   * specified by the &#x60;property&#x60; and &#x60;millisecond&#x60; parameters. This is
   * &#x60;undefined&#x60; if no properties were found.
   */
  Actor.prototype.getKeyframeProperty = function (property, millisecond) {
    var propertyTrack = this._propertyTracks[property];
    var index = propertyIndexInTrack(propertyTrack, millisecond);
    if (typeof index !== &#x27;undefined&#x27;) {
      return propertyTrack[index];
    }
  };

  /**
   * Modify a &#x60;{{#crossLink &quot;Rekapi.KeyframeProperty&quot;}}{{/crossLink}}&#x60; stored
   * on an actor.  Internally, this calls &#x60;{{#crossLink
   * &quot;Rekapi.KeyframeProperty/modifyWith:method&quot;}}{{/crossLink}}&#x60; and then
   * performs some cleanup.
   *
   * __[Example](../../../../docs/examples/actor_modify_keyframe_property.html)__
   * @method modifyKeyframeProperty
   * @param {string} property The name of the &#x60;{{#crossLink
   * &quot;Rekapi.KeyframeProperty&quot;}}{{/crossLink}}&#x60; to modify.
   * @param {number} millisecond The timeline millisecond of the &#x60;{{#crossLink
   * &quot;Rekapi.KeyframeProperty&quot;}}{{/crossLink}}&#x60; to modify.
   * @param {Object} newProperties The properties to augment the &#x60;{{#crossLink
   * &quot;Rekapi.KeyframeProperty&quot;}}{{/crossLink}}&#x60; with.
   * @chainable
   */
  Actor.prototype.modifyKeyframeProperty = function (
    property, millisecond, newProperties) {

    var keyframeProperty = this.getKeyframeProperty(property, millisecond);
    if (keyframeProperty) {
      if (&#x27;millisecond&#x27; in newProperties) {
        if (this.hasKeyframeAt(newProperties.millisecond, property)) {
          throw new Error(&#x27;Tried to move &#x27; + property + &#x27; to &#x27; + newProperties.millisecond + &#x27;ms, but a keyframe property already exists there&#x27;);
        }
      }

      keyframeProperty.modifyWith(newProperties);
      cleanupAfterKeyframeModification(this);
    }

    return this;
  };

  /**
   * Remove a single &#x60;{{#crossLink &quot;Rekapi.KeyframeProperty&quot;}}{{/crossLink}}&#x60;
   * from the actor.
   * @method removeKeyframeProperty
   * @param {string} property The name of the &#x60;{{#crossLink
   * &quot;Rekapi.KeyframeProperty&quot;}}{{/crossLink}}&#x60; to remove.
   * @param {number} millisecond Where in the timeline the &#x60;{{#crossLink
   * &quot;Rekapi.KeyframeProperty&quot;}}{{/crossLink}}&#x60; to remove is.
   * @return {Rekapi.KeyframeProperty|undefined} The removed KeyframeProperty,
   * if one was found.
   */
  Actor.prototype.removeKeyframeProperty = function (property, millisecond) {
    var propertyTracks = this._propertyTracks;

    if (typeof propertyTracks[property] !== &#x27;undefined&#x27;) {
      var propertyTrack = propertyTracks[property];
      var index = propertyIndexInTrack(propertyTrack, millisecond);
      var keyframeProperty = propertyTrack[index];
      fireEvent(this.rekapi, &#x27;beforeRemoveKeyframeProperty&#x27;, _, keyframeProperty);
      this._deleteKeyframePropertyAt(propertyTrack, index);
      keyframeProperty.detach();

      removeEmptyPropertyTracks(this);
      cleanupAfterKeyframeModification(this);
      fireEvent(this.rekapi, &#x27;removeKeyframePropertyComplete&#x27;, _, keyframeProperty);

      return keyframeProperty;
    }
  };

  /**
   *
   * @method getTrackNames
   * @return {Array(string)} A list of all the track names for an actor.
   */
  Actor.prototype.getTrackNames = function () {
    return _.keys(this._propertyTracks);
  };

  /**
   * Get all of the &#x60;{{#crossLink &quot;Rekapi.KeyframeProperty&quot;}}{{/crossLink}}&#x60;s
   * for a track.
   * @method getPropertiesInTrack
   * @param {string} trackName The track name to query.
   * @return {Rekapi.KeyframeProperty[]|undefined}
   */
  Actor.prototype.getPropertiesInTrack = function (trackName) {
    var propertyTrack = this._propertyTracks[trackName];

    if (propertyTrack) {
      return propertyTrack.slice(0);
    }
  };

  /**
   * @method getStart
   * @param {string=} opt_trackName Optionally scope the lookup to a particular
   * track.
   * @return {number} The millisecond of the first animating state of an actor
   * (for instance, if the actor&#x27;s first keyframe is later than millisecond
   * &#x60;0&#x60;).  If there are no keyframes, this returns &#x60;0&#x60;.
   */
  Actor.prototype.getStart = function (opt_trackName) {
    var starts = [];
    var propertyTracks = this._propertyTracks;

    // Null check to see if opt_trackName was provided and is valid
    if (propertyTracks.hasOwnProperty(opt_trackName)) {
      var firstKeyframeProperty = propertyTracks[opt_trackName][0];

      if (firstKeyframeProperty) {
        starts.push(firstKeyframeProperty.millisecond);
      }
    } else {
      // Loop over all property tracks and accumulate the first
      // keyframeProperties from non-empty tracks
      _.each(propertyTracks, function (propertyTrack) {
        if (propertyTrack.length) {
          starts.push(propertyTrack[0].millisecond);
        }
      });
    }

    if (starts.length === 0) {
      starts = [0];
    }

    var start;
    if (starts.length &gt; 0) {
      start = Math.min.apply(Math, starts);
    } else {
      start = 0;
    }

    return start;
  };

  /**
   * @method getEnd
   * @param {string=} opt_trackName Optionally scope the lookup to a particular
   * keyframe track.
   * @return {number} The millisecond of the last state of an actor (the point
   * in the timeline in which it is done animating).  If there are no
   * keyframes, this is &#x60;0&#x60;.
   */
  Actor.prototype.getEnd = function (opt_trackName) {
    var latest = 0;
    var tracksToInspect = this._propertyTracks;

    if (opt_trackName) {
      tracksToInspect = {};
      tracksToInspect[opt_trackName] = this._propertyTracks[opt_trackName];
    }

    _.each(tracksToInspect, function (propertyTrack) {
      if (propertyTrack.length) {
        var trackLength = Math.max.apply(Math, _.map(propertyTrack, &#x27;millisecond&#x27;));

        if (trackLength &gt; latest) {
          latest = trackLength;
        }
      }
    }, this);

    return latest;
  };

  /**
   * @method getLength
   * @param {string=} opt_trackName Optionally scope the lookup to a particular
   * track.
   * @return {number} The length of time in milliseconds that the actor
   * animates for.
   */
  Actor.prototype.getLength = function (opt_trackName) {
    return this.getEnd(opt_trackName) - this.getStart(opt_trackName);
  };

  /**
   * Extend the last state on this actor&#x27;s timeline to simulate a pause.
   * Internally, this method copies the final state of the actor in the
   * timeline to the millisecond defined by &#x60;until&#x60;.
   *
   * __[Example](../../../../docs/examples/actor_wait.html)__
   * @method wait
   * @param {number} until At what point in the animation the Actor should wait
   * until (relative to the start of the animation timeline).  If this number
   * is less than the value returned from &#x60;{{#crossLink
   * &quot;Rekapi.Actor/getLength:method&quot;}}{{/crossLink}}&#x60;, this method does
   * nothing.
   * @chainable
   */
  Actor.prototype.wait = function (until) {
    var length = this.getEnd();

    if (until &lt;= length) {
      return this;
    }

    var end = this.getEnd();
    var latestProps = getLatestProperties(this, this.getEnd());
    var serializedProps = {};
    var serializedEasings = {};

    _.each(latestProps, function (latestProp, propName) {
      serializedProps[propName] = latestProp.value;
      serializedEasings[propName] = latestProp.easing;
    });

    this.modifyKeyframe(end, serializedProps, serializedEasings);
    this.keyframe(until, serializedProps, serializedEasings);

    return this;
  };

  /*!
   * Insert a &#x60;KeyframeProperty&#x60; into a property track at &#x60;index&#x60;.  The linked
   * list structure of the property track is maintained.
   * @method _insertKeyframePropertyAt
   * @param {Rekapi.KeyframeProperty} keyframeProperty
   * @param {Array(Rekapi.KeyframeProperty)} propertyTrack
   * @param {number} index
   */
  Actor.prototype._insertKeyframePropertyAt = function (keyframeProperty, propertyTrack, index) {
    propertyTrack.splice(index, 0, keyframeProperty);
  };

  /*!
   * Remove the &#x60;KeyframeProperty&#x60; at &#x60;index&#x60; from a property track.  The linked
   * list structure of the property track is maintained.  The removed property
   * is not modified or unlinked internally.
   * @method _deleteKeyframePropertyAt
   * @param {Array(Rekapi.KeyframeProperty)} propertyTrack
   * @param {number} index
   */
  Actor.prototype._deleteKeyframePropertyAt = function (propertyTrack, index) {
    propertyTrack.splice(index, 1);
  };

  /**
   * Associate a &#x60;{{#crossLink &quot;Rekapi.KeyframeProperty&quot;}}{{/crossLink}}&#x60; to
   * this actor.  Augments the &#x60;{{#crossLink
   * &quot;Rekapi.KeyframeProperty&quot;}}{{/crossLink}}&#x60; to maintain a link between the
   * two objects.  This is a lower-level method, and it is generally better to
   * use &#x60;{{#crossLink &quot;Rekapi.Actor/keyframe:method&quot;}}{{/crossLink}}&#x60;.  This
   * is mostly useful for adding a &#x60;{{#crossLink
   * &quot;Rekapi.KeyframeProperty&quot;}}{{/crossLink}}&#x60; back to an actor after it was
   * &#x60;{{#crossLink &quot;Rekapi.KeyframeProperty/detach&quot;}}{{/crossLink}}&#x60;ed.
   * @method addKeyframeProperty
   * @param {Rekapi.KeyframeProperty} keyframeProperty
   * @chainable
   */
  Actor.prototype.addKeyframeProperty = function (keyframeProperty) {
    if (this.rekapi) {
      fireEvent(this.rekapi, &#x27;beforeAddKeyframeProperty&#x27;, _, keyframeProperty);
    }

    keyframeProperty.actor = this;
    this._keyframeProperties[keyframeProperty.id] = keyframeProperty;

    var name = keyframeProperty.name;
    var propertyTracks = this._propertyTracks;

    if (typeof this._propertyTracks[name] === &#x27;undefined&#x27;) {
      propertyTracks[name] = [keyframeProperty];
      if (this.rekapi) {
        fireEvent(this.rekapi, &#x27;addKeyframePropertyTrack&#x27;, _, keyframeProperty);
      }
    } else {
      var index = insertionPointInTrack(propertyTracks[name], keyframeProperty.millisecond);
      if (propertyTracks[name][index]) {
        var ms = keyframeProperty.millisecond;
        var otherMs = propertyTracks[name][index].millisecond;
        if (otherMs === ms) {
          throw new Error(&#x27;Tried to add a duplicate keyframe property, &#x27; + name + &#x27; @ &#x27; + ms + &#x27; ms&#x27;);
        } else if (this.rekapi &amp;&amp; this.rekapi._warnOnOutOfOrderKeyframes) {
          console.warn(new Error(&#x27;Added a keyframe property before end of track, &#x27; + name + &#x27; @ &#x27; + ms + &#x27; ms &lt; &#x27; + otherMs + &#x27; ms&#x27;));
        }
      }
      this._insertKeyframePropertyAt(keyframeProperty, propertyTracks[name], index);
      cleanupAfterKeyframeModification(this);
    }

    if (this.rekapi) {
      fireEvent(this.rekapi, &#x27;addKeyframeProperty&#x27;, _, keyframeProperty);
    }

    return this;
  };

  /*!
   * Set the actor to be active or inactive starting at &#x60;millisecond&#x60;.
   * @method setActive
   * @param {number} millisecond The time at which to change the actor&#x27;s active state
   * @param {boolean} isActive Whether the actor should be active or inactive
   * @chainable
   */
  Actor.prototype.setActive = function (millisecond, isActive) {
    var activeProperty = this._propertyTracks._active
        &amp;&amp; this.getKeyframeProperty(&#x27;_active&#x27;, millisecond);

    if (activeProperty) {
      activeProperty.value = isActive;
    } else {
      activeProperty = new Rekapi.KeyframeProperty(
        millisecond, &#x27;_active&#x27;, isActive);
      this.addKeyframeProperty(activeProperty);
    }

    return this;
  };

  /*!
   * Calculate and set the actor&#x27;s position at &#x60;millisecond&#x60; in the animation.
   * @method _updateState
   * @param {number} millisecond
   * @param {boolean=} opt_doResetLaterFnKeyframes If true, allow all function
   * keyframes later in the timeline to be run again.
   * @chainable
   */
  Actor.prototype._updateState = function (millisecond, opt_doResetLaterFnKeyframes) {
    var startMs = this.getStart();
    var endMs = this.getEnd();
    var interpolatedObject = {};

    millisecond = Math.min(endMs, millisecond);

    ensurePropertyCacheValid(this);
    var propertiesToInterpolate =
        getPropertyCacheEntryForMillisecond(this, millisecond);

    // All actors are active at time 0 unless otherwise specified;
    // make sure a future time deactivation doesn&#x27;t deactive the actor
    // by default.
    if (propertiesToInterpolate._active
        &amp;&amp; millisecond &gt;= propertiesToInterpolate._active.millisecond) {
      this.wasActive = propertiesToInterpolate._active.getValueAt(millisecond);
      if (!this.wasActive)
        return this;
    } else {
      this.wasActive = true;
    }

    if (startMs === endMs) {

      // If there is only one keyframe, use that for the state of the actor
      _.each(propertiesToInterpolate, function (keyframeProperty, propName) {
        if (propName !== &#x27;_millisecond&#x27;) {
          if (keyframeProperty.shouldInvokeForMillisecond(millisecond)) {
            keyframeProperty.invoke();
            keyframeProperty.hasFired = false;
            return;
          }

          interpolatedObject[propName] = keyframeProperty.value;
        }
      }, this);

    } else {

      _.each(propertiesToInterpolate, function (keyframeProperty, propName) {
        if (propName !== &#x27;_millisecond&#x27;) {
          if (this._beforeKeyframePropertyInterpolate !== noop) {
            this._beforeKeyframePropertyInterpolate(keyframeProperty);
          }

          if (keyframeProperty.shouldInvokeForMillisecond(millisecond)) {
            keyframeProperty.invoke();
            return;
          }

          interpolatedObject[propName] =
          keyframeProperty.getValueAt(millisecond);

          if (this._afterKeyframePropertyInterpolate !== noop) {
            this._afterKeyframePropertyInterpolate(
              keyframeProperty, interpolatedObject);
          }
        }
      }, this);
    }

    this.set(interpolatedObject);

    if (!opt_doResetLaterFnKeyframes) {
      this._resetFnKeyframesFromMillisecond(millisecond);
    }

    return this;
  };

  /*!
   * @method _resetFnKeyframesFromMillisecond
   * @param {number} millisecond
   */
  Actor.prototype._resetFnKeyframesFromMillisecond = function (millisecond) {
    var cache = this._timelineFunctionCache;
    var index = _.sortedIndex(cache, { millisecond: millisecond }, getMillisecond);
    var len = cache.length;

    while (index &lt; len) {
      cache[index++].hasFired = false;
    }
  };

  /*!
   * @method _beforeKeyframePropertyInterpolate
   * @param {Rekapi.KeyframeProperty} keyframeProperty
   * @abstract
   */
  Actor.prototype._beforeKeyframePropertyInterpolate = noop;

  /*!
   * @method _afterKeyframePropertyInterpolate
   * @param {Rekapi.KeyframeProperty} keyframeProperty
   * @param {Object} interpolatedObject
   * @abstract
   */
  Actor.prototype._afterKeyframePropertyInterpolate = noop;

  /**
   * __[Example](../../../../docs/examples/actor_export_timeline.html)__
   * @method exportTimeline
   * @return {Object} A serializable Object of this actor&#x27;s timeline property
   * tracks and &#x60;{{#crossLink &quot;Rekapi.KeyframeProperty&quot;}}{{/crossLink}}&#x60;s.
   */
  Actor.prototype.exportTimeline = function () {
    var exportData = {
      &#x27;start&#x27;: this.getStart()
      ,&#x27;end&#x27;: this.getEnd()
      ,&#x27;trackNames&#x27;: this.getTrackNames()
      ,&#x27;propertyTracks&#x27;: {}
    };

    _.each(this._propertyTracks, function (propertyTrack, trackName) {
      var trackAlias = exportData.propertyTracks[trackName] = [];
      _.each(propertyTrack, function (keyframeProperty) {
        trackAlias.push(keyframeProperty.exportPropertyData());
      });
    });

    return exportData;
  };

  /**
   * Import an Object to augment this actor&#x27;s state.  This does not remove
   * keyframe properties before importing new ones.
   *
   * @method importTimeline
   * @param {Object} actorData Any object that has the same data format as the
   * object generated from &#x60;{{#crossLink
   * &quot;Rekapi.Actor/exportTimeline:method&quot;}}{{/crossLink}}&#x60;.
   */
  Actor.prototype.importTimeline = function (actorData) {
    _.each(actorData.propertyTracks, function (propertyTrack) {
      _.each(propertyTrack, function (property) {
        var obj = {};
        obj[property.name] = property.value;
        this.keyframe(property.millisecond, obj, property.easing);
      }, this);
    }, this);
  };

});

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
