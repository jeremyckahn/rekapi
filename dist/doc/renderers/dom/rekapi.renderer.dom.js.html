<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width" charset="utf-8"><title>Rekapi</title><!-- Foundation CSS--><link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/foundation/4.1.6/css/foundation.min.css"><!-- Prism CSS--><style type="text/css">/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
	color: black;
	text-shadow: 0 1px white;
	font-family: Consolas, Monaco, 'Andale Mono', monospace;
	direction: ltr;
	text-align: left;
	white-space: pre;
	word-spacing: normal;

	-moz-tab-size: 4;
	-o-tab-size: 4;
	tab-size: 4;

	-webkit-hyphens: none;
	-moz-hyphens: none;
	-ms-hyphens: none;
	hyphens: none;
}

::-moz-selection {
	text-shadow: none;
	background: #b3d4fc;
}

::selection {
	text-shadow: none;
	background: #b3d4fc;
}

@media print {
	code[class*="language-"],
	pre[class*="language-"] {
		text-shadow: none;
	}
}

/* Code blocks */
pre[class*="language-"] {
	padding: 1em;
	margin: .5em 0;
	overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
	background: #f5f2f0;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
	padding: .1em;
	border-radius: .3em;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
	color: slategray;
}

.token.punctuation {
	color: #999;
}

.namespace {
	opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number {
	color: #905;
}

.token.selector,
.token.attr-name,
.token.string {
	color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
	color: #a67f59;
	background: hsla(0,0%,100%,.5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
	color: #07a;
}


.token.regex,
.token.important {
	color: #e90;
}

.token.important {
	font-weight: bold;
}

.token.entity {
	cursor: help;
}
</style><!-- Custom Styles--><style type="text/css">h1.page-title small {
  font-weight: 400;
}
/*.section-container, .section-container .section .title
  border-color #e6e6e6*/
#nav .section.active {
  padding-top: 0 !important;
}
#nav .section.active .title {
  background: #ddd;
}
#nav .section .title {
  background-color: #eee;
}
#nav .section .title a {
  font-weight: 700;
  padding: 0.6em;
}
#nav .section .title a small {
  font-size: 0.8em;
  line-height: 1em;
  display: block;
  color: #888;
  margin: 2px 0 -2px;
}
#nav .section .title:hover {
  background: #ddd;
}
#nav ul.solo {
  border-top: 1px solid #ccc;
  padding: 0.875em;
}
code {
  background: transparent;
  line-height: 1.3em;
  font-weight: normal;
}
.comment {
  position: relative;
  padding-bottom: 1.5em;
  margin-bottom: 2em;
  border-bottom: 1px solid #ddd;
}
.comment ol,
.comment ul {
  margin-left: 2.25em;
}
.comment ol.no-bullet,
.comment ul.no-bullet {
  margin-left: 0;
}
.comment header {
  margin-bottom: 1.5em;
}
.comment header h1 {
  font-size: 2rem;
  margin-bottom: 0.2em;
}
.comment .section-container,
.comment .section-container > .section > .content {
  border: none;
}
.comment .section-container > .section > .title {
  padding: auto;
  background: none !important;
  border: none !important;
}
.comment .section-container > .section > .title a {
  border-radius: 4px;
  font-weight: 700;
  padding: 1px 10px 1px 0;
  margin-right: 5px;
  color: #ccc;
}
.comment .section-container > .section:hover .title a {
  color: #999;
}
.comment .section-container > .section.active .title a {
  color: #2ba6cb;
}
.comment .section-container > .section > .content {
  padding: 0.9em 0 0;
}
.comment div.description h2 {
  font-size: 1.2em;
}
.comment .tags span {
  margin-right: 4px;
}
.comment .tags .name,
.comment .tags .type {
  font-weight: 700;
}
.comment .tags .types {
  color: #666;
}
.comment .tags .description {
  margin-left: 15px;
}
.ctx-type {
  margin-right: 6px;
  font-size: 0.7em;
}
</style><script srr="http://cdnjs.cloudflare.com/ajax/libs/foundation/4.1.6/js/vendor/custom.modernizr.js"></script></head><body><div class="row"><div class="small-12 columns"><h1 class="page-title">Rekapi<small> renderers/dom/rekapi.renderer.dom.js</small></h1></div></div><div class="row"><div id="nav" class="large-3 columns"><div data-section="accordian" data-options="" class="section-container accordian"><div class="section"><p data-section-title class="title"><a href="../../../../dist/doc/src/rekapi.core.js.html"><small>src/</small>rekapi.core.js</a></p><div data-section-content class="content"><ul class="side-nav"><li><a href="../../../../dist/doc/src/rekapi.core.js.html#Rekapi">Rekapi</a></li><li><a href="../../../../dist/doc/src/rekapi.core.js.html#addActor">addActor</a></li><li><a href="../../../../dist/doc/src/rekapi.core.js.html#getActor">getActor</a></li><li><a href="../../../../dist/doc/src/rekapi.core.js.html#getActorIds">getActorIds</a></li><li><a href="../../../../dist/doc/src/rekapi.core.js.html#getAllActors">getAllActors</a></li><li><a href="../../../../dist/doc/src/rekapi.core.js.html#getActorCount">getActorCount</a></li><li><a href="../../../../dist/doc/src/rekapi.core.js.html#removeActor">removeActor</a></li><li><a href="../../../../dist/doc/src/rekapi.core.js.html#play">play</a></li><li><a href="../../../../dist/doc/src/rekapi.core.js.html#playFrom">playFrom</a></li><li><a href="../../../../dist/doc/src/rekapi.core.js.html#playFromCurrent">playFromCurrent</a></li><li><a href="../../../../dist/doc/src/rekapi.core.js.html#pause">pause</a></li><li><a href="../../../../dist/doc/src/rekapi.core.js.html#stop">stop</a></li><li><a href="../../../../dist/doc/src/rekapi.core.js.html#isPlaying">isPlaying</a></li><li><a href="../../../../dist/doc/src/rekapi.core.js.html#update">update</a></li><li><a href="../../../../dist/doc/src/rekapi.core.js.html#getLastPositionUpdated">getLastPositionUpdated</a></li><li><a href="../../../../dist/doc/src/rekapi.core.js.html#getAnimationLength">getAnimationLength</a></li><li><a href="../../../../dist/doc/src/rekapi.core.js.html#on">on</a></li><li><a href="../../../../dist/doc/src/rekapi.core.js.html#off">off</a></li><li><a href="../../../../dist/doc/src/rekapi.core.js.html#exportTimeline">exportTimeline</a></li><li><a href="../../../../dist/doc/src/rekapi.core.js.html#importTimeline">importTimeline</a></li></ul></div></div><div class="section"><p data-section-title class="title"><a href="../../../../dist/doc/src/rekapi.actor.js.html"><small>src/</small>rekapi.actor.js</a></p><div data-section-content class="content"><ul class="side-nav"><li><a href="../../../../dist/doc/src/rekapi.actor.js.html#Actor">Actor</a></li><li><a href="../../../../dist/doc/src/rekapi.actor.js.html#keyframe">keyframe</a></li><li><a href="../../../../dist/doc/src/rekapi.actor.js.html#hasKeyframeAt">hasKeyframeAt</a></li><li><a href="../../../../dist/doc/src/rekapi.actor.js.html#copyKeyframe">copyKeyframe</a></li><li><a href="../../../../dist/doc/src/rekapi.actor.js.html#moveKeyframe">moveKeyframe</a></li><li><a href="../../../../dist/doc/src/rekapi.actor.js.html#modifyKeyframe">modifyKeyframe</a></li><li><a href="../../../../dist/doc/src/rekapi.actor.js.html#removeKeyframe">removeKeyframe</a></li><li><a href="../../../../dist/doc/src/rekapi.actor.js.html#removeAllKeyframes">removeAllKeyframes</a></li><li><a href="../../../../dist/doc/src/rekapi.actor.js.html#getKeyframeProperty">getKeyframeProperty</a></li><li><a href="../../../../dist/doc/src/rekapi.actor.js.html#modifyKeyframeProperty">modifyKeyframeProperty</a></li><li><a href="../../../../dist/doc/src/rekapi.actor.js.html#removeKeyframeProperty">removeKeyframeProperty</a></li><li><a href="../../../../dist/doc/src/rekapi.actor.js.html#getTrackNames">getTrackNames</a></li><li><a href="../../../../dist/doc/src/rekapi.actor.js.html#getPropertiesInTrack">getPropertiesInTrack</a></li><li><a href="../../../../dist/doc/src/rekapi.actor.js.html#getStart">getStart</a></li><li><a href="../../../../dist/doc/src/rekapi.actor.js.html#getEnd">getEnd</a></li><li><a href="../../../../dist/doc/src/rekapi.actor.js.html#getLength">getLength</a></li><li><a href="../../../../dist/doc/src/rekapi.actor.js.html#wait">wait</a></li><li><a href="../../../../dist/doc/src/rekapi.actor.js.html#exportTimeline">exportTimeline</a></li><li><a href="../../../../dist/doc/src/rekapi.actor.js.html#importTimeline">importTimeline</a></li></ul></div></div><div class="section"><p data-section-title class="title"><a href="../../../../dist/doc/src/rekapi.keyframe-property.js.html"><small>src/</small>rekapi.keyframe-property.js</a></p><div data-section-content class="content"><ul class="side-nav"><li><a href="../../../../dist/doc/src/rekapi.keyframe-property.js.html#KeyframeProperty">KeyframeProperty</a></li><li><a href="../../../../dist/doc/src/rekapi.keyframe-property.js.html#modifyWith">modifyWith</a></li><li><a href="../../../../dist/doc/src/rekapi.keyframe-property.js.html#getValueAt">getValueAt</a></li><li><a href="../../../../dist/doc/src/rekapi.keyframe-property.js.html#linkToNext">linkToNext</a></li><li><a href="../../../../dist/doc/src/rekapi.keyframe-property.js.html#detach">detach</a></li><li><a href="../../../../dist/doc/src/rekapi.keyframe-property.js.html#exportPropertyData">exportPropertyData</a></li><li><a href="../../../../dist/doc/src/rekapi.keyframe-property.js.html#invoke">invoke</a></li></ul></div></div><div class="section"><p data-section-title class="title"><a href="../../../../dist/doc/renderers/canvas/rekapi.renderer.canvas.js.html"><small>renderers/canvas/</small>rekapi.renderer.canvas.js</a></p><div data-section-content class="content"><ul class="side-nav"><li><a href="../../../../dist/doc/renderers/canvas/rekapi.renderer.canvas.js.html#CanvasRenderer">CanvasRenderer</a></li><li><a href="../../../../dist/doc/renderers/canvas/rekapi.renderer.canvas.js.html#height">height</a></li><li><a href="../../../../dist/doc/renderers/canvas/rekapi.renderer.canvas.js.html#width">width</a></li><li><a href="../../../../dist/doc/renderers/canvas/rekapi.renderer.canvas.js.html#clear">clear</a></li><li><a href="../../../../dist/doc/renderers/canvas/rekapi.renderer.canvas.js.html#moveActorToLayer">moveActorToLayer</a></li><li><a href="../../../../dist/doc/renderers/canvas/rekapi.renderer.canvas.js.html#setOrderFunction">setOrderFunction</a></li><li><a href="../../../../dist/doc/renderers/canvas/rekapi.renderer.canvas.js.html#unsetOrderFunction">unsetOrderFunction</a></li></ul></div></div><div class="section active"><p data-section-title class="title"><a href="../../../../dist/doc/renderers/dom/rekapi.renderer.dom.js.html"><small>renderers/dom/</small>rekapi.renderer.dom.js</a></p><div data-section-content class="content"><ul class="side-nav"><li><a href="../../../../dist/doc/renderers/dom/rekapi.renderer.dom.js.html#DOMRenderer">DOMRenderer</a></li><li><a href="../../../../dist/doc/renderers/dom/rekapi.renderer.dom.js.html#canAnimateWithCSS">canAnimateWithCSS</a></li><li><a href="../../../../dist/doc/renderers/dom/rekapi.renderer.dom.js.html#play">play</a></li><li><a href="../../../../dist/doc/renderers/dom/rekapi.renderer.dom.js.html#stop">stop</a></li><li><a href="../../../../dist/doc/renderers/dom/rekapi.renderer.dom.js.html#isPlaying">isPlaying</a></li><li><a href="../../../../dist/doc/renderers/dom/rekapi.renderer.dom.js.html#prerender">prerender</a></li><li><a href="../../../../dist/doc/renderers/dom/rekapi.renderer.dom.js.html#setActorTransformOrder">setActorTransformOrder</a></li><li><a href="../../../../dist/doc/renderers/dom/rekapi.renderer.dom.js.html#getActorClassName">getActorClassName</a></li><li><a href="../../../../dist/doc/renderers/dom/rekapi.renderer.dom.js.html#toString">toString</a></li></ul></div></div></div></div><div class="small-12 large-9 columns"><article class="comment"><header><h1 id="DOMRenderer">DOMRenderer</h1><h5 class="subheader"><div class="label radius ctx-type">method</div>Rekapi.DOMRenderer()</h5></header><ul class="no-bullet tags"><li class="tag"><span class="type">@param: </span><span class="types">{Rekapi}</span><span class="name">rekapi</span><span class="description"></span></li><li class="tag"><span class="type">@constructor: </span><span class="string"></span></li></ul><div data-section="accordian" data-options="one_up: false;" class="section-container code auto"><div class="section"><p data-section-title class="title"><a href="#">Description</a></p><div data-section-content class="content description"><p><code>DOMRenderer</code> allows you to animate DOM elements.  This is achieved either by browser-accelerated <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@keyframes">CSS <code>@keyframe</code> animations</a>, or by traditional inline style updates on every frame (like how <a href="http://api.jquery.com/animate/"><code>jQuery.fn.animate</code></a> works).  Animations are defined with the same API in either case, but you can gracefully fall back to the inline style approach if CSS <code>@keyframe</code> animations are not supported by the browser or not preferred.  To render animations with the DOM, just supply any DOM element to the <a href="../../src/rekapi.core.js.html#Rekapi"><code>Rekapi</code></a> constructor.  You may use <code>document.body</code>, since it is generally always available:</p>

<pre><code>var rekapi = new Rekapi(document.body);
rekapi.renderer instanceof Rekapi.DOMRenderer; // true
</code></pre>

<p><code></code></p>

<p>There are separate APIs for playing inline style animations and CSS <code>@keyframe</code> animations.  Advantages of playing an animation with CSS <code>@keyframes</code>:</p>

<ul>
<li>Smoother animations in modern browsers (particularly noticeable in Webkit and iOS browsers).</li>
<li>The JavaScript thread is freed from performing animation updates, making it available for other logic.</li>
</ul>

<p>Disadvantages:</p>

<ul>
<li>Not all browsers render CSS <code>@keyframe</code> animations smoothly.</li>
<li>Limited playback control: You can only play and stop an animation, you cannot jump to or start from a specific point in the timeline.</li>
<li>Generating the CSS for <code>@keyframe</code> animations can take a noticeable amount of time.  This blocks all other logic, including rendering, so you may have to be clever with how to spend the cycles to do it.</li>
<li>No <code>Rekapi</code> <a href="../../src/rekapi.core.js.html#on">events</a> can be bound to CSS <code>@keyframe</code> animations.</li>
</ul>

<p>So, the results are a little more predictable and flexible with inline style animations, but CSS <code>@keyframe</code> may give you better performance.  Choose whichever approach makes the most sense for your needs.</p>

<p><code>DOMRenderer</code> can gracefully fall back to an inline style animation if CSS <code>@keyframe</code> animations are not supported by the browser:</p>

<pre><code> var rekapi = new Rekapi(document.body);

 // Each actor needs a reference to the DOM element it represents
 var actor = rekapi.addActor({ context: document.getElementById('actor-1') });

 actor.keyframe(0,    { left: '0px'   });
 actor.keyframe(1000, { left: '250px' }, 'easeOutQuad');

 // Feature detect for CSS @keyframe support
 if (rekapi.renderer.canAnimateWithCSS()) {
   // Animate with CSS @keyframes
   rekapi.renderer.play();
 } else {
   // Animate inline styles instead
   rekapi.play();
 }
</code></pre>

<p><code></code></p>

<h2>CSS <code>@keyframe</code> animations are controlled differently from inline style animations</h2>

<p>Inline style animations are compatible with all of the playback and timeline control methods defined by <a href="../../src/rekapi.core.js.html#Rekapi"><code>Rekapi</code></a>, such as <a href="../../src/rekapi.core.js.html#play"><code>play</code></a>, <a href="../../src/rekapi.core.js.html#playFrom"><code>playFrom</code></a> and <a href="../../src/rekapi.core.js.html#update"><code>update</code></a>.  CSS <code>@keyframe</code> playback cannot be controlled, so <code>DOMRenderer</code> defines its own analogous, renderer-specific CSS playback methods that you should use:</p>

<ul>
<li><a href="#play"><code>play</code></a></li>
<li><a href="#isPlaying"><code>isPlaying</code></a></li>
<li><a href="#stop"><code>stop</code></a></li>
</ul>

<p>This is due to the playback control limitations of the CSS <code>@keyframe</code> specification.</p>

<p><strong>Note</strong>: <code>Rekapi.DOMRenderer</code> is instantiated for you automatically as <code>renderer</code>, there is no reason to call it yourself for most use cases.</p>

<p><strong><a href="/renderers/dom/sample/play-many-actors.html">Example</a></strong></p></div></div><div class="section"><p data-section-title class="title"><a href="#">Source</a></p><div data-section-content class="content"><pre><code class="language-javascript">Rekapi.DOMRenderer = function (rekapi) {
    this.rekapi = rekapi;

    // @private {number}
    this._playTimestamp = null;

    // @private {string}
    this._cachedCSS = null;

    // The HTMLStyleElement that gets injected into the DOM.
    // @private {HTMLStyleElement)
    this._styleElement = null;

    // @private {number}
    this._stopSetTimeoutHandle = null;

    rekapi.on('timelineModified', _.bind(function () {
      this._cachedCSS = null;
    }, this));

    rekapi.on('addActor', onAddActor);

    return this;
  };
  var DOMRenderer = Rekapi.DOMRenderer;</code></pre></div></div></div></article><article class="comment"><header><h1 id="canAnimateWithCSS">canAnimateWithCSS</h1><h5 class="subheader"><div class="label radius ctx-type">method</div>DOMRenderer.prototype.canAnimateWithCSS()</h5></header><ul class="no-bullet tags"><li class="tag"><span class="type">@return: </span><span class="types">{boolean}</span><span class="description"></span></li></ul><div data-section="accordian" data-options="one_up: false;" class="section-container code auto"><div class="section"><p data-section-title class="title"><a href="#">Description</a></p><div data-section-content class="content description"><p>Whether or not the browser supports CSS <code>@keyframe</code> animations.</p></div></div><div class="section"><p data-section-title class="title"><a href="#">Source</a></p><div data-section-content class="content"><pre><code class="language-javascript">DOMRenderer.prototype.canAnimateWithCSS = function () {
    return !!getVendorPrefix();
  };</code></pre></div></div></div></article><article class="comment"><header><h1 id="play">play</h1><h5 class="subheader"><div class="label radius ctx-type">method</div>DOMRenderer.prototype.play()</h5></header><ul class="no-bullet tags"><li class="tag"><span class="type">@param: </span><span class="types">{number=}</span><span class="name">opt_iterations</span><span class="description">How many times the animation should loop. This can be null or 0 if you want to loop the animation endlessly but also specify a value for opt_fps.</span></li><li class="tag"><span class="type">@param: </span><span class="types">{number=}</span><span class="name">opt_fps</span><span class="description">How many @keyframes to generate per second of the animation. A higher value results in a more precise CSS animation, but it will take longer to generate. The default value is 30. You should not need to go higher than 60.</span></li></ul><div data-section="accordian" data-options="one_up: false;" class="section-container code auto"><div class="section"><p data-section-title class="title"><a href="#">Description</a></p><div data-section-content class="content description"><p>Play the Rekapi animation as a CSS <code>@keyframe</code> animation.</p>

<p>Note that this is different from <a href="../../src/rekapi.core.js.html#play"><code>Rekapi#play</code></a>.  This method only applies to CSS <code>@keyframe</code> animations.</p></div></div><div class="section"><p data-section-title class="title"><a href="#">Source</a></p><div data-section-content class="content"><pre><code class="language-javascript">DOMRenderer.prototype.play = function (opt_iterations, opt_fps) {
    if (this.isPlaying()) {
      this.stop();
    }

    var css = this._cachedCSS || this.prerender.apply(this, arguments);
    this._styleElement = injectStyle(this.rekapi, css);
    this._playTimestamp = now();

    if (opt_iterations) {
      var animationLength = (opt_iterations * this.rekapi.getAnimationLength());
      this._stopSetTimeoutHandle = setTimeout(
          _.bind(this.stop, this, true),
          animationLength + INJECTED_STYLE_REMOVAL_BUFFER_MS);
    }

    fireEvent(this.rekapi, 'play', _);
  };</code></pre></div></div></div></article><article class="comment"><header><h1 id="stop">stop</h1><h5 class="subheader"><div class="label radius ctx-type">method</div>DOMRenderer.prototype.stop()</h5></header><ul class="no-bullet tags"><li class="tag"><span class="type">@param: </span><span class="types">{boolean=}</span><span class="name">opt_goToEnd</span><span class="description">If true, skip to the end of the animation. If false or omitted, set the actor elements to stay in their current position.</span></li></ul><div data-section="accordian" data-options="one_up: false;" class="section-container code auto"><div class="section"><p data-section-title class="title"><a href="#">Description</a></p><div data-section-content class="content description"><p>Stop a CSS <code>@keyframe</code> animation.  This also removes any <code>&lt;style&gt;</code> elements that were dynamically injected into the DOM.  This method sets inline styles on actor elements to stay either in their target or current position.</p>

<p>Note that this is different from <a href="../../src/rekapi.core.js.html#stop"><code>Rekapi#stop</code></a>.  This method only applies to CSS <code>@keyframe</code> animations.</p></div></div><div class="section"><p data-section-title class="title"><a href="#">Source</a></p><div data-section-content class="content"><pre><code class="language-javascript">DOMRenderer.prototype.stop = function (opt_goToEnd) {
    if (this.isPlaying()) {
      clearTimeout(this._stopSetTimeoutHandle);

      // Forces a style update in WebKit/Presto
      this._styleElement.innerHTML = '';

      document.head.removeChild(this._styleElement);
      this._styleElement = null;

      var updateTime;
      if (opt_goToEnd) {
        updateTime = this.rekapi.getAnimationLength();
      } else {
        updateTime = (now() - this._playTimestamp)
            % this.rekapi.getAnimationLength();
      }

      this.rekapi.update(updateTime);
      fireEvent(this.rekapi, 'stop', _);
    }
  };</code></pre></div></div></div></article><article class="comment"><header><h1 id="isPlaying">isPlaying</h1><h5 class="subheader"><div class="label radius ctx-type">method</div>DOMRenderer.prototype.isPlaying()</h5></header><ul class="no-bullet tags"><li class="tag"><span class="type">@return: </span><span class="types">{boolean}</span><span class="description"></span></li></ul><div data-section="accordian" data-options="one_up: false;" class="section-container code auto"><div class="section"><p data-section-title class="title"><a href="#">Description</a></p><div data-section-content class="content description"><p>Whether or not a CSS <code>@keyframe</code> animation is running.</p></div></div><div class="section"><p data-section-title class="title"><a href="#">Source</a></p><div data-section-content class="content"><pre><code class="language-javascript">DOMRenderer.prototype.isPlaying = function () {
    return !!this._styleElement;
  };</code></pre></div></div></div></article><article class="comment"><header><h1 id="prerender">prerender</h1><h5 class="subheader"><div class="label radius ctx-type">method</div>DOMRenderer.prototype.prerender()</h5></header><ul class="no-bullet tags"><li class="tag"><span class="type">@param: </span><span class="types">{number=}</span><span class="name">opt_iterations</span><span class="description">How many times the animation should loop. This can be null or 0 if you want to loop the animation endlessly but also specify a value for opt_fps.</span></li><li class="tag"><span class="type">@param: </span><span class="types">{number=}</span><span class="name">opt_fps</span><span class="description">How many @keyframes to prerender per second of the animation. A higher value results in a more precise CSS animation, but it will take longer to prerender. The default value is 30. You should not need to go higher than 60.</span></li><li class="tag"><span class="type">@return: </span><span class="types">{string}</span><span class="description">The prerendered CSS string. You likely won't need this, as it is also cached internally.</span></li></ul><div data-section="accordian" data-options="one_up: false;" class="section-container code auto"><div class="section"><p data-section-title class="title"><a href="#">Description</a></p><div data-section-content class="content description"><p>Prerender and cache the CSS animation so that it is immediately ready to be used when it is needed in the future.  The function signature is identical to <a href="#play"><code>DOMRenderer#play</code></a>.  This is necessary to play a CSS animation and will be automatically called for you if you don't call it manually, but calling it ahead of time (such as on page load) will prevent any perceived lag when a CSS <code>@keyframe</code> animation is started.  The prerendered animation is cached for reuse until the timeline or a keyframe is modified.</p></div></div><div class="section"><p data-section-title class="title"><a href="#">Source</a></p><div data-section-content class="content"><pre><code class="language-javascript">DOMRenderer.prototype.prerender = function (opt_iterations, opt_fps) {
    return this._cachedCSS = this.toString({
      'vendors': [getVendorPrefix()]
      ,'fps': opt_fps
      ,'iterations': opt_iterations
    });
  };</code></pre></div></div></div></article><article class="comment"><header><h1 id="setActorTransformOrder">setActorTransformOrder</h1><h5 class="subheader"><div class="label radius ctx-type">method</div>DOMRenderer.prototype.setActorTransformOrder()</h5></header><ul class="no-bullet tags"><li class="tag"><span class="type">@param: </span><span class="types">{Rekapi.Actor}</span><span class="name">actor</span><span class="description"></span></li><li class="tag"><span class="type">@param: </span><span class="types">{Array.&lt;string&gt;}</span><span class="name">orderedTransforms</span><span class="description">The array of transform names.</span></li><li class="tag"><span class="type">@return: </span><span class="types">{Rekapi}</span><span class="description"></span></li></ul><div data-section="accordian" data-options="one_up: false;" class="section-container code auto"><div class="section"><p data-section-title class="title"><a href="#">Description</a></p><div data-section-content class="content description"><p>You can decouple transform components in order to animate each property with its own easing curve:</p>

<pre><code>actor
  .keyframe(0, {
    'translateX': '0px'
    ,'translateY': '0px'
    ,'rotate': '0deg'
  })
  .keyframe(1500, {
    'translateX': '200px'
    ,'translateY': '200px'
    ,'rotate': '90deg'
  }, {
    'translateX': 'easeOutExpo'
    ,'translateY': 'easeInSine'
    ,'rotate': 'elastic'
  });
</code></pre>

<p><code></code></p>

<p>CSS transform string components are order-dependent, but JavaScript object properties have an unpredictable order.  Rekapi must combine transform properties supplied to <a href="../../src/rekapi.actor.js.html#keyframe"><code>Rekapi.Actor.keyframe</code></a> (as shown above) into a single string when it renders each frame.  This method lets you change that order from the default.  The supported array values for <code>orderedTransforms</code> are:</p>

<ul>
<li><code>translateX</code></li>
<li><code>translateY</code></li>
<li><code>translateZ</code></li>
<li><code>scale</code></li>
<li><code>scaleX</code></li>
<li><code>scaleY</code></li>
<li><code>rotate</code></li>
<li><code>skewX</code></li>
<li><code>skewY</code></li>
</ul>

<p>If you prefer a more standards-oriented approach, Rekapi also supports combining the transform components yourself:</p>

<pre><code>actor
  .keyframe(0, {
    'transform': 'translateX(0px) translateY(0px) rotate(0deg)'
  })
  .keyframe(1500, {
    'transform': 'translateX(200px) translateY(200px) rotate(90deg)'
  }, {
    'transform': 'easeOutExpo easeInSine elastic'
  });
</code></pre>

<p><code></code></p>

<p>This example and the one above it are equivalent.</p>

<p><strong>Note</strong>: The decoupled form of <code>transform</code> animations is not supported in CSS <code>@keyframe</code> animations, only inline style animations.  This is due to the tightly-coupled nature of the CSS <code>@keyframes</code> spec.  If you intend to play a CSS-based <code>@keyframe</code> animation, <strong>do not</strong> use the non-standard decoupled API form for <code>transform</code> properties.</p></div></div><div class="section"><p data-section-title class="title"><a href="#">Source</a></p><div data-section-content class="content"><pre><code class="language-javascript">DOMRenderer.prototype.setActorTransformOrder = function (actor, orderedTransforms) {
    // TODO: Document this better...
    var unknownFunctions = _.reject(orderedTransforms, isTransformFunction);

    if (unknownFunctions.length) {
      throw 'Unknown or unsupported transform functions: ' +
        unknownFunctions.join(', ');
    }
    // Ignore duplicate transform function names in the array
    actor._transformOrder = _.uniq(orderedTransforms);

    return this.rekapi;
  };</code></pre></div></div></div></article><article class="comment"><header><h1 id="getActorClassName">getActorClassName</h1><h5 class="subheader"><div class="label radius ctx-type">method</div>DOMRenderer.getActorClassName()</h5></header><ul class="no-bullet tags"><li class="tag"><span class="type">@param: </span><span class="types">{Rekapi.Actor}</span><span class="name">actor</span><span class="description"></span></li><li class="tag"><span class="type">@return: </span><span class="types">{string}</span><span class="description"></span></li></ul><div data-section="accordian" data-options="one_up: false;" class="section-container code auto"><div class="section"><p data-section-title class="title"><a href="#">Description</a></p><div data-section-content class="content description"><p>This is the default CSS class that is targeted by <a href="../css-animate/rekapi.renderer.dom.js.html">DOMRenderer#toString</a> if a custom class is not specified.  This may be useful for getting a standard and consistent CSS class name for an actor's DOM element.</p></div></div><div class="section"><p data-section-title class="title"><a href="#">Source</a></p><div data-section-content class="content"><pre><code class="language-javascript">DOMRenderer.getActorClassName = function (actor) {
    return 'actor-' + actor.id;
  };</code></pre></div></div></div></article><article class="comment"><header><h1 id="toString">toString</h1><h5 class="subheader"><div class="label radius ctx-type">method</div>Rekapi.DOMRenderer.prototype.toString()</h5></header><ul class="no-bullet tags"><li class="tag"><span class="type">@param: </span><span class="types">{Object=}</span><span class="name">opts</span><span class="description"></span></li><li class="tag"><span class="type">@return: </span><span class="types">{string}</span><span class="description"></span></li></ul><div data-section="accordian" data-options="one_up: false;" class="section-container code auto"><div class="section"><p data-section-title class="title"><a href="#">Description</a></p><div data-section-content class="content description"><p>Converts Rekapi animations to CSS <code>@keyframes</code>.</p>

<h2><code>opts</code></h2>

<p>You can specify some parameters for your CSS animation.  They are all optional:</p>

<ul>
<li><strong>vendors</strong> <em>(Array)</em>: Defaults to <code>['w3']</code>.  The browser vendors you want to support. Valid values are:
<ul><li><code>'microsoft'</code></li>
<li><code>'mozilla'</code></li>
<li><code>'opera'</code></li>
<li><code>'w3'</code></li>
<li><code>'webkit'</code></li></ul></li>
<li><strong>fps</strong> <em>(number)</em>: Defaults to 30.  Defines the number of CSS <code>@keyframe</code> frames rendered per second of an animation.  CSS <code>@keyframes</code> are comprised of a series of explicitly defined steps, and more steps will allow for a more complex animation.  More steps will also result in a larger CSS string, and more time needed to generate the string.</li>
<li><strong>name</strong> <em>(string)</em>: Define a custom name for your animation.  This becomes the class name targeted by the generated CSS.  The default value is determined by a call to <a href="#getActorClassName"><code>getActorClassName</code></a>.</li>
<li><strong>isCentered</strong> <em>(boolean)</em>: If <code>true</code>, the generated CSS will contain <code>transform-origin: 0 0;</code>, which centers the DOM element along the path of motion.  If <code>false</code> or omitted, no <code>transform-origin</code> rule is specified and the element is aligned to the path of motion with its top-left corner.</li>
<li><strong>iterations</strong> <em>(number)</em>: How many times the generated animation should repeat.  If omitted, the animation will loop indefinitely.</li>
</ul></div></div><div class="section"><p data-section-title class="title"><a href="#">Source</a></p><div data-section-content class="content"><pre><code class="language-javascript">Rekapi.DOMRenderer.prototype.toString = function (opts) {
    opts = opts || {};
    var animationCSS = [];

    _.each(this.rekapi.getAllActors(), function (actor) {
      if (actor.context.nodeType === 1) {
        animationCSS.push(getActorCSS(actor, opts));
      }
    });

    return animationCSS.join('\n');
  };

  // DOMRenderer.prototype.toString-SPECIFIC CODE
  //

  // CONSTANTS
  //

  var DEFAULT_FPS = 30;
  var TRANSFORM_TOKEN = 'TRANSFORM';
  var VENDOR_TOKEN = 'VENDOR';
  var VENDOR_PREFIXES = {
    'microsoft': '-ms-'
    ,'mozilla': '-moz-'
    ,'opera': '-o-'
    ,'w3': ''
    ,'webkit': '-webkit-'
  };
  var BEZIERS = {
    linear: '.25,.25,.75,.75'
    ,easeInQuad: '.55,.085,.68,.53'
    ,easeInCubic: '.55,.055,.675,.19'
    ,easeInQuart: '.895,.03,.685,.22'
    ,easeInQuint: '.755,.05,.855,.06'
    ,easeInSine: '.47,0,.745,.715'
    ,easeInExpo: '.95,.05,.795,.035'
    ,easeInCirc: '.6,.04,.98, .335'
    ,easeOutQuad: '.25,.46,.45,.94'
    ,easeOutCubic: '.215,.61,.355,1'
    ,easeOutQuart: '.165,.84,.44,1'
    ,easeOutQuint: '.23,1,.32,1'
    ,easeOutSine: '.39,.575,.565,1'
    ,easeOutExpo: '.19,1,.22,1'
    ,easeOutCirc: '.075,.82,.165,1'
    ,easeInOutQuad: '.455,.03,.515,.955'
    ,easeInOutCubic: '.645,.045,.355,1'
    ,easeInOutQuart: '.77,0,.175,1'
    ,easeInOutQuint: '.86,0.07,1'
    ,easeInOutSine: '.445,.05,.55,.95'
    ,easeInOutExpo: '1,0,0,1'
    ,easeInOutCirc: '.785,.135,.15,.86'
  };

  // TEMPLATES
  //</code></pre></div></div></div></article></div></div><!-- Foundation JS--><script type="text/javascript">document.write('<script src=' +
('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0/zepto.min' : 'http://cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min') +
'.js><\/script>')
</script><script src="http://cdnjs.cloudflare.com/ajax/libs/foundation/4.1.6/js/foundation.min.js"></script><script src="http://cdnjs.cloudflare.com/ajax/libs/foundation/4.1.6/js/foundation/foundation.reveal.min.js"></script><!-- Prism js--><script>/**
 * Prism: Lightweight, robust, elegant syntax highlighting
 * MIT license http://www.opensource.org/licenses/mit-license.php/
 * @author Lea Verou http://lea.verou.me
 */(function(){var e=/\blang(?:uage)?-(?!\*)(\w+)\b/i,t=self.Prism={util:{type:function(e){return Object.prototype.toString.call(e).match(/\[object (\w+)\]/)[1]},clone:function(e){var n=t.util.type(e);switch(n){case"Object":var r={};for(var i in e)e.hasOwnProperty(i)&&(r[i]=t.util.clone(e[i]));return r;case"Array":return e.slice()}return e}},languages:{extend:function(e,n){var r=t.util.clone(t.languages[e]);for(var i in n)r[i]=n[i];return r},insertBefore:function(e,n,r,i){i=i||t.languages;var s=i[e],o={};for(var u in s)if(s.hasOwnProperty(u)){if(u==n)for(var a in r)r.hasOwnProperty(a)&&(o[a]=r[a]);o[u]=s[u]}return i[e]=o},DFS:function(e,n){for(var r in e){n.call(e,r,e[r]);t.util.type(e)==="Object"&&t.languages.DFS(e[r],n)}}},highlightAll:function(e,n){var r=document.querySelectorAll('code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code');for(var i=0,s;s=r[i++];)t.highlightElement(s,e===!0,n)},highlightElement:function(r,i,s){var o,u,a=r;while(a&&!e.test(a.className))a=a.parentNode;if(a){o=(a.className.match(e)||[,""])[1];u=t.languages[o]}if(!u)return;r.className=r.className.replace(e,"").replace(/\s+/g," ")+" language-"+o;a=r.parentNode;/pre/i.test(a.nodeName)&&(a.className=a.className.replace(e,"").replace(/\s+/g," ")+" language-"+o);var f=r.textContent;if(!f)return;f=f.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/\u00a0/g," ");var l={element:r,language:o,grammar:u,code:f};t.hooks.run("before-highlight",l);if(i&&self.Worker){var c=new Worker(t.filename);c.onmessage=function(e){l.highlightedCode=n.stringify(JSON.parse(e.data),o);t.hooks.run("before-insert",l);l.element.innerHTML=l.highlightedCode;s&&s.call(l.element);t.hooks.run("after-highlight",l)};c.postMessage(JSON.stringify({language:l.language,code:l.code}))}else{l.highlightedCode=t.highlight(l.code,l.grammar,l.language);t.hooks.run("before-insert",l);l.element.innerHTML=l.highlightedCode;s&&s.call(r);t.hooks.run("after-highlight",l)}},highlight:function(e,r,i){return n.stringify(t.tokenize(e,r),i)},tokenize:function(e,n,r){var i=t.Token,s=[e],o=n.rest;if(o){for(var u in o)n[u]=o[u];delete n.rest}e:for(var u in n){if(!n.hasOwnProperty(u)||!n[u])continue;var a=n[u],f=a.inside,l=!!a.lookbehind,c=0;a=a.pattern||a;for(var h=0;h<s.length;h++){var p=s[h];if(s.length>e.length)break e;if(p instanceof i)continue;a.lastIndex=0;var d=a.exec(p);if(d){l&&(c=d[1].length);var v=d.index-1+c,d=d[0].slice(c),m=d.length,g=v+m,y=p.slice(0,v+1),b=p.slice(g+1),w=[h,1];y&&w.push(y);var E=new i(u,f?t.tokenize(d,f):d);w.push(E);b&&w.push(b);Array.prototype.splice.apply(s,w)}}}return s},hooks:{all:{},add:function(e,n){var r=t.hooks.all;r[e]=r[e]||[];r[e].push(n)},run:function(e,n){var r=t.hooks.all[e];if(!r||!r.length)return;for(var i=0,s;s=r[i++];)s(n)}}},n=t.Token=function(e,t){this.type=e;this.content=t};n.stringify=function(e,r,i){if(typeof e=="string")return e;if(Object.prototype.toString.call(e)=="[object Array]")return e.map(function(t){return n.stringify(t,r,e)}).join("");var s={type:e.type,content:n.stringify(e.content,r,i),tag:"span",classes:["token",e.type],attributes:{},language:r,parent:i};s.type=="comment"&&(s.attributes.spellcheck="true");t.hooks.run("wrap",s);var o="";for(var u in s.attributes)o+=u+'="'+(s.attributes[u]||"")+'"';return"<"+s.tag+' class="'+s.classes.join(" ")+'" '+o+">"+s.content+"</"+s.tag+">"};if(!self.document){self.addEventListener("message",function(e){var n=JSON.parse(e.data),r=n.language,i=n.code;self.postMessage(JSON.stringify(t.tokenize(i,t.languages[r])));self.close()},!1);return}var r=document.getElementsByTagName("script");r=r[r.length-1];if(r){t.filename=r.src;document.addEventListener&&!r.hasAttribute("data-manual")&&document.addEventListener("DOMContentLoaded",t.highlightAll)}})();;
Prism.languages.markup={comment:/&lt;!--[\w\W]*?-->/g,prolog:/&lt;\?.+?\?>/,doctype:/&lt;!DOCTYPE.+?>/,cdata:/&lt;!\[CDATA\[[\w\W]*?]]>/i,tag:{pattern:/&lt;\/?[\w:-]+\s*(?:\s+[\w:-]+(?:=(?:("|')(\\?[\w\W])*?\1|\w+))?\s*)*\/?>/gi,inside:{tag:{pattern:/^&lt;\/?[\w:-]+/i,inside:{punctuation:/^&lt;\/?/,namespace:/^[\w-]+?:/}},"attr-value":{pattern:/=(?:('|")[\w\W]*?(\1)|[^\s>]+)/gi,inside:{punctuation:/=|>|"/g}},punctuation:/\/?>/g,"attr-name":{pattern:/[\w:-]+/g,inside:{namespace:/^[\w-]+?:/}}}},entity:/&amp;#?[\da-z]{1,8};/gi};Prism.hooks.add("wrap",function(e){e.type==="entity"&&(e.attributes.title=e.content.replace(/&amp;/,"&"))});;
Prism.languages.css={comment:/\/\*[\w\W]*?\*\//g,atrule:{pattern:/@[\w-]+?.*?(;|(?=\s*{))/gi,inside:{punctuation:/[;:]/g}},url:/url\((["']?).*?\1\)/gi,selector:/[^\{\}\s][^\{\};]*(?=\s*\{)/g,property:/(\b|\B)[\w-]+(?=\s*:)/ig,string:/("|')(\\?.)*?\1/g,important:/\B!important\b/gi,ignore:/&(lt|gt|amp);/gi,punctuation:/[\{\};:]/g};Prism.languages.markup&&Prism.languages.insertBefore("markup","tag",{style:{pattern:/(&lt;|<)style[\w\W]*?(>|&gt;)[\w\W]*?(&lt;|<)\/style(>|&gt;)/ig,inside:{tag:{pattern:/(&lt;|<)style[\w\W]*?(>|&gt;)|(&lt;|<)\/style(>|&gt;)/ig,inside:Prism.languages.markup.tag.inside},rest:Prism.languages.css}}});;
Prism.languages.clike={comment:{pattern:/(^|[^\\])(\/\*[\w\W]*?\*\/|(^|[^:])\/\/.*?(\r?\n|$))/g,lookbehind:!0},string:/("|')(\\?.)*?\1/g,"class-name":{pattern:/((?:(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[a-z0-9_\.\\]+/ig,lookbehind:!0,inside:{punctuation:/(\.|\\)/}},keyword:/\b(if|else|while|do|for|return|in|instanceof|function|new|try|catch|finally|null|break|continue)\b/g,"boolean":/\b(true|false)\b/g,"function":{pattern:/[a-z0-9_]+\(/ig,inside:{punctuation:/\(/}}, number:/\b-?(0x[\dA-Fa-f]+|\d*\.?\d+([Ee]-?\d+)?)\b/g,operator:/[-+]{1,2}|!|&lt;=?|>=?|={1,3}|(&amp;){1,2}|\|?\||\?|\*|\/|\~|\^|\%/g,ignore:/&(lt|gt|amp);/gi,punctuation:/[{}[\];(),.:]/g};;
Prism.languages.javascript=Prism.languages.extend("clike",{keyword:/\b(var|let|if|else|while|do|for|return|in|instanceof|function|new|with|typeof|try|catch|finally|null|break|continue)\b/g,number:/\b-?(0x[\dA-Fa-f]+|\d*\.?\d+([Ee]-?\d+)?|NaN|-?Infinity)\b/g});Prism.languages.insertBefore("javascript","keyword",{regex:{pattern:/(^|[^/])\/(?!\/)(\[.+?]|\\.|[^/\r\n])+\/[gim]{0,3}(?=\s*($|[\r\n,.;})]))/g,lookbehind:!0}});Prism.languages.markup&&Prism.languages.insertBefore("markup","tag",{script:{pattern:/(&lt;|<)script[\w\W]*?(>|&gt;)[\w\W]*?(&lt;|<)\/script(>|&gt;)/ig,inside:{tag:{pattern:/(&lt;|<)script[\w\W]*?(>|&gt;)|(&lt;|<)\/script(>|&gt;)/ig,inside:Prism.languages.markup.tag.inside},rest:Prism.languages.javascript}}});;
Prism.languages.coffeescript=Prism.languages.extend("javascript",{"block-comment":/([#]{3}\s*\r?\n(.*\s*\r*\n*)\s*?\r?\n[#]{3})/g,comment:/(\s|^)([#]{1}[^#^\r^\n]{2,}?(\r?\n|$))/g,keyword:/\b(this|window|delete|class|extends|namespace|extend|ar|let|if|else|while|do|for|each|of|return|in|instanceof|new|with|typeof|try|catch|finally|null|undefined|break|continue)\b/g});Prism.languages.insertBefore("coffeescript","keyword",{"function":{pattern:/[a-z|A-z]+\s*[:|=]\s*(\([.|a-z\s|,|:|{|}|\"|\'|=]*\))?\s*-&gt;/gi,inside:{"function-name":/[_?a-z-|A-Z-]+(\s*[:|=])| @[_?$?a-z-|A-Z-]+(\s*)| /g,operator:/[-+]{1,2}|!|=?&lt;|=?&gt;|={1,2}|(&amp;){1,2}|\|?\||\?|\*|\//g}},"attr-name":/[_?a-z-|A-Z-]+(\s*:)| @[_?$?a-z-|A-Z-]+(\s*)| /g});;
Prism.languages.scss=Prism.languages.extend("css",{comment:{pattern:/(^|[^\\])(\/\*[\w\W]*?\*\/|\/\/.*?(\r?\n|$))/g,lookbehind:!0},atrule:/@[\w-]+(?=\s+(\(|\{|;))/gi,url:/([-a-z]+-)*url(?=\()/gi,selector:/([^@;\{\}\(\)]?([^@;\{\}\(\)]|&amp;|\#\{\$[-_\w]+\})+)(?=\s*\{(\}|\s|[^\}]+(:|\{)[^\}]+))/gm});Prism.languages.insertBefore("scss","atrule",{keyword:/@(if|else if|else|for|each|while|import|extend|debug|warn|mixin|include|function|return)|(?=@for\s+\$[-_\w]+\s)+from/i});Prism.languages.insertBefore("scss","property",{variable:/((\$[-_\w]+)|(#\{\$[-_\w]+\}))/i});Prism.languages.insertBefore("scss","ignore",{placeholder:/%[-_\w]+/i,statement:/\B!(default|optional)\b/gi,"boolean":/\b(true|false)\b/g,"null":/\b(null)\b/g,operator:/\s+([-+]{1,2}|={1,2}|!=|\|?\||\?|\*|\/|\%)\s+/g});
;
</script><script>  var headerHeight = 64;

  $(document).foundation();

  $(function(){
    $('pre code').addClass('language-javascript');
  //   $('#nav > ul > li > a[href$="'+location.pathname.substring(location.pathname.lastIndexOf('/')+1, location.pathname.length)+'"]').parent().addClass('active');
  })</script></body></html>