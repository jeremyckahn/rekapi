<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>rekapi.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <li class="nav-link nav-home-link"><a href="index.html">Home</a></li><li class="nav-heading">Tutorials</li><li class="nav-item"><a href="tutorial-dom-rendering-in-depth.html">DOM Rendering in Depth</a></li><li class="nav-item"><a href="tutorial-getting-started.html">Getting Started</a></li><li class="nav-item"><a href="tutorial-keyframes-in-depth.html">Keyframes in Depth</a></li><li class="nav-item"><a href="tutorial-multiple-renderers.html">Multiple Renderers</a></li><li class="nav-heading">Classes</li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="rekapi.Actor.html">Actor</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.Actor.html#addKeyframeProperty">addKeyframeProperty</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.Actor.html#copyKeyframe">copyKeyframe</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.Actor.html#exportTimeline">exportTimeline</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.Actor.html#getEnd">getEnd</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.Actor.html#getKeyframeProperty">getKeyframeProperty</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.Actor.html#getLength">getLength</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.Actor.html#getPropertiesInTrack">getPropertiesInTrack</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.Actor.html#getStart">getStart</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.Actor.html#getTrackNames">getTrackNames</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.Actor.html#hasKeyframeAt">hasKeyframeAt</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.Actor.html#importTimeline">importTimeline</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.Actor.html#keyframe">keyframe</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.Actor.html#modifyKeyframe">modifyKeyframe</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.Actor.html#modifyKeyframeProperty">modifyKeyframeProperty</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.Actor.html#moveKeyframe">moveKeyframe</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.Actor.html#removeAllKeyframes">removeAllKeyframes</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.Actor.html#removeKeyframe">removeKeyframe</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.Actor.html#removeKeyframeProperty">removeKeyframeProperty</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.Actor.html#wait">wait</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="rekapi.CanvasRenderer.html">CanvasRenderer</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.CanvasRenderer.html#clear">clear</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.CanvasRenderer.html#height">height</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.CanvasRenderer.html#width">width</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="rekapi.DOMRenderer.html">DOMRenderer</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.DOMRenderer.html#canAnimateWithCSS">canAnimateWithCSS</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.DOMRenderer.html#getCss">getCss</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.DOMRenderer.html#isPlaying">isPlaying</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.DOMRenderer.html#play">play</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.DOMRenderer.html#prerender">prerender</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.DOMRenderer.html#setActorTransformOrder">setActorTransformOrder</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.DOMRenderer.html#stop">stop</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="rekapi.KeyframeProperty.html">KeyframeProperty</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.KeyframeProperty.html#detach">detach</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.KeyframeProperty.html#exportPropertyData">exportPropertyData</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.KeyframeProperty.html#getValueAt">getValueAt</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.KeyframeProperty.html#invoke">invoke</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.KeyframeProperty.html#linkToNext">linkToNext</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.KeyframeProperty.html#modifyWith">modifyWith</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="rekapi.Rekapi.html">Rekapi</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.Rekapi.html#addActor">addActor</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.Rekapi.html#exportTimeline">exportTimeline</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.Rekapi.html#getActor">getActor</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.Rekapi.html#getActorCount">getActorCount</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.Rekapi.html#getActorIds">getActorIds</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.Rekapi.html#getAllActors">getAllActors</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.Rekapi.html#getAnimationLength">getAnimationLength</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.Rekapi.html#getEventNames">getEventNames</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.Rekapi.html#getLastMillisecondUpdated">getLastMillisecondUpdated</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.Rekapi.html#getLastPositionUpdated">getLastPositionUpdated</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.Rekapi.html#getRendererInstance">getRendererInstance</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.Rekapi.html#importTimeline">importTimeline</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.Rekapi.html#isPaused">isPaused</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.Rekapi.html#isPlaying">isPlaying</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.Rekapi.html#isStopped">isStopped</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.Rekapi.html#moveActorToPosition">moveActorToPosition</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.Rekapi.html#off">off</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.Rekapi.html#on">on</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.Rekapi.html#pause">pause</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.Rekapi.html#play">play</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.Rekapi.html#playFrom">playFrom</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.Rekapi.html#playFromCurrent">playFromCurrent</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.Rekapi.html#removeActor">removeActor</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.Rekapi.html#removeAllActors">removeAllActors</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.Rekapi.html#stop">stop</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.Rekapi.html#trigger">trigger</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="rekapi.Rekapi.html#update">update</a></span></li><li class="nav-heading">Namespaces</li><li class="nav-heading"><span class="nav-item-type type-namespace">N</span><span class="nav-item-name"><a href="rekapi.html">rekapi</a></span></li>
</nav>

<div id="main">
    
    <h1 class="page-title">rekapi.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import _ from 'lodash';
import { Tweenable, setBezierFunction } from 'shifty';
import { Actor } from './actor';

const UPDATE_TIME = 1000 / 60;

export const DEFAULT_EASING = 'linear';

/*!
 * Fire an event bound to a Rekapi.
 * @param {Rekapi} rekapi
 * @param {string} eventName
 * @param {Object} [data={}] Optional event-specific data
 */
export const fireEvent = (rekapi, eventName, data = {}) =>
  rekapi._events[eventName].forEach(handler => handler(rekapi, data));

/*!
 * @param {Rekapi} rekapi
 */
export const invalidateAnimationLength = rekapi =>
  rekapi._animationLengthValid = false;

/*!
 * Determines which iteration of the loop the animation is currently in.
 * @param {Rekapi} rekapi
 * @param {number} timeSinceStart
 */
export const determineCurrentLoopIteration = (rekapi, timeSinceStart) => {
  const animationLength = rekapi.getAnimationLength();

  if (animationLength === 0) {
    return timeSinceStart;
  }

  return Math.floor(timeSinceStart / animationLength);
};

/*!
 * Calculate how many milliseconds since the animation began.
 * @param {Rekapi} rekapi
 * @return {number}
 */
export const calculateTimeSinceStart = rekapi =>
  Tweenable.now() - rekapi._loopTimestamp;

/*!
 * Determines if the animation is complete or not.
 * @param {Rekapi} rekapi
 * @param {number} currentLoopIteration
 * @return {boolean}
 */
export const isAnimationComplete = (rekapi, currentLoopIteration) =>
  currentLoopIteration >= rekapi._timesToIterate
    &amp;&amp; rekapi._timesToIterate !== -1;

/*!
 * Stops the animation if it is complete.
 * @param {Rekapi} rekapi
 * @param {number} currentLoopIteration
 */
export const updatePlayState = (rekapi, currentLoopIteration) => {
  if (isAnimationComplete(rekapi, currentLoopIteration)) {
    rekapi.stop();
    fireEvent(rekapi, 'animationComplete');
  }
};

/*!
 * Calculate how far in the animation loop `rekapi` is, in milliseconds,
 * based on the current time.  Also overflows into a new loop if necessary.
 * @param {Rekapi} rekapi
 * @param {number} forMillisecond
 * @param {number} currentLoopIteration
 * @return {number}
 */
export const calculateLoopPosition = (rekapi, forMillisecond, currentLoopIteration) => {
  const animationLength = rekapi.getAnimationLength();

  return animationLength === 0 ?
    0 :
    isAnimationComplete(rekapi, currentLoopIteration) ?
      animationLength :
      forMillisecond % animationLength;
};

/*!
 * Calculate the timeline position and state for a given millisecond.
 * Updates the `rekapi` state internally and accounts for how many loop
 * iterations the animation runs for.
 * @param {Rekapi} rekapi
 * @param {number} forMillisecond
 */
export const updateToMillisecond = (rekapi, forMillisecond) => {
  const currentIteration = determineCurrentLoopIteration(rekapi, forMillisecond);
  const loopPosition = calculateLoopPosition(
    rekapi, forMillisecond, currentIteration
  );

  rekapi._loopPosition = loopPosition;

  let keyframeResetList = [];

  if (currentIteration > rekapi._latestIteration) {
    fireEvent(rekapi, 'animationLooped');

    // Reset function keyframes
    const lookupObject = { name: 'function' };

    rekapi._actors.forEach(actor => {
      const fnKeyframes = _.where(actor._keyframeProperties, lookupObject);
      const lastFnKeyframe = _.last(fnKeyframes);

      if (lastFnKeyframe &amp;&amp; !lastFnKeyframe.hasFired) {
        lastFnKeyframe.invoke();
      }

      keyframeResetList = keyframeResetList.concat(fnKeyframes);
    });
  }

  rekapi._latestIteration = currentIteration;
  rekapi.update(loopPosition, true);
  updatePlayState(rekapi, currentIteration);

  _.each(keyframeResetList, fnKeyframe => {
    fnKeyframe.hasFired = false;
  });
};

/*!
 * Calculate how far into the animation loop `rekapi` is, in milliseconds,
 * and update based on that time.
 * @param {Rekapi} rekapi
 */
export const updateToCurrentMillisecond = rekapi =>
  updateToMillisecond(rekapi, calculateTimeSinceStart(rekapi));

/*!
 * This is the heartbeat of an animation.  This updates `rekapi`'s state and
 * then calls itself continuously.
 * @param {Rekapi} rekapi
 */
const tick = rekapi =>
  // Need to check for .call presence to get around an IE limitation.  See
  // annotation for cancelLoop for more info.
  rekapi._loopId = rekapi._scheduleUpdate.call ?
    rekapi._scheduleUpdate.call(global, rekapi._updateFn, UPDATE_TIME) :
    setTimeout(rekapi._updateFn, UPDATE_TIME);

/*!
 * @return {Function}
 */
const getUpdateMethod = () =>
  // requestAnimationFrame() shim by Paul Irish (modified for Rekapi)
  // http://paulirish.com/2011/requestanimationframe-for-smart-animating/
  global.requestAnimationFrame       ||
  global.webkitRequestAnimationFrame ||
  global.oRequestAnimationFrame      ||
  global.msRequestAnimationFrame     ||
  (global.mozCancelRequestAnimationFrame &amp;&amp; global.mozRequestAnimationFrame) ||
  global.setTimeout;

/*!
 * @return {Function}
 */
const getCancelMethod = () =>
  global.cancelAnimationFrame           ||
  global.webkitCancelAnimationFrame     ||
  global.oCancelAnimationFrame          ||
  global.msCancelAnimationFrame         ||
  global.mozCancelRequestAnimationFrame ||
  global.clearTimeout;

/*!
 * Cancels an update loop.  This abstraction is needed to get around the fact
 * that in IE, clearTimeout is not technically a function
 * (https://twitter.com/kitcambridge/status/206655060342603777) and thus
 * Function.prototype.call cannot be used upon it.
 * @param {Rekapi} rekapi
 */
const cancelLoop = rekapi =>
  rekapi._cancelUpdate.call ?
    rekapi._cancelUpdate.call(global, rekapi._loopId) :
    clearTimeout(rekapi._loopId);

const STOPPED = 'stopped';
const PAUSED = 'paused';
const PLAYING = 'playing';

/*!
 * @type {Object.&lt;function>} Contains the context init function to be called in
 * the Rekapi constructor.  This array is populated by modules in the
 * renderers/ directory.
 */
export const rendererBootstrappers = [];

/**
 * If this is a rendered animation, the appropriate renderer is accessible as
 * `this.renderer`.  If provided, a reference to `context` is accessible
 * as `this.context`.
 * @param {(Object|CanvasRenderingContext2D|HTMLElement)} [context={}] Sets
 * {@link rekapi.Rekapi#context}. This determines how to render the animation.
 * {@link rekapi.Rekapi} will also automatically set up all necessary {@link
 * rekapi.Rekapi#renderers} based on this value:
 *
 * * If this is not provided or is a plain object (`{}`), the animation will
 * not render anything and {@link rekapi.Rekapi#renderers} will be empty.
 * * If this is a
 * [`CanvasRenderingContext2D`](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D),
 * {@link rekapi.Rekapi#renderers} will contain a {@link
 * rekapi.CanvasRenderer}.
 * * If this is a DOM element, {@link rekapi.Rekapi#renderers} will contain a
 * {@link rekapi.DOMRenderer}.
 * @constructs rekapi.Rekapi
 */
export class Rekapi {
  constructor (context = {}) {
    /**
     * @member {(Object|CanvasRenderingContext2D|HTMLElement)}
     * rekapi.Rekapi#context The rendering context for an animation.
     * @default {}
     */
    this.context = context;
    this._actors = [];
    this._playState = STOPPED;

    /**
     * @member {(rekapi.actorSortFunction|null)} rekapi.Rekapi#sort Optional
     * function for sorting the render order of {@link rekapi.Actor}s.  If set,
     * this is called each frame before the {@link rekapi.Actor}s are rendered.
     * If not set, {@link rekapi.Actor}s will render in the order they were
     * added via {@link rekapi.Rekapi#addActor}.
     *
     * The following example assumes that all {@link rekapi.Actor}s are circles
     * that have a `radius` {@link rekapi.KeyframeProperty}.  The circles will
     * be rendered in order of the value of their `radius`, from smallest to
     * largest.  This has the effect of layering larger circles on top of
     * smaller circles, thus giving a sense of perspective.
     *
     *     const rekapi = new Rekapi();
     *     rekapi.sort = actor => actor.get().radius;
     * @default null
     */
    this.sort = null;

    this._events = {
      animationComplete: [],
      playStateChange: [],
      play: [],
      pause: [],
      stop: [],
      beforeUpdate: [],
      afterUpdate: [],
      addActor: [],
      removeActor: [],
      beforeAddKeyframeProperty: [],
      addKeyframeProperty: [],
      removeKeyframeProperty: [],
      removeKeyframePropertyComplete: [],
      beforeRemoveKeyframeProperty: [],
      addKeyframePropertyTrack: [],
      removeKeyframePropertyTrack: [],
      timelineModified: [],
      animationLooped: []
    };

    // How many times to loop the animation before stopping
    this._timesToIterate = -1;

    // Millisecond duration of the animation
    this._animationLength = 0;
    this._animationLengthValid = false;

    // The setTimeout ID of `tick`
    this._loopId = null;

    // The UNIX time at which the animation loop started
    this._loopTimestamp = null;

    // Used for maintaining position when the animation is paused
    this._pausedAtTime = null;

    // The last millisecond position that was updated
    this._lastUpdatedMillisecond = 0;

    // The most recent loop iteration a frame was calculated for
    this._latestIteration = 0;

    // The most recent millisecond position within the loop that the animation
    // was updated to
    this._loopPosition = null;

    this._scheduleUpdate = getUpdateMethod();
    this._cancelUpdate = getCancelMethod();

    this._updateFn = () => {
      tick(this);
      updateToCurrentMillisecond(this);
    };

    /**
     * @member {Array.&lt;rekapi.renderer>} rekapi.Rekapi#renderers Instances of
     * {@link rekapi.renderer} classes, as inferred by the `context`
     * parameter provided to the {@link rekapi.Rekapi} constructor.  You can
     * add more renderers to this list manually; see the {@tutorial
     * multiple-renderers} tutorial for an example.
     */
    this.renderers = rendererBootstrappers
      .map(renderer => renderer(this))
      .filter(_ => _);
  }

  /**
   * Add a {@link rekapi.Actor} to the animation.  Decorates the added {@link
   * rekapi.Actor} with a reference to this {@link rekapi.Rekapi} instance as
   * {@link rekapi.Actor#rekapi}.
   *
   * @method rekapi.Rekapi#addActor
   * @param {(rekapi.Actor|Object)} [actor={}] If this is an `Object`, it is used to as
   * the constructor parameters for a new {@link rekapi.Actor} instance that
   * is created by this method.
   * @return {rekapi.Actor} The {@link rekapi.Actor} that was added.
   */
  addActor (actor = {}) {
    const rekapiActor = actor instanceof Actor ?
      actor :
      new Actor(actor);

    // You can't add an actor more than once.
    if (_.contains(this._actors, rekapiActor)) {
      return rekapiActor;
    }

    rekapiActor.context = rekapiActor.context || this.context;
    rekapiActor.rekapi = this;

    // Store a reference to the actor internally
    this._actors.push(rekapiActor);

    invalidateAnimationLength(this);
    rekapiActor.setup();

    fireEvent(this, 'addActor', rekapiActor);

    return rekapiActor;
  }

  /**
   * @method rekapi.Rekapi#getActor
   * @param {number} actorId
   * @return {rekapi.Actor} A reference to an actor from the animation by its
   * `id`.  You can use {@link rekapi.Rekapi#getActorIds} to get a list of IDs
   * for all actors in the animation.
   */
  getActor (actorId) {
    return this._actors.filter(actor => actor.id === actorId)[0];
  }

  /**
   * @method rekapi.Rekapi#getActorIds
   * @return {Array.&lt;number>} The `id`s of all {@link rekapi.Actor}`s in the
   * animation.
   */
  getActorIds () {
    return this._actors.map(actor => actor.id);
  }

  /**
   * @method rekapi.Rekapi#getAllActors
   * @return {Array.&lt;rekapi.Actor>} All {@link rekapi.Actor}s in the animation.
   */
  getAllActors () {
    return this._actors.slice();
  }

  /**
   * @method rekapi.Rekapi#getActorCount
   * @return {number} The number of {@link rekapi.Actor}s in the animation.
   */
  getActorCount () {
    return this._actors.length;
  }

  /**
   * Remove an actor from the animation.  This does not destroy the actor, it
   * only removes the link between it and this {@link rekapi.Rekapi} instance.
   * This method calls the actor's {@link rekapi.Actor#teardown} method, if
   * defined.
   * @method rekapi.Rekapi#removeActor
   * @param {rekapi.Actor} actor
   * @return {rekapi.Actor} The {@link rekapi.Actor} that was removed.
   */
  removeActor (actor) {
    // Remove the link between Rekapi and actor
    this._actors = _.without(this._actors, actor);
    delete actor.rekapi;

    actor.teardown();
    invalidateAnimationLength(this);

    fireEvent(this, 'removeActor', actor);

    return actor;
  }

  /**
   * Remove all {@link rekapi.Actor}s from the animation.
   * @method rekapi.Rekapi#removeAllActors
   * @return {Array.&lt;rekapi.Actor>} The {@link rekapi.Actor}s that were
   * removed.
   */
  removeAllActors () {
    return this.getAllActors().map(actor => this.removeActor(actor));
  }

  /**
   * Play the animation.
   *
   * @method rekapi.Rekapi#play
   * @param {number} [iterations=-1] If omitted, the animation will loop
   * endlessly.
   * @return {rekapi.Rekapi}
   */
  play (iterations = -1) {
    cancelLoop(this);

    if (this._playState === PAUSED) {
      // Move the playhead to the correct position in the timeline if resuming
      // from a pause
      this._loopTimestamp += Tweenable.now() - this._pausedAtTime;
    } else {
      this._loopTimestamp = Tweenable.now();
    }

    this._timesToIterate = iterations;
    this._playState = PLAYING;

    // Start the update loop
    tick(this);

    fireEvent(this, 'playStateChange');
    fireEvent(this, 'play');

    return this;
  }

  /**
   * Move to a specific millisecond on the timeline and play from there.
   *
   * @method rekapi.Rekapi#playFrom
   * @param {number} millisecond
   * @param {number} [iterations] Works as it does in {@link
   * rekapi.Rekapi#play}.
   * @return {rekapi.Rekapi}
   */
  playFrom (millisecond, iterations) {
    this.play(iterations);
    this._loopTimestamp = Tweenable.now() - millisecond;

    this._actors.forEach(
      actor => actor._resetFnKeyframesFromMillisecond(millisecond)
    );

    return this;
  }

  /**
   * Play from the last frame that was rendered with {@link
   * rekapi.Rekapi#update}.
   *
   * @method rekapi.Rekapi#playFromCurrent
   * @param {number} [iterations] Works as it does in {@link
   * rekapi.Rekapi#play}.
   * @return {rekapi.Rekapi}
   */
  playFromCurrent (iterations) {
    return this.playFrom(this._lastUpdatedMillisecond, iterations);
  }

  /**
   * Pause the animation.  A "paused" animation can be resumed from where it
   * left off with {@link rekapi.Rekapi#play}.
   *
   * @method rekapi.Rekapi#pause
   * @return {rekapi.Rekapi}
   */
  pause () {
    if (this._playState === PAUSED) {
      return this;
    }

    this._playState = PAUSED;
    cancelLoop(this);
    this._pausedAtTime = Tweenable.now();

    fireEvent(this, 'playStateChange');
    fireEvent(this, 'pause');

    return this;
  }

  /**
   * Stop the animation.  A "stopped" animation will start from the beginning
   * if {@link rekapi.Rekapi#play} is called.
   *
   * @method rekapi.Rekapi#stop
   * @return {rekapi.Rekapi}
   */
  stop () {
    this._playState = STOPPED;
    cancelLoop(this);

    // Also kill any shifty tweens that are running.
    this._actors.forEach(actor =>
      actor._resetFnKeyframesFromMillisecond(0)
    );

    fireEvent(this, 'playStateChange');
    fireEvent(this, 'stop');

    return this;
  }

  /**
   * @method rekapi.Rekapi#isPlaying
   * @return {boolean} Whether or not the animation is playing (meaning not paused or
   * stopped).
   */
  isPlaying () {
    return this._playState === PLAYING;
  }

  /**
   * @method rekapi.Rekapi#isPaused
   * @return {boolean} Whether or not the animation is paused (meaning not playing or
   * stopped).
   */
  isPaused () {
    return this._playState === PAUSED;
  }

  /**
   * @method rekapi.Rekapi#isStopped
   * @return {boolean} Whether or not the animation is stopped (meaning not playing or
   * paused).
   */
  isStopped () {
    return this._playState === STOPPED;
  }

  /**
   * Render an animation frame at a specific point in the timeline.
   *
   * @method rekapi.Rekapi#update
   * @param {number} [millisecond=this._lastUpdatedMillisecond] The point in
   * the timeline at which to render.  If omitted, this renders the last
   * millisecond that was rendered (it's a re-render).
   * @param {boolean} [doResetLaterFnKeyframes=false] If `true`, allow all
   * {@link rekapi.keyframeFunction}s later in the timeline to be run again.
   * This is a low-level feature, it should not be `true` (or even provided)
   * for most use cases.
   * @return {rekapi.Rekapi}
   */
  update (
    millisecond = this._lastUpdatedMillisecond,
    doResetLaterFnKeyframes = false
  ) {
    fireEvent(this, 'beforeUpdate');

    const renderOrder = this.sort ?
      _.sortBy(this._actors, this.sort) :
      this._actors;

    // Update and render each of the actors
    renderOrder.forEach(actor => {
      actor._updateState(millisecond, doResetLaterFnKeyframes);

      if (actor.wasActive) {
        actor.render(actor.context, actor.get());
      }
    });

    this._lastUpdatedMillisecond = millisecond;
    fireEvent(this, 'afterUpdate');

    return this;
  }

  /**
   * @method rekapi.Rekapi#getLastPositionUpdated
   * @return {number} The normalized timeline position (between 0 and 1) that
   * was last rendered.
   */
  getLastPositionUpdated () {
    return (this._lastUpdatedMillisecond / this.getAnimationLength());
  }

  /**
   * @method rekapi.Rekapi#getLastMillisecondUpdated
   * @return {number} The millisecond that was last rendered.
   */
  getLastMillisecondUpdated () {
    return this._lastUpdatedMillisecond;
  }

  /**
   * @method rekapi.Rekapi#getAnimationLength
   * @return {number} The length of the animation timeline, in milliseconds.
   */
  getAnimationLength () {
    if (!this._animationLengthValid) {
      this._animationLength = Math.max.apply(
        Math,
        this._actors.map(actor => actor.getEnd())
      );

      this._animationLengthValid = true;
    }

    return this._animationLength;
  }

  /**
   * Bind a {@link rekapi.eventHandler} function to a Rekapi event.
   * @method rekapi.Rekapi#on
   * @param {string} eventName Valid values are:
   *
   * - `"animationComplete"`: Fires when all animation loops have completed.
   * - `"playStateChange"`: Fires when the animation is played, paused, or
   *   stopped.
   * - `"play"`: Fires when the animation is {@link rekapi.Rekapi#play}ed.
   * - `"pause"`: Fires when the animation is {@link rekapi.Rekapi#pause}d.
   * - `"stop"`: Fires when the animation is {@link rekapi.Rekapi#stop}ped.
   * - `"beforeUpdate"`: Fires each frame before all actors are rendered.
   * - `"afterUpdate"`: Fires each frame after all actors are rendered.
   * - `"addActor"`: Fires when an actor is added.  `data` is the
   *   {@link rekapi.Actor} that was added.
   * - `"removeActor"`: Fires when an actor is removed.  `data` is the {@link
   *   rekapi.Actor} that was removed.
   * - `"beforeAddKeyframeProperty"`: Fires just before the point where a
   *   {@link rekapi.KeyframeProperty} is added to the timeline.  This event is
   *   called before any modifications to the timeline are done.
   * - `"addKeyframeProperty"`: Fires when a keyframe property is added.
   *   `data` is the {@link rekapi.KeyframeProperty} that was added.
   * - `"beforeRemoveKeyframeProperty"`: Fires just before the point where a
   *   {@link rekapi.KeyframeProperty} is removed.  This
   *   event is called before any modifications to the timeline are done.
   * - `"removeKeyframeProperty"`: Fires when a {@link rekapi.KeyframeProperty}
   *   is removed.  This event is fired _before_ the internal state of the
   *   keyframe (but not the timeline, in contrast to the
   *   `beforeRemoveKeyframeProperty` event) has been updated to reflect the
   *   keyframe property removal (this is in contrast to
   *   `removeKeyframePropertyComplete`).  `data` is the {@link
   *   rekapi.KeyframeProperty} that was removed.
   * - `"removeKeyframePropertyComplete"`: Fires when a {@link
   *   rekapi.KeyframeProperty} has finished being removed from the timeline.
   *   Unlike `removeKeyframeProperty`, this is fired _after_ the internal
   *   state of Rekapi has been updated to reflect the removal of the keyframe
   *   property. `data` is the {@link rekapi.KeyframeProperty} that was
   *   removed.
   * - `"addKeyframePropertyTrack"`: Fires when the a keyframe is added to an
   *   actor that creates a new keyframe property track.  `data` is the {@link
   *   rekapi.KeyframeProperty} that was added to create the property track.  A
   *   reference to the actor that the keyframe property is associated with can
   *   be accessed via `data.actor` and the track name that was added can be
   *   determined via `data.name`.
   * - `"removeKeyframePropertyTrack"`: Fires when the last keyframe property
   *   in an actor's keyframe property track is removed.  Rekapi automatically
   *   removes property tracks when they are emptied out, which causes this
   *   event to be fired.  `data` is the name of the track that was
   *   removed.
   * - `"timelineModified"`: Fires when a keyframe is added, modified or
   *   removed.
   * - `"animationLooped"`: Fires when an animation loop ends and a new one
   *   begins.
   * @param {rekapi.eventHandler} handler The event handler function.
   * @return {rekapi.Rekapi}
   */
  on (eventName, handler) {
    if (!this._events[eventName]) {
      return this;
    }

    this._events[eventName].push(handler);

    return this;
  }

  /**
   * Manually fire a Rekapi event, thereby calling all {@link
   * rekapi.eventHandler}s bound to that event.
   * @param {string} eventName The name of the event to trigger.
   * @param {any} [data] Optional data to provide to the `eventName` {@link
   * rekapi.eventHandler}s.
   * @method rekapi.Rekapi#trigger
   * @return {rekapi.Rekapi}
   */
  trigger (eventName, data) {
    fireEvent(this, eventName, data);

    return this;
  }

  /**
   * Unbind one or more handlers from a Rekapi event.
   * @method rekapi.Rekapi#off
   * @param {string} eventName Valid values correspond to the list under
   * {@link rekapi.Rekapi#on}.
   * @param {rekapi.eventHandler} [handler] A reference to the {@link
   * rekapi.eventHandler} to unbind.  If omitted, all {@link
   * rekapi.eventHandler}s bound to `eventName` are unbound.
   * @return {rekapi.Rekapi}
   */
  off (eventName, handler) {
    if (!this._events[eventName]) {
      return this;
    }

    this._events[eventName] = handler ?
      _.without(this._events[eventName], handler) :
      [];

    return this;
  }

  /**
   * Export the timeline to a `JSON.stringify`-friendly `Object`.
   *
   * @method rekapi.Rekapi#exportTimeline
   * @return {Object} This data can later be consumed by {@link
   * rekapi.Rekapi#importTimeline}.
   */
  exportTimeline () {
    const exportData = {
      duration: this.getAnimationLength(),
      actors: this._actors.map(actor => actor.exportTimeline())
    };


    const curves = {};

    _.chain(Tweenable.formulas)
      .filter(formula => typeof formula.x1 === 'number')
      .each(curve =>
        curves[curve.displayName] =
          _.pick(curve, 'displayName', 'x1', 'y1', 'x2', 'y2')
      )
      .value();

    exportData.curves = curves;

    return exportData;
  }

  /**
   * Import data that was created by {@link rekapi.Rekapi#exportTimeline}.
   * This sets up all actors, keyframes, and custom easing curves specified in
   * the `rekapiData` parameter.  These two methods collectively allow you
   * serialize an animation (for sending to a server for persistence, for
   * example) and later recreating an identical animation.
   *
   * @method rekapi.Rekapi#importTimeline
   * @param {Object} rekapiData Any object that has the same data format as the
   * object generated from {@link rekapi.Rekapi#exportTimeline}.
   */
  importTimeline (rekapiData) {
    _.each(rekapiData.curves, (curve, curveName) =>
      setBezierFunction(
        curveName,
        curve.x1,
        curve.y1,
        curve.x2,
        curve.y2
      )
    );

    _.each(rekapiData.actors, actorData => {
      const actor = new Actor();
      actor.importTimeline(actorData);
      this.addActor(actor);
    });
  }

  /**
   * @method rekapi.Rekapi#getEventNames
   * @return {Array.&lt;string>} The list of event names that this Rekapi instance
   * supports.
   */
  getEventNames () {
    return Object.keys(this._events);
  }

  /**
   * Get a reference to a {@link rekapi.renderer} that was initialized for this
   * animation.
   * @method rekapi.Rekapi#getRendererInstance
   * @param {rekapi.renderer} rendererConstructor The type of {@link
   * rekapi.renderer} subclass (such as {@link rekapi.CanvasRenderer} or {@link
   * rekapi.DOMRenderer}) to look up an instance of.
   * @return {rekapi.renderer|undefined} The matching {@link rekapi.renderer},
   * if any.
   */
  getRendererInstance (rendererConstructor) {
    return this.renderers.filter(renderer =>
      renderer instanceof rendererConstructor
    )[0];
  }

  /**
   * Move a {@link rekapi.Actor} around within the internal render order list.
   * By default, a {@link rekapi.Actor} is rendered in the order it was added
   * with {@link rekapi.Rekapi#addActor}.
   *
   * This method has no effect if {@link rekapi.Rekapi#sort} is set.
   *
   * @method rekapi.Rekapi#moveActorToPosition
   * @param {rekapi.Actor} actor
   * @param {number} layer This should be within `0` and the total number of
   * {@link rekapi.Actor}s in the animation.  That number can be found with
   * {@link rekapi.Rekapi#getActorCount}.
   * @return {rekapi.Rekapi}
   */
  moveActorToPosition (actor, position) {
    if (position &lt; this._actors.length &amp;&amp; position > -1) {
      this._actors = _.without(this._actors, actor);
      this._actors.splice(position, 0, actor);
    }

    return this;
  }
}
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.3</a> on Sun Sep 03 2017 10:40:02 GMT-0700 (PDT) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
