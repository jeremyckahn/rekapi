<!DOCTYPE html>
<html>
<head>
  <link href="../lib/shifty/tests/qunit/qunit.css" rel="stylesheet" type="text/css" />
  <script src="../lib/shifty/tests/qunit/qunit.js"></script>
  <script src="../lib/require.js"></script><script>
  
  var KAPI_DEBUG = true
      ,internalDebugNow
      ,SHIFTY_DEBUG_NOW = function () {
        return internalDebugNow();
      };
  
  require([
      '../lib/underscore/underscore.js'
      ,'../lib/shifty/shifty.js'], 
      function () {
        
        require(['../src/rekapi.core.js'], function () {
          require(['../src/rekapi.actor.js'], function () {
            require(['../src/rekapi.canvas.js'
                    ,'../src/rekapi.interpolate.js'], function () {
              setTimeout(runTests, 1);
            });
          });
        });
    
  });
  
  function setupTestKapi () {
    var sandbox
        ,kapi
        ,actor;

    sandbox = document.getElementById('sandbox');
    kapi = new Kapi(sandbox);

    kapi.canvas_style('background', '#ddd');
    kapi.canvas_height(300);
    kapi.canvas_width(500);
    
    return kapi;
  }
  
  function  setupTestActor (forKapi) {
    var actor;
    
    actor = new Kapi.Actor(forKapi, {
      'draw': function (canvas_context, state) {
        canvas_context.beginPath();
          canvas_context.arc(
            this.x || 0,
            this.y || 0,
            this.radius || 0,
            0,
            Math.PI*2, 
            true);
          canvas_context.fillStyle = this.color || '#f0f';
          canvas_context.fill();
          canvas_context.closePath();

          return this;
      }
    });
    
    forKapi.addActor(actor);
    return actor;
  }
  
  function runTests () {
    
    module("calculateLoopPosition");
    
    test('Calculate accurate position in the tween', function () {
      var testKapi
          ,testActor1
          ,calculatedMillisecond;
    
      testKapi = setupTestKapi();
      testActor1 = setupTestActor(testKapi);
      
      testActor1
        .keyframe(0, {})
        .keyframe(2000, {});
        
      calculatedMillisecond =  Kapi._private
        .calculateLoopPosition(testKapi, 1000, 0);
    
      equals(calculatedMillisecond, 1000, 
          'Calculated a midpoint of the animation');
    });
    
    
    test('Calculate accurate overflow position in the tween', function () {
      var testKapi
          ,testActor1
          ,calculatedMillisecond;
    
      testKapi = setupTestKapi();
      testActor1 = setupTestActor(testKapi);
      
      testActor1
        .keyframe(0, {})
        .keyframe(2000, {});
        
      calculatedMillisecond = 
          Kapi._private.calculateLoopPosition(testKapi, 2500, 1);
    
      equals(calculatedMillisecond, 500, 
          'Calculated an overflow position of the animation');
    });
   

    module("determineCurrentLoopIteration");
    
    test('Calculate a given iteration of a loop', function () {
      var testKapi
          ,testActor1
          ,calculatedIteration;
    
      testKapi = setupTestKapi();
      testActor1 = setupTestActor(testKapi);
      
      testActor1
        .keyframe(0, {})
        .keyframe(2000, {});
      
      calculatedIteration = 
          Kapi._private.determineCurrentLoopIteration(testKapi, 0);
    
      equals(calculatedIteration, 0, 
          'Calculated the beginning of the first iteration');


      calculatedIteration = 
          Kapi._private.determineCurrentLoopIteration(testKapi, 1000);
    
      equals(calculatedIteration, 0, 
          'Calculated the middle of the first iteration');


      calculatedIteration = 
          Kapi._private.determineCurrentLoopIteration(testKapi, 1999);
    
      equals(calculatedIteration, 0, 
          'Calculated the end of the first iteration');


      calculatedIteration = 
          Kapi._private.determineCurrentLoopIteration(testKapi, 4000);
    
      equals(calculatedIteration, 2, 
          'Calculated the beginning of an iteration greater than 1');


      calculatedIteration = 
          Kapi._private.determineCurrentLoopIteration(testKapi, 5000);
    
      equals(calculatedIteration, 2, 
          'Calculated the middle of an iteration greater than 1');


      calculatedIteration = 
          Kapi._private.determineCurrentLoopIteration(testKapi, 5999);
    
      equals(calculatedIteration, 2, 
          'Calculated the end of an iteration greater than 1');
    });
    
    
    module('calculateTimeSinceStart');

    test('Calculate the delta of the current time and when the animation began'
      ,function () {
      var testKapi
          ,testActor1
          ,calculatedTime;
    
      testKapi = setupTestKapi();
      testActor1 = setupTestActor(testKapi);
      
      testActor1
        .keyframe(0, {})
        .keyframe(2000, {});

      internalDebugNow = function () {
        return 0;
      };

      testKapi.play();

      internalDebugNow = function () {
        return 500;
      };
      
      calculatedTime = Kapi._private.calculateTimeSinceStart(testKapi);
      equals(calculatedTime, 500, 
          'The expected amount of time since beginning the animation was calculated');
    
    });


    module('isAnimationComplete');

    test('Determine if the animation has completed in a finite loop'
      ,function () {
      var testKapi
          ,testActor1
          ,animationIsComplete;
    
      testKapi = setupTestKapi();
      testActor1 = setupTestActor(testKapi);
      
      testActor1
        .keyframe(0, {})
        .keyframe(2000, {});

      testKapi.play(3);

      animationIsComplete = Kapi._private.isAnimationComplete(testKapi, 1);
      equals(animationIsComplete, false,
          'The animation is not complete');

      animationIsComplete = Kapi._private.isAnimationComplete(testKapi, 2);
      equals(animationIsComplete, false,
          'The last iteration of a loop is condsider to be not complete');

      animationIsComplete = Kapi._private.isAnimationComplete(testKapi, 3);
      equals(animationIsComplete, true,
          'An iteration after the specified amount of iterations is considered to be complete');
    });
    
    test('Determine if the animation has completed in an infinite loop'
      ,function () {
      var testKapi
          ,testActor1
          ,animationIsComplete;
    
      testKapi = setupTestKapi();
      testActor1 = setupTestActor(testKapi);
      
      testActor1
        .keyframe(0, {})
        .keyframe(2000, {});

      testKapi.play();

      animationIsComplete = Kapi._private.isAnimationComplete(testKapi, 1);
      equals(animationIsComplete, false,
          'The animation is not complete');

      animationIsComplete = Kapi._private.isAnimationComplete(testKapi, 3);
      equals(animationIsComplete, false,
          'The animation is not complete');

      animationIsComplete = Kapi._private.isAnimationComplete(testKapi, 1000);
      equals(animationIsComplete, false,
          'The animation is not complete');
    });


    module('updatePlayState');

    test('Determine if the animation\'s internal state is "playing" after evaluating a given iteration'
      ,function () {
      var testKapi
          ,testActor1;
    
      testKapi = setupTestKapi();
      testActor1 = setupTestActor(testKapi);
      
      testActor1
        .keyframe(0, {})
        .keyframe(2000, {});

      testKapi.play(3);

      Kapi._private.updatePlayState(testKapi, 0);
      equals(testKapi.isPlaying(), true, 'The animation is still running');

      Kapi._private.updatePlayState(testKapi, 2);
      equals(testKapi.isPlaying(), true, 'The animation is still running');

      Kapi._private.updatePlayState(testKapi, 3);
      equals(testKapi.isPlaying(), false, 'The animation is still complete');
    });
  }
  </script>
</head>
<body>
  <h1 id="qunit-header"><a href="https://github.com/jeremyckahn/rekapi">Rekapi</a></h1>
   <h2 id="qunit-banner"></h2>
   <div id="qunit-testrunner-toolbar"></div>
   <h2 id="qunit-userAgent"></h2>
   <ol id="qunit-tests"></ol>
   <div id="qunit-fixture"></div>
  <canvas id="sandbox"></canvas>
</body>
</html>
